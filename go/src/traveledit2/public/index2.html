<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* { margin: 0; padding: 0; 
background-color: black; color: white;
}
body { background-color: black; }
.text { border: none; color: lime;
/*border: 1px solid lime;*/
}
#toolbar {
  display: flex;
  flex-flow: row nowrap;
  overflow: scroll;
  -webkit-overflow-scrolling: touch;
}
#toolbar div {
  background-color: navy;
  padding: 10px;
  margin: 1px;
  flex: 1 0 auto;

}
</style>
<div id=s style=";"></div>

<form onsubmit=newLine(event)>

<input id=theTextBefore class=text
style="font: 8px Courier;
width: 375px;
/* display: none; see what it looks like without */
"
onfocus=handleFocusBefore()
onblur=handleBlur()
>
<input id=theText class=text
style="font: 20px Courier;
width: 375px;
height:30px;
"
onfocus=handleFocusIn()
onblur=handleBlur()
oninput=saveLine()
onkeydown=handleKeydown(event)
>
<input id=theTextAfter class=text
style="font: 8px Courier;
width: 375px;
/* display: none; see what it looks like without */
"
onfocus=handleFocusAfter()
onblur=handleBlur()
>
<input type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>

<!-- 
as of now the canvas doesn't get resized
so it has to be at least as big as the biggest canvasHeight x canvasWith size.
Also note that the css width needs to be 1/3 of
the with attribute, and same for height.
-->
<canvas id=c width=1125 height=1500
style="width: 375px; height:500px;"
ontouchstart=onStart(event)
></canvas>
<div id=toolbar>
  <div onclick=insertLine()>new</div>
  <div onclick=del()>del</div>
  <div onclick=paste()>paste</div>
  <div onclick=dup()>dup</div>
  <!-- copy is just a dup del -->
  <!-- <div onclick=copy()>copy</div>
  -->
  <div onclick=toggleLog()>log</div>
  <div onclick=clearLog()>clear</div>
  <div onclick=findDown()>find down</div>
  <div onclick=findUp()>find up</div>
  <div onclick=undo()>undo</div>
  <div onclick=redo()>redo</div>
  <div>replace</div>
</div>

<div>
<input type=text id=searchText
  style="font-size: 20px"
>
</div>

</div>
<script>
// it's important that this go in it's own script tag
window.onerror = function(message, url, lineNumber, columnNumber, error) {
    alert(lineNumber + ": " + message)
}
</script>
<script>
var lines = []
var logLines = []
var logShown = false
// LINES GO HERE
var contentLines = lines
</script>
<script>
var t = c.getContext("2d")
var version = 0
var savedVersion = 0
var savingVersion = -1
var saveEveryMS = 1000
var fontHeight=48
var fontWidth=26
var fontCSS = "40px 'Courier'"
var cursorX=0
var cursorY=0
var offsetX = 0
var offsetY = 0
// 4 chars for line number and 1 for space
var marginLeft = 5

// Note that the width and height need to match
// the width and height of the canvas tag attribute.
var canvasWidth=1125
var canvasHeightKeyboard=800
var canvasHeightFull=1575
var maxLines = 0
var maxCols = Math.ceil(canvasWidth / fontWidth)
var canvasHeight = 0
setCanvasHeight(canvasHeightFull)
var pointWidth=325
var pointHeight=500
var touchScale=3
var cursorLineIndex = 0
var cursorColIndex = 0

// TODO: reconcile inEdit and document.activeElement usage
var inEdit = false
var copyBuffer = ""
var cursorType = "move"
// cursorType can be 
// * move
// * select
// * line-select
// * vertical-select

var selectTimeout
var selectTimeoutMillis = 150
var selectedRegions = []

function log(v) {
  logLines.push(v)
}
function toggleLog() {
 logShown = !logShown
 if (logShown) {
   lines = logLines
 } else {
   lines = contentLines
 }
 render()
}

function clearLog() {
  logLines = []
  if (logShown) lines = logLines
  render()
}
// check for A-Za-z0-9_
function isWordy(a) {
  return (
     (a >= 65 && a <= 90) ||  // A-Z
     (a >= 97 && a <= 122) || // a-z
     (a >= 48 && a <= 57) ||  // 0-9
     (a == 95)                // _
  ) 
}
function getWordAtCursor() {
  var line = lines[cursorLineIndex]
  log("getting word: " + line)
  for (var startIndex=cursorColIndex-1; startIndex>=0; startIndex--) {
    if (!isWordy(line.charCodeAt(startIndex))) {
       startIndex += 1
       break
    }
  }
  for (var endIndex=cursorColIndex; endIndex < line.length; endIndex++) {
    if (!isWordy(line.charCodeAt(endIndex))) {
      break
    }
  }
  log(`start: ${startIndex} end: ${endIndex}`)
  //if (startIndex < endIndex) {
    return line.substring(startIndex, endIndex)
  //}
  return ""
}
function findDown() {
  if (searchText.value == "") {
    searchText.value = getWordAtCursor()
  }
  log("searching for: " + searchText.value)
  for (var i=cursorLineIndex; i<lines.length; i++) {
    var lineToSearch = lines[i]
    if (i == cursorLineIndex) {
      lineToSearch = lineToSearch.substr(cursorColIndex)
    }
    var pos = lineToSearch.indexOf(searchText.value)
    if (pos != -1) {
      offsetY = i
      cursorLineIndex = i
      cursorColIndex = pos + searchText.value.length
      updateCursorXY()
      render()
      return
    }
  }
  alert("not found")
}

function updateCursorXY() {
  cursorX = (cursorColIndex - offsetX) * fontWidth
  cursorY = (cursorLineIndex - offsetY) * fontHeight
}


function dup() {
  lines.splice(cursorLineIndex, 0, lines[cursorLineIndex])
  cursorLineIndex += 1
  render()
  docChanged()
}

function copy() {
  copyBuffer = lines[cursorLineIndex]
}


// populate lines
// for (var i=0; i<100000; i++) {
//   lines.push("so this is line " + i + " " + Date.now())
// }

function docChanged() {
   if (logShown) return
   version += 1 
}

function setCanvasHeight(h) {
  canvasHeight = h
  maxLines = Math.ceil(canvasHeight / fontHeight)
}

function paste() {
  lines.splice(cursorLineIndex + 1, 0, copyBuffer)
  cursorLineIndex += 1
  render()
  docChanged()
}

function del() {
  copyBuffer = lines[cursorLineIndex]
  lines.splice(cursorLineIndex, 1)
  render()
  docChanged()
}

function newLine(e) {
  e.preventDefault()
  theLine = lines[cursorLineIndex]
  lines.splice(cursorLineIndex + 1, 0, theLine.substr(theText.selectionStart))
  lines[cursorLineIndex] = theLine.substr(0, theText.selectionStart)

  cursorLineIndex += 1
  cursorColIndex = 0
  render()
  theText.focus()
  theText.setSelectionRange(cursorColIndex, cursorColIndex)
  docChanged()
  return false
}

function handleFocusAfter() {
  if (cursorLineIndex == lines.Length - 1) return
  cursorLineIndex += 1
  setCanvasHeight(canvasHeightKeyboard)
  if (cursorLineIndex < offsetY || cursorLineIndex > (offsetY + maxLines)) {
    offsetY = cursorLineIndex - maxLines
  }
  updateCursorXY()
  render()
  theText.focus()
  theText.setSelectionRange(cursorColIndex, cursorColIndex)
}

function handleFocusBefore() {
  if (cursorLineIndex == 0) return
  cursorLineIndex -= 1
  setCanvasHeight(canvasHeightKeyboard)
  if (cursorLineIndex < offsetY || cursorLineIndex > (offsetY + maxLines)) {
    offsetY = 0
  }
  updateCursorXY()
  render()
  theText.focus()
  theText.setSelectionRange(cursorColIndex, cursorColIndex)
}

function handleFocusIn() {
  setCanvasHeight(canvasHeightKeyboard)
  if (cursorLineIndex < offsetY || cursorLineIndex > (offsetY + maxLines)) {
    offsetY = cursorLineIndex - maxLines
  }
  render()
  theText.setSelectionRange(cursorColIndex, cursorColIndex)
}

function handleBlur() {
  setCanvasHeight(canvasHeightFull)
  render()
}

function save() {
    // using a single for loop to
    // simulate a goto
    // breaks will make sure the 'cleanup' step gets called
    for (var s=0; s<1; s++) { 
    if (logShown) break
    // loop once so I can simulate a goto for cleanup by breaking
    for (var i=0; i<1; i++) {
      if (savedVersion == version) {
        break
      }
      savingVersion = version
      fetch(location.href, {
        method: "POST",
        cache: "no-cache",
        headers: { "Content-Type": "application/x-www-form-urlencoded"},
        body: "content=" + encodeURIComponent(lines.join("\n"))
      })
      .then(r => r.json())
      .then(v => {
          if (v.saved) {
            savedVersion = savingVersion
            savingVersion = -1
          }
          render()
      })
      .catch(e => alert(e))
      render()
    }
    }
    setTimeout(save, saveEveryMS)
}
setTimeout(save, saveEveryMS)

function handleKeydown(e) {
  // 8 means backspace
  if (e.keyCode == 8 && theText.selectionStart == 0 && cursorLineIndex != 0) {
    e.preventDefault()
    var theLine = lines[cursorLineIndex]

    lines.splice(cursorLineIndex, 1)
    cursorLineIndex -= 1
    var prevLine = lines[cursorLineIndex]
    lines[cursorLineIndex] = lines[cursorLineIndex] + theLine
    render()
    theText.setSelectionRange(prevLine.length, prevLine.length)
    docChanged()
  }
  return true
}

function saveLine() {
  cursorColIndex = theText.selectionStart
  lines[cursorLineIndex] = theText.value
  cursorX = (cursorColIndex - offsetX) * fontWidth
  cursorY = (cursorLineIndex - offsetY) * fontHeight
  inEdit = true
  render()
  inEdit = false
  docChanged()
}
function bind(v, min, max) {
  if (v < min) v = min
  if (v > max) v = max
  return v
}
function charAt(lines, y, x) {
  var line = lines[y]
  if (!line) return ""
  var theChar = line[x]
  if (!theChar) return ""
  return theChar
}

function render() {
  var selStart = theText.selectionStart
  var selEnd = theText.selectionEnd
  c.width = c.width // one way to clear
  t.fillStyle = "rgba(255, 0, 0, 0.5)"
  t.fillRect(cursorX, cursorY, 6, fontHeight)
  var yPos = (cursorLineIndex - offsetY) * fontHeight
  var xPos = (cursorColIndex - offsetX) * fontWidth
  t.fillStyle = "rgba(0, 0, 255, 0.1)"
  t.fillRect(0, yPos, canvasWidth, fontHeight)
  t.fillStyle = cursorType == "move" ? "red" : "cyan"
  t.fillRect(xPos, yPos, 6, fontHeight)

  // the selected areas
  for (var i=0; i<selectedRegions.length;i++) {
    // todo: normalize region start and end
    var r = selectedRegions[i]
    t.fillStyle = "blue"
    log(JSON.stringify(r))
    for (var y=r.startY-offsetY; y<=r.stopY-offsetY; y++) {
      t.fillRect(0, y*fontHeight, 500, fontHeight) 
    } 
  }
  t.font = fontCSS
  t.textBaseline = "top"
  s.innerHTML = "docver:" + version + 
    " savedver:" + savedVersion +
    " savingver:" + savingVersion +
    " x,y:" + cursorX + "," + cursorY
  for (var y=0; y <= maxLines; y++) {
    var lineNumber = (y+offsetY).toString().padStart(4, " ")
    if (offsetX < -1) {
      t.fillStyle = "magenta"
      for (var i=0; i<-offsetX-1; i++) {
        var lineNumberIndex = offsetX + 5 + i
        t.fillText(lineNumber.charAt(lineNumberIndex), i*fontWidth, y*fontHeight)
      }
    }

    t.fillStyle = "white"
    for (var x=0; x <= maxCols; x++) {  
      t.fillText( charAt(lines, y+offsetY, x+offsetX), x*fontWidth, y*fontHeight)
    }
  }
  cursorLine = lines[cursorLineIndex] || ""
  if (!inEdit) {
    theText.value = cursorLine
    theTextBefore.value = lines[cursorLineIndex - 1] || ""
    theTextAfter.value = lines[cursorLineIndex + 1] || ""
  }

  // set the selection range back to what it was
  // if it needs to be changed, some functions will change it
  // after the call to render.
  // TODO: have a state variable for what it should be.
  if (document.activeElement == theText) {
      theText.setSelectionRange(selStart, selEnd)
  }
 // alert(charAt(lines, 0, 0))
}

function ensureSign(sign, v) {
  if (sign < 0 && v > 0) return -v
  if (sign > 0 && v < 0) return -v
  return v
}
function onStart(e) {
  e.preventDefault()
  var startTouchX = e.touches[0].pageX
  var startTouchY = e.touches[0].pageY
  var startX = cursorX
  var startY = cursorY

  var lastTouchX = startTouchX
  var lastTouchY = startTouchY
  var lastTime = Date.now()
  var firstMove = true
  var moved = false
  render()
  var selectedRegion = {}
  var selectAction = function() {
    selectedRegions = []
    cursorType = "select"
    selectedRegion.startX = cursorColIndex
    selectedRegion.startY = cursorLineIndex
    selectedRegions.push(selectedRegion)
    render()
  }
  selectTimeout = setTimeout(selectAction, selectTimeoutMillis)
  var onMove = function(e) {
    clearTimeout(selectTimeout)
    selectTimeout = setTimeout(selectAction, selectTimeoutMillis)
    //var diffTouchX = e.touches[0].pageX - startTouchX
    //var diffTouchY = e.touches[0].pageY - startTouchY
    //cursorX = bind(startX + diffTouchX*touchScale, 0, canvasWidth)
    //cursorY = bind(startY + diffTouchY*touchScale, 0, canvasHeight)
    
    moved = true
    var diffLastTouchX = e.touches[0].pageX - lastTouchX
    var diffLastTouchY = e.touches[0].pageY - lastTouchY
    var signX = diffLastTouchX < 0 ? -1: 1
    var signY = diffLastTouchY < 0 ? -1 : 1
    thePow = firstMove ? 1 : 2
    cursorX = cursorX + ensureSign(signX, Math.round(Math.pow(diffLastTouchX, thePow)*touchScale))
    cursorY = cursorY + ensureSign(signY, Math.round(Math.pow(diffLastTouchY, thePow)*touchScale))
    lastTouchX = e.touches[0].pageX
    lastTouchY = e.touches[0].pageY

    var changedY = false
    if (cursorY > canvasHeight) {
      var extendY = cursorY - canvasHeight
      cursorY = canvasHeight //Math.round(canvasHeight - (canvasHeight/4))
      offsetY += Math.ceil(extendY/fontHeight)
      if (offsetY > lines.length - 10) offsetY = lines.length - 10
      changedY = true
    } else if (cursorY < 0) {
      var extendY = cursorY
      cursorY = 0
      offsetY += Math.floor(extendY/fontHeight)
      changedY = true
      if (offsetY < 0) offsetY = 0
    }

    if (cursorX > canvasWidth) {
      var extendX = cursorX - canvasWidth
      cursorX = canvasWidth //Math.round(canvasHeight - (canvasHeight/4))
      
      // if (!changedY) offsetX += Math.round(extendX/fontWidth)
      if (!changedY) offsetX += Math.ceil(extendX/fontWidth)
    } else if (cursorX < 0) {
      var extendX = cursorX
      cursorX = 0
      // if (!changedY) offsetX += Math.round(extendX/fontWidth)
      if (!changedY) offsetX += Math.floor(extendX/fontWidth)
      if (offsetX < -marginLeft) offsetX = -marginLeft
    }
    cursorLineIndex = Math.round(cursorY/fontHeight) + offsetY
    cursorColIndex = Math.round(cursorX/fontWidth) + offsetX
    firstMove = false
    if (cursorType == "select") {
      selectedRegion.stopX = cursorColIndex
      selectedRegion.stopY = cursorLineIndex
    }
    render()
    return false
  }
  var onEnd = function(e) {
    clearTimeout(selectTimeout)
    // it's not straightforward to do a setTimeout
    // here because iOS Safari doesn't like to focus
    // text elements when not responding to user action
    // maybe there are workarounds.
    //tapTimeout = setTimeout(function() {
      if (!moved && cursorType == "move") {
        log("calling focus")
        offsetY = bind(cursorLineIndex - 5, 0, cursorLineIndex)
        updateCursorXY()
        theText.focus()
        theText.setSelectionRange(cursorColIndex, cursorColIndex)
      } 
      document.body.removeEventListener("touchmove", onMove)
      document.body.removeEventListener("touchend", onEnd)
      cursorType = "move"
      render()
    //}, 100)
  } 
  document.body.addEventListener("touchmove", onMove)
  document.body.addEventListener("touchend", onEnd)
}
</script>
