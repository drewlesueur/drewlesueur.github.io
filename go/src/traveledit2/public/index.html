<!doctype html>
<html>
<head>
<script>
var proxyPath = ""
// PROXYPATH GOES HERE
</script>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, max-scale=1">
<meta name="apple-mobile-web-app-title" content="Editor">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="hidden">

<meta charset='utf-8'>
<!-- TODO: make this work with path proxy ok?3 -->
<script>
document.write(`
<script src="`+proxyPath+`/tepublic/diff.js"></scr`+`ipt>
<script src="`+proxyPath+`/tepublic/md52.js"></scr`+`ipt>
<script src="`+proxyPath+`/tepublic/grapheme-splitter.js"></scr`+`ipt>
`)
</script>
<style>
/*
@font-face {
  font-family: IosevkaLucida;
  src: url('http://tel.drewles.com:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf');
}
@import url('https://fonts.googleapis.com/css2?family=Nova+Mono&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Anonymous+Pro&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Overpass+Mono&display=swap');
// @font-face {
//   font-family: GoMono;
//   src: url(tepublic/fonts/Go-Mono.ttf);
// }

// @import url('https://fonts.googleapis.com/css2?family=Courier+Prime&family=Inconsolata&family=JetBrains+Mono&family=Nanum+Gothic+Coding&family=Overpass+Mono&family=Oxygen+Mono&family=Roboto+Mono&family=Share+Tech+Mono&family=VT323&family=Xanh+Mono&display=swap');

// @font-face {
//   font-family: IosevkaLucida;
//   src: url('tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf');
// }


// @font-face {
//   font-family: IosevkaLucida;
//   src: url('http://tel.drewles.com:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf');
// }
// @font-face {
//   font-family: Iosevka;
//   src: url('http://tel.drewles.com:8000/tepublic/iosevka/iosevka-fixed-regular.ttf');
// }

// @font-face {
//   font-family: IosevkaSlab;
//   src: url('http://tel.drewles.com:8000/tepublic/iosevka_slab/iosevka-fixed-slab-regular.ttf');
// }
*/
* {
    margin: 0; padding: 0;
    box-sizing: border-box;
}
.dark {
    background-color: black;
    color: white;
}
.light {
    background-color: lightyellow;
    --background-color: white;
    color: black;
}
.text { border: none; color: cyan;
}


.toolbar {
    display: flex;
    flex-flow: row nowrap;
    --flex-flow: row wrap;
    overflow: scroll;
    -webkit-overflow-scrolling: touch;
    --font-family: 'IosevkaLucida';
    --font-family: 'Courier';
}
.hidden {
   display: none;
}

body.dark .toolbar div {
    background-color: black;
    /* see renderDarkMode */
    color: rgba(255, 255, 200);
    border: 1px solid rgba(255, 255, 200);
    opacity: 0.7;
    --text-decoration: underline;
}
body.dark .toolbar div.selected {
    background-color: gray;
    color: black;
    border: 1px solid black;
}
body.light .toolbar div {
    --background-color: #077;
    --color: white;
    background-color: lightyellow;
    color: black;
    border: 1px solid black;
}
body.light .toolbar div.selected {
    background-color: black;
    color: rgba(255, 255, 200);
    border: 1px solid rgba(255, 255, 200);
}

.toolbar div {
    --border-radius: 17px;
}
.toolbar .square {
    padding: 0px;
    width: 40px;
    height: 34px;
    --height: 20px;
    margin: 1px;
    flex: 1 0 auto;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}
.toolbar .longButton {
    padding: 0px;
    --width: 80px;
    width: 60px;
    --height: 28px;
    height: 34px;
    margin: 1px;
    flex: 1 0 auto;
    --font-size: 12px;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

#fileRow div {
    font-size: 10px !important;
}

input[type="text"] {
    font-size: 16px;
    --border: 1px solid cyan;
    border: none;
}

#searchText {
    border: none;
}
#searchText::placeholder {
    --color: red;
    font-size: 10px;
}
</style>
</head>
<body class=dark>
<div id=topPadding style="height: 0px;"></div>
<!-- status bar -->
<div id=s style="font-size: 12px;
display: none;
position: absolute;
top: 10px; right:0;
z-index: 999;
color: magenta;
opacity: 0.5;
"></div>

<form onsubmit="findDownForm(event)">
    <input class=dark id=searchTextBefore class=text type=text
    style="
    --font: 8px IosevkaLucida;
    font: px Courier;
    height:1px; overflow: hidden;
    display: block;"
    onfocus=handleSearchFocusBefore()
    xonblur=handleBlur()
    class=fullWidth
    >
    
    <input class=dark type=text id=searchText
        style="display: none;
        --font: 13px IosevkaLucida;
        font: 16px Courier;
        "
        onfocus="focusSearchText()"
        oninput="inputSearchText()"
        onblur="blurSearchText()"
        class=fullWidth
    >
    
    <input class=dark id=searchTextAfter class=text type=text
    style="
    --font: 8px IosevkaLucida;
    font: 8px Courier;
    height:1px; overflow: hidden;
    display: block;
    "
    onfocus=handleSearchFocusAfter()
    xonblur=handleBlur()
    class=fullWidth
    >
    
    <input class=dark type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>

<form onsubmit="newLine(event, true)">

<input type=hidden class=dark id=theTextBefore class=text type=text
style="
--font: 8px IosevkaLucida;
font: 8px Courier;
/* display: none; see what it looks like without */
height:1px; overflow: hidden;
display: block;"
onfocus=handleFocusBefore()
onblur=handleBlur()
class=fullWidth
>
<input class=dark id=theText class=text type=text
style="
--font: 13px IosevkaLucida;
--font: 16px Courier;
font: 16px Times;
padding: 0;
color: brown;
height: 24px;
--position:absolute; top: 100px;
display: block;
"
onfocus=handleFocusIn()
onblur=handleBlur()
oninput=saveLine()
onkeydown=handleKeydown(event)
class=fullWidth
>
<input type=hidden class=dark id=theTextAfter class=text type=text
style="
--font: 8px IosevkaLucida;
font: 8px Courier;
/* display: none; see what it looks like without */
height:1px; overflow: hidden;
display: block;
"
onfocus=handleFocusAfter()
onblur=handleBlur()
class=fullWidth
>
<input class=dark type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>
<div style="
    display: flex;
    flex-flow: row nowrap;
">
    <pre id=statusEl class=hidden style="overflow:scroll; font-size: 10px;">
    </pre>
    <div id=logEl class=hidden style="height: 450px; width:240px;
    overflow:scroll;
    -webkit-overflow-scrolling: touch;
    font-size:10px;"
    ></div>
</div>
<!--
Note that the css width needs to be 1/3 of
the with attribute, and same for height.
See canvasHeightFull
-->

<!-- <canvas id=c width=1125 height=1470 -->
<canvas id=c width=1125 height=1800
style="width: 375px; height:10px;
display: block;"
ontouchstart=onStart(event)
></canvas>

<div class="toolbar hidden" id=terminalToolbar1 style="--display: none">
    <div class=square ontouchstart='sendTerminal("\x1b"); event.preventDefault()'>esc</div>
    <div class=square ontouchstart='ctrlDown = true; event.preventDefault()'>ctrl</div>
    <div class=square ontouchstart='sendTerminal("\x03"); event.preventDefault()'>^C</div>
    <!-- don't really need tab because touching the screen gets you tab-->
    <!--<div class=square ontouchstart='sendTerminal("\t"); event.preventDefault() '>tab</div>
    -->
    <div class=square ontouchstart='sendTerminal("\x1b[D"); event.preventDefault()'>left</div>
    <div class=square ontouchstart='sendTerminal("\x1b[B"); event.preventDefault()'>down</div>
    <div class=square ontouchstart='sendTerminal("\x1b[A"); event.preventDefault()'>up</div>
    <div class=square ontouchstart='sendTerminal("\x1b[C"); event.preventDefault()'>right</div>
</div>
<div class="toolbar hidden" id=terminalToolbar2 style="--display: none">
</div>

<div class="toolbar hidden" id=bashToolbar1 style="--display: none">
    <div class=square onclick='runBashCommand("git branch")'>branch</div>
    <div class=square onclick='runBashCommand("git status")'>status</div>
    <div class=square onclick='runBashCommand("git diff")'>diff</div>
    <!-- this one tries to make light backgroud, but doesn't work with mac sed.
    <div class=square onclick='runBashCommand("rm coverage.out coverage.html; if go test -cover -coverprofile coverage.out ./...; then go tool cover -func=coverage.out; go tool cover -o=coverage.html -html=coverage.out; sed -i &apos;s/black;/white;/g&apos; coverage.html; fi")'>gotest</div>
    -->
    <div class=square onclick='runBashCommand("rm coverage.out coverage.html; if go test -cover -coverprofile coverage.out ./...; then go tool cover -func=coverage.out; go tool cover -o=coverage.html -html=coverage.out; fi")'>gotest</div>
    <div class=square onclick='insertText(["git checkout "], 0, -1)'>checkout</div>
    <div class=square onclick='insertText(["git commit -m &apos;&apos;"], 0, 15)'>commit -m</div>
    <!--
    <div class=square onclick='insertText(["git checkout -b "], 0, -1)'>checkout -b</div>
    -->
    <div class=square onclick='runBashCommand("git add -u :/")'>add -u :/</div>
</div>
<div class="toolbar hidden" id=bashToolbar2 style="--display: none">
    <div class=square onclick='runBashCommand("git push origin HEAD")'>push origin H</div>
    <div class=square onclick=openAtCursor()>open</div>
    <div class=square onclick=urlAtCursor()>visit</div>
    <div class=square onclick='runBashCommand("cd ..")'>cd ..</div>
    <!--
    <div class=square onclick='runBashCommand("git stash")'>stash</div>
    <div class=square onclick='runBashCommand("git stash pop")'> stash pop</div>
    <div class=square onclick='runBashCommand("git pull origin master")'>pull origin m</div>
    -->
    <div class=square onclick='runBashCommand("git diff --cached")'>diff --cached</div>
    <div class=square onclick='runBashCommand("git log -10")'>log -10</div>
    <div class=square onclick='runBashCommand("git log -p -3")'>log -p -3</div>
</div>
<!--<div class="toolbar xhidden" id=fileRow ontouchstart=selectFileRow(event)>-->
<div class="toolbar xhidden" id=fileRow onclick=selectFileRow(event)>
</div>
<div class=toolbar>
    <div id=findUpButton class=square onclick=findUp()>find up</div>
    <div id=findDownButton class=square onclick=findDown()>find down</div>
    <div id=clearSearchButton class=square onclick=clearSearch()>clear search</div>
    <div class=square onclick=editSearch()>edit search</div>
    
    <div id=saveButton class=square onclick=saveWrapper()>save</div>
    <div class=square onclick=seeFiles()>files</div>
    <div class=square onclick=closeFile()>close</div>
</div>
<div class=toolbar>
    <div class=square ontouchstart="setCurrentFile(lastFile); event.preventDefault()">alt tab</div>
    <div class=square onclick="duplicateFile(fx, -1)">dupl file</div>
    <div class=square onclick=addCmdTab()>cmd</div>
    <div class=square onclick=addTerminalTab()>xterm</div>
    <div class=square onclick=clearLog()>clear log</div>
    <div class=square onclick=undo()>undo</div>
    <div class=square onclick=comment()>//</div>
</div>
<div class=toolbar>
    
    <!--<div class=square onclick=addSpace()>space</div>
    <div class=square onclick=backspace()>backspace</div>
    <div class=square onclick="theText.focus()">insert</div>
    <div class=square onclick="newLine(null, false)">new line</div>
    -->
</div>
<!-- Stuff after here is after the fold -->
<div class=toolbar>
    <div class=square onclick=debugView()>debug view</div>
    <div class=square onclick=openAtCursor()>open</div>
    <div class=square onclick=urlAtCursor()>visit</div>
    <div class=square onclick=redo()>redo</div>
    <div class=square onclick=doEval()>eval</div>
    <div class=square onclick=runScript()>run script</div>
    <div class=square onclick=reloadFile(fx)>reload</div>
</div>
<div class=toolbar>
    <div class=longButton onclick="selectFont('Menlo')">Menlo</div>
    <div class=longButton onclick="selectFont('RobotoMono')">Roboto Mono</div>
    <div class=longButton onclick="selectFont('IosevkaLucida')">Iosevka L</div>
    <div class=longButton onclick="fontScaleInput.value = 0.9; updateFontScale()">0.9</div>
    <div class=longButton onclick="fontScaleInput.value = 1.0; updateFontScale()">1.0</div>
    <div class=longButton onclick="fontScaleInput.value = 1.1; updateFontScale()">1.1</div>
    <div class=longButton onclick="fontScaleInput.value = 1.2; updateFontScale()">1.2</div>
    <div class=longButton onclick="fontScaleInput.value = 1.3; updateFontScale()">1.3</div>
    <div class=longButton onclick="fontScaleInput.value = 2; updateFontScale()">2</div>
    <div class=longButton onclick="selectFont('Courier')">Courier</div>
    <div class=longButton onclick="selectFont('CourierThin')">Courier Thin</div>
    <div class=longButton onclick="selectFont('SFMono')">SF Mono</div>
    <div class=longButton onclick="selectFont('SFMonoThin')">SF Thin</div>
    <div class=longButton onclick="selectFont('IosevkaThin')">Iosevka Thin</div>
    <div class=longButton onclick="selectFont('Iosevka')">Iosevka</div>
    <div class=longButton onclick="selectFont('IosevkaSlab')">Iosevka S</div>
    <div class=longButton onclick="selectFont('XanhMono')">Xanh</div>
    <div class=longButton onclick="selectFont('Inconsolata')">Inconsolata</div>
    <div class=longButton onclick="selectFont('InconsolataThin')">Inconsolata Thin</div>
    <div class=longButton onclick="selectFont('Courier New')">Courier New</div>
    <div class=longButton onclick="selectFont('NanumGothicCoding')">Nanum GC</div>
    <div class=longButton onclick="selectFont('GillSans')">Gill Sans</div>
    <div class=longButton onclick="selectFont('AmericanTypewriter')">American T</div>
</div>
<div class=toolbar>
    <div class=square onclick="copyBuffer = [location.href]">copy url</div>
    <div class=square onclick="showDiff()">show diff</div>
    <div id=darkModeButton class=square onclick="toggleDarkMode()">light</div>
    <div class=square onclick=scriptLines()>script lines</div>
    <div class=square onclick=scriptLinesInline()>script inline</div>
    <!--<div class=square onclick=addBrowser()>add browser</div>
    -->
    <div class=square onclick=navBack()>nav back</div>
    <div class=square onclick=navForward()>nav forward</div>
</div>
<div class=toolbar>
    <button class=square onclick="osCopyText()">os copy</button>
    <button class=square onclick="osPasteText()">os paste</button>
    <div class=square onclick="reloadAll()">reload All</div>
    <div class=square onclick="comment('--')">--</div>
    <div class=square onclick="copyString(fx.fullPath + ':' + (fx.cursorLineIndex + 1))">copy path</div>
    <div class=square onclick="searchText.value = getWordAtCursor().word; render();">highlight word</div>
    <div id=toggleTabStopButton class=square onclick="toggleTabStop()">tabs</div>
</div>
<div class=toolbar>
    <div class=square onclick=doFormat()>format</div>
    <div class=square onclick="toggleSeeTabs()">see tabs</div>
    <div class=square onclick="diffFiles()">diff files</div>
    <div class=square onclick="moveFileAllTheWayLeft()">move home</div>
    <div class=square onclick="moveFileLeft()">move left</div>
    <div class=square onclick="moveFileRight()">move right</div>
    <div class=square onclick="stopServer()">stop server</div>
</div>
<div class=toolbar>
    <div class=square onclick="window.open(location.href)">dup tab</div>
    <div class=square onclick="saveOrder()">save order</div>
    <div class=square onclick="updateName()">update name</div>
    <div class=square onclick="location.reload()">refresh</div>
    <!--<div class=square onclick="location.href = urlForRefreash">refresh</div>-->
</div>
<label for=allowPollingCheckbox>
    <input onchange="allowPolling = allowPollingCheckbox.checked" type=checkbox name=allowPollingCheckbox id=allowPollingCheckbox checked />
    allow polling
</label>
<label for=useUnicodeCheckbox>
    <input onchange="useUnicode = useUnicodeCheckbox.checked" type=checkbox name=useUnicodeCheckbox id=useUnicodeCheckbox checked />
    use unicode
</label>
<label for=agressiveRenderCheckbox>
    <input onchange="agressiveRender = agressiveRenderCheckbox.checked" type=checkbox name=agressiveRenderCheckbox id=agressiveRenderCheckbox />
    agressive render
</label>
<label for=saveDiffsCheckbox>
    <input onchange="saveDiffs = saveDiffsCheckbox.checked" type=checkbox name=saveDiffsCheckbox id=saveDiffsCheckbox checked />
    save diffs
</label>
<br>
<label for=serverViewCheckbox>
    <input onchange="serverViewFeature = serverViewCheckbox.checked" type=checkbox name=serverViewCheckbox id=serverViewCheckbox />
    Screen Share
</label>
<br>
<label for=lockXCheckbox>
    <input onchange="lockX = lockXCheckbox.checked" type=checkbox name=lockXCheckbox id=lockXCheckbox />
    Lock X
</label>
<br>
<label for=reorderFilesCheckbox>
    <input onchange="reorderFiles = reorderFilesCheckbox.checked" type=checkbox name=reorderFilesCheckbox id=reorderFilesCheckbox />
    Auto-Reorder Files
</label>
<div>
    Term name: <input id=fileNameInput onchange="saveTerminalName(this.value)">
</div>
<div>
    Workspace name: <input id=fileNameInput onchange="saveTerminalName(this.value)">
</div>
<!--
<iframe width="100%" height=400 src="/te/screenshare"></iframe>
-->
<select onchange="selectFont(this.value)">
    <option>Courier</option>
    <option>Menlo</option>
    <option>IosevkaLucida</option>
    <option>Fake</option>
</select>
<textarea class=dark id=pasteEl
style="width:100%; height:100px;"
onfocus="this.setSelectionRange(0, this.value.length)"
oninput=importPaste()
>when you add text here it will be copied</textarea>

<textarea class=dark id=copyEl
contenteditable
onfocus="this.setSelectionRange(0, this.value.length)"
style="width:100%; height:100px;"
    placeholder="when you copy something, it will show up here"
></textarea>
<div>
    <input
        id=fontScaleInput
        oninput="updateFontScale()"
        style="font-size: 16px;"
    > font scale
</div>
<form onsubmit=uploadFile(event)>
    Upload files:<br>
    <input id=filesToUpload type=file multiple>
    <input type=Submit value=Upload>
</form>

<textarea id=s1 placeholder=s1 style="width:100%; height:100px;"></textarea>
<textarea id=s2 placeholder=s2 style="width:100%; height:100px;"></textarea>

<div id=bottomPadding style="height: 100px;"></div>
<div id=colorGetterEl style="width: 100px; height: 100px;"></div>
</div>

</div> <!-- end wrapper -->
<script>
// it's important that this go in it's own script tag
window.onerror = function(message, url, lineNumber, columnNumber, error) {
    alert(lineNumber + ": " + message)
}
</script>
<script>
var t = c.getContext("2d")

var preventRender = true
// var saveDiffs = false
var saveDiffs = true
var totalViewBytesSent = 0 
var totalViewRequests = 0
var saveEveryMS = 3000
var lastWord = ""
var lastCleared = ""
var fontScale = 1.2
fontScaleInput.value = fontScale
var useUnicode = false
var agressiveRender = false

var toolbars = document.querySelectorAll(".fullWidth")
for (var i=0; i<toolbars.length; i++) {        
    var toolbar = toolbars[i]
    toolbar.style.width = innerWidth + "px"
}
c.style.width = innerWidth + "px"
c.width = innerWidth * 3    




var fonts = {
    "Courier": {
        fontHeightPre: 36,
        // fontWidthPre: 18,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "Courier",
    },
    "CourierThin": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "Courier",
    },
    "Courier New": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "Courier New",
    },
    "Menlo": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "Menlo",
    },
    "AmericanTypewriter": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "AmericanTypewriter",
    },
    "GillSans": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "GillSans",
    },
    "SFMono": {
        // I think this actually only works because we default to ui-monospace
        // SFMono seems to not be known
        fontHeightPre: 36,
        fontWidthPre: 17,
        fontSize: 30,
        fontName: "SFMono",
    },
    "SFMonoThin": {
        // I think this actually only works because we default to ui-monospace
        // SFMono seems to not be known
        fontHeightPre: 36,
        fontWidthPre: 15,
        fontSize: 30,
        fontName: "SFMono",
    },
    "RobotoMono": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "RobotoMono",
        url: "https://fonts.gstatic.com/s/robotomono/v13/L0xuDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vq_ROW4AJ68SA.woff2"
    },
    "NanumGothicCoding": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "NanumGothicCoding",
        url: "https://fonts.gstatic.com/s/nanumgothiccoding/v14/8QIVdjzHisX_8vv59_xMxtPFW4IXROwsy6ExUM1WtMRe4NStuSM4eXtk7e0M06IfTaI.119.woff2"
    },
    "IosevkaLucida": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucida",
        // TODO: fix url/path etc
        // url: "http://tel.drewles.com:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
        //url: "http://192.168.0.21:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
        url: proxyPath + "/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
    },
    "IosevkaThin": {
        fontHeightPre: 36,
        // fontWidthPre: 13.5,
        fontWidthPre: 14,
        fontSize: 30,
        fontName: "IosevkaThin",
        url: "http://192.168.0.21:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
    },
    "Iosevka": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "Iosevka",
        url: "http://tel.drewles.com:8000/tepublic/iosevka/iosevka-fixed-regular.ttf"
    },
    "IosevkaSlab": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaSlab",
        url: "http://tel.drewles.com:8000/tepublic/iosevka_slab/iosevka-fixed-slab-regular.ttf"
    },

    "Inconsolata": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "Inconsolata",
        url: "https://fonts.gstatic.com/s/inconsolata/v21/QlddNThLqRwH-OJ1UHjlKENVzlm-WkL3GZQmAwPyya15IDhunA.woff2"
    },
    // https://usefulangle.com/post/74/javascript-dynamic-font-loading
    "InconsolataThin": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "InconsolataThin",
        descriptors: {
            // because inconsolata has this special property
            // feature not working?
            stretch: "70%",
        },
        url: "https://fonts.gstatic.com/s/inconsolata/v21/QlddNThLqRwH-OJ1UHjlKENVzlm-WkL3GZQmAwPyya15IDhunA.woff2"
    },
    "XanhMono": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "XanhMono",
        url: "https://fonts.gstatic.com/s/xanhmono/v4/R70YjykVmvKCep-vWhSonwqRfTHxTw.woff2"
    },
    "Fake": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucida",
        // TODO: fix url/path etc
        url: "http://192.168.0.21:8000/tepublic/notreal.ttf"
    },
}

// this gets changes later down.
// Just need to set some variables I guess
currentFont = fonts["Courier"]
setFontVars()

// currentFont = fonts["SFMono"]
// https://medium.com/@caulfieldOwen/programming-fonts-a-visual-guide-567fc210d2c6
// https://vfoley.xyz/lesser-known-coding-fonts/
// https://www.programmingfonts.org/#iosevka


var lastFile = fx
// not using indexes so we can move files around without worrying about the indexes
// It means we'll have to use files.indexOf in various places
    // var currentFileIndex = 0
    // var lastFileIndex = 0

var reorderFiles = false

var lockX = false
var fontColor = "white"
var lightFontColor = "rgba(255, 255, 255, 0.5)"
var veryLightFontColor = "rgba(255, 255, 255, 0.1)"
var isDark = false
var cursorX=0
var cursorY=0
// 4 chars for line number and 1 for space
var marginLeft = 5
// Note that the width and height need to match
// the width and height of the canvas tag attribute.
canvasWidth=innerWidth * 3
//var canvasWidth=600
// I turned off "Predictive" to get more vertical space
// TODO: make these configurable in UI
var canvasHeightKeyboard=1200
var canvasHeightKeyboardTerminal=canvasHeightKeyboard-(36*3*1)
// var canvasHeightKeyboard=950
var canvasHeightFull=c.height
// 34 button height plus 1px*2 margin
// 2 rows of new buttons for bash
var canvasHeightBash = canvasHeightFull - ((36*3) * 2)
var canvasHeightTerminal = canvasHeightFull - ((36*3) * 1)
var maxLines = 0
var maxCols = 0
var canvasHeight = 0
setCanvasHeight(canvasHeightFull)
setCanvasWidth(canvasWidth)
var pointWidth=325
var pointHeight=500
var touchScaleY = 2 // was 3 for a while, then 2 for a while
var touchScaleX = 2 // was 3 for a while, then 2 for a while

var lastAction = "move" // move or type
var lastSearchDirForSameTerm = "" // up or down or ""
var lastSearchMatchLength = 0 
var hasMovedSinceNewLine = false
var inEdit = false
var copyBuffer = []
var copyBuffer2 = []
var cutBuffer = []
var selectMode = "line"
var selectAction
var cursorType = "move"
// cursorType can be
// * move
// * select

var theStatus = {}

// note: fileMode can be
// * file
// * bash (like a terminal lite)
// * fileList
// * directory
// * terminal
var knownContrastingColors = {}
// if last keyDown is a backspace
var wasDelete = false
var moveHomeEndTimeout
var moveHomeEndTimeoutMillis = 100
var moveHomeEndDirection
var selectTimeout
var selectTimeoutMillis = 750
var moveListenerCount = 0
var endListenerCount = 0
var startListenerCount = 0
var autoSave = false
var lastPageYOffset = 0
var originalCanvasHeightFull = canvasHeightFull
var scrollTimeout
var useRegexSearch = true
// TODO: as you add or delete lines
// go thru these locations and update them
selectFont("IosevkaLucida")
setInterval(function() {
    if (!fx) {
        return
    }
    // has to be at the same place for 2 seconds
    if (fx.lastOffsetY != fx.offsetY) {
        fx.lastOffsetY = fx.offsetY   
        return
    }
    var lastLocation = fx.locationStack[fx.locationIndex]
    if (!lastLocation || (Math.abs(fx.offsetY - lastLocation.offsetY) > maxLines)) {
        if (fx.locationIndex != fx.locationStack.length - 1) {
            fx.locationStack = fx.locationStack.slice(0, fx.locationIndex + 1)
        }
        var loc = {
            offsetY: fx.offsetY,
            cursorLineIndex: fx.cursorLineIndex,
            cursorColIndex: fx.cursorColIndex,
        }
        fx.locationStack.push(loc)
        fx.locationIndex++
        if (fx.locationStack.length > 30) {
            fx.locationStack.shift()       
            fx.locationIndex--
        }
    } else {
        var loc = {
            offsetY: fx.offsetY,
            cursorLineIndex: fx.cursorLineIndex,
            cursorColIndex: fx.cursorColIndex,
        }
        fx.locationStack[fx.locationIndex] = loc
    }
}, 1000)

function navBack() {
    if (fx.locationIndex == 0) {
        return
    }    
    fx.locationIndex--
    var loc = fx.locationStack[fx.locationIndex]
    gotoLoc(loc)
}
function navForward() {
    if (fx.locationIndex >= fx.locationStack.length - 1) {
        return
    }    
    fx.locationIndex++
    var loc = fx.locationStack[fx.locationIndex]
    gotoLoc(loc)
}
function gotoLoc(loc) {
    if (!loc) {
        return
    }
    fx.cursorLineIndex = loc.cursorLineIndex
    fx.cursorColIndex = loc.cursorColIndex
    fx.offsetY = loc.offsetY
    updateCursorXY()
    render()
}

function osCopyText() {
    navigator.clipboard.writeText(copyBuffer.join("\n")).then(function() {
    }, function() {
        alert("not copied")
    })
}
function osPasteText() {
    navigator.clipboard.readText().then(function(text) {
        copyBuffer = text.split("\n")
    }, function(e) {
        alert("not copied: " + e)
    })
}

function addBrowser() {
    var f = makeFile("http://google.com", 0, contents)
    addFileToList(f)
}
function showDiff() {
    // var start = Date.now()
    // var contents = simpleDiffOld(fx.undo.lastSavedLines, fx.lines, false).join("\n")
    // log("diff1: " + (Date.now()-start))
    // var f = makeFile("__diffOld", 0, contents)
    // f.fileMode = "file"
    // f.cursorLineIndex = 0
    // addFileToList(f)
    // 
    // var start = Date.now()
    // var contents = simpleDiffOld2(fx.undo.lastSavedLines, fx.lines, false).join("\n")
    // log("diff2: " + (Date.now()-start))
    // var f2 = makeFile("__diffOld2", 0, contents)
    // f2.fileMode = "file"
    // f2.cursorLineIndex = 0
    // addFileToList(f2)
    
    var start = Date.now()
    var contents = simpleDiffOld3(fx.undo.lastSavedLines, fx.lines, false).join("\n")
    log("diff3: " + (Date.now()-start))
    var f3 = makeFile("__diffOld3", 0, contents)
    f3.fileMode = "file"
    f3.cursorLineIndex = 0
    addFileToList(f3)
    
    var oldContents = fx.undo.lastSavedLines.join("\n")
    var newContents = fx.lines.join("\n")
    var start = Date.now()
    var contents = Diff.createPatch("foo", oldContents, newContents, "", "", {context:0})
    // var contents = Diff.createPatch("foo", "aaaaa", "bbbbbb", "", "")
    log("diffM: " + (Date.now()-start))
    var f4 = makeFile("__diffMyers", 0, contents)
    f4.fileMode = "file"
    f4.cursorLineIndex = 0
    addFileToList(f4)
    
    
    setCurrentFile(f4)
    updateCursorXY()
    ensureCursorInScreen()
}

function simpleDiffOld(aLines, bLines, showSame) {
    var aLastMatched = -1
    var bLastMatched = -1
    var ai = -1
    var bi = -1
    
    // TODO: you can handle a bit better when it gets to the end for one?
    // NOTE: this is my experimenting with diff. likely not fastest or most
    // efficient. For example I don't get largest common substring.
    // max 20000 line diff
    // this has large issues, see scratch5
    // one thing we can do to improve is another pass where we optimize this output. 
    // or just implement the Myers diff algorithm and compare speed
    var ret = []
    outerLoop:
    for (var i=0; i<20000; i++) {
        ai += 1
        bi += 1
        if (ai >= aLines.length && bi >= bLines.length) {
            break
        }
        var aLine = aLines[ai]    
        for (var b=bLastMatched+1; b<=bi; b++) {
            var bLine = bLines[b]    
            // log("a comparing " + aLine + " " + bLine)
            if (aLine == bLine) {
                if (!showSame && (aLastMatched+1<ai || bLastMatched+1<b)) {
                    ret.push("@@ -" + (aLastMatched+2) + " @@")
                }
                for (var a=aLastMatched+1; a<ai; a++) {
                    ret.push("-" + aLines[a])
                }
                for (var b2=bLastMatched+1; b2<b; b2++) {
                    ret.push("+" + bLines[b2])
                }
                aLastMatched = ai    
                bLastMatched = b  
                bi = b
                if (showSame) {
                    ret.push(" " + aLines[ai])
                }
                continue outerLoop
            } 
        }
        
        var bLine = bLines[bi]    
        for (var a=aLastMatched+1; a<=ai-1; a++) {
            var aLine = aLines[a]    
            // log("b comparing " + bLine + " " + aLine)
            if (aLine == bLine) {
                if (!showSame && (aLastMatched+1<a || bLastMatched+1<bi)) {
                    ret.push("@@ -" + (aLastMatched+2) + " @@")
                }
                for (var a2=aLastMatched+1; a2<a; a2++) {
                    ret.push("-" + aLines[a2])
                }
                for (var b=bLastMatched+1; b<bi; b++) {
                    ret.push("+" + bLines[b])
                }
                if (showSame) {
                    ret.push(" " + bLines[bi])
                }
                aLastMatched = a    
                bLastMatched = bi  
                ai = a
                continue outerLoop
            } 
        }
    }
    if (i == 200000) {
        alert("likely a bug with diff code")
    }
    
    // any left over
    if (aLastMatched+1<aLines.length || bLastMatched+1<bLines.length) {
        ret.push("@@ -" + (aLastMatched+2) + " @@")
    }
    if (aLastMatched + 1 < aLines.length) {
        for (var aR=aLastMatched+1; aR<aLines.length; aR++) {
            ret.push("-" + aLines[aR])
        }
    }
    if (bLastMatched + 1 < bLines.length) {
        for (var bR=bLastMatched+1; bR<bLines.length; bR++) {
            ret.push("+" + bLines[bR])
        }
    }
    return ret
}

function simpleDiffOld2(aLines, bLines, showSame) {
    var aLastMatched = -1
    var bLastMatched = -1
    var ai = -1
    var bi = -1
    
    // TODO: you can handle a bit better when it gets to the end for one?
    // NOTE: this is my experimenting with diff. likely not fastest or most
    // efficient. For example I don't get largest common substring.
    // max 20000 line diff
    // this has large issues, see scratch5
    // one thing we can do to improve is another pass where we optimize this output. 
    // or just implement the Myers diff algorithm and compare speed
    var ret = []
    lastMatched = true
    outerLoop:
    for (var i=0; i<20000; i++) {
        ai += 1
        bi += 1
        if (ai >= aLines.length && bi >= bLines.length) {
            break
        }
        var aLine = aLines[ai]    
        for (var b=bLastMatched+1; b<=bi; b++) {
            var bLine = bLines[b]    
            // log("a comparing " + aLine + " " + bLine)
            if (aLine == bLine && (lastMatched || (!aLine || (aLine.trim() != "" && aLine.trim() != "}" && !aLine.trim().startsWith("</"))))) {
                lastMatched = true
                if (!showSame && (aLastMatched+1<ai || bLastMatched+1<b)) {
                    ret.push("@@ -" + (aLastMatched+2) + " @@")
                }
                for (var a=aLastMatched+1; a<ai; a++) {
                    ret.push("-" + aLines[a])
                }
                for (var b2=bLastMatched+1; b2<b; b2++) {
                    ret.push("+" + bLines[b2])
                }
                aLastMatched = ai    
                bLastMatched = b  
                bi = b
                if (showSame) {
                    ret.push(" " + aLines[ai])
                }
                continue outerLoop
            } 
        }
        
        var bLine = bLines[bi]    
        for (var a=aLastMatched+1; a<=ai-1; a++) {
            var aLine = aLines[a]    
            // log("b comparing " + bLine + " " + aLine)
            // if (aLine == bLine) {
            if (aLine == bLine && (lastMatched || (!aLine || (aLine.trim() != "" && aLine.trim() != "}" && !aLine.trim().startsWith("</"))))) {
                lastMatched = true
                if (!showSame && (aLastMatched+1<a || bLastMatched+1<bi)) {
                    ret.push("@@ -" + (aLastMatched+2) + " @@")
                }
                for (var a2=aLastMatched+1; a2<a; a2++) {
                    ret.push("-" + aLines[a2])
                }
                for (var b=bLastMatched+1; b<bi; b++) {
                    ret.push("+" + bLines[b])
                }
                if (showSame) {
                    ret.push(" " + bLines[bi])
                }
                aLastMatched = a    
                bLastMatched = bi  
                ai = a
                continue outerLoop
            } 
        }
        
        lastMatched = false
    }
    if (i == 200000) {
        alert("likely a bug with diff code")
    }
    
    // any left over
    if (aLastMatched+1<aLines.length || bLastMatched+1<bLines.length) {
        ret.push("@@ -" + (aLastMatched+2) + " @@")
    }
    if (aLastMatched + 1 < aLines.length) {
        for (var aR=aLastMatched+1; aR<aLines.length; aR++) {
            ret.push("-" + aLines[aR])
        }
    }
    if (bLastMatched + 1 < bLines.length) {
        for (var bR=bLastMatched+1; bR<bLines.length; bR++) {
            ret.push("+" + bLines[bR])
        }
    }
    return ret
}

// heuristical
function simpleDiffOld3(aLines, bLines, showSame) {
    var aLastMatched = -1
    var bLastMatched = -1
    var ai = -1
    var bi = -1
    
    // TODO: you can handle a bit better when it gets to the end for one?
    // NOTE: this is my experimenting with diff. likely not fastest or most
    // efficient. For example I don't get largest common substring.
    // max 20000 line diff
    // this has large issues, see scratch5
    // one thing we can do to improve is another pass where we optimize this output. 
    // or just implement the Myers diff algorithm and compare speed
    var ret = []
    lastMatched = true
    outerLoop:
    for (var i=0; i<20000; i++) {
        ai += 1
        bi += 1
        if (ai >= aLines.length && bi >= bLines.length) {
            break
        }
        var aLine = aLines[ai]    
        for (var b=bLastMatched+1; b<=bi; b++) {
            var bLine = bLines[b]    
            // log("a comparing " + aLine + " " + bLine)
            if (aLine != bLine) {
                continue
            }
            if (!lastMatched) {
               // use a hash for this?
               var trimmed = (aLine || "").trim()   
               if (trimmed == "") {
                   continue
               }
               if (trimmed == "}") {
                   continue
               }
               if (trimmed.startsWith == "/>") {
                   continue
               }
               if (trimmed == "break") {
                   continue
               }
               if (trimmed == "continue") {
                   continue
               }
               if (trimmed == "return") {
                   continue
               }
            }
            lastMatched = true
            if (!showSame && (aLastMatched+1<ai || bLastMatched+1<b)) {
                ret.push("@@ -" + (aLastMatched+2) + " @@")
            }
            for (var a=aLastMatched+1; a<ai; a++) {
                ret.push("-" + aLines[a])
            }
            for (var b2=bLastMatched+1; b2<b; b2++) {
                ret.push("+" + bLines[b2])
            }
            aLastMatched = ai    
            bLastMatched = b  
            bi = b
            if (showSame) {
                ret.push(" " + aLines[ai])
            }
            continue outerLoop
        }
        
        var bLine = bLines[bi]    
        for (var a=aLastMatched+1; a<=ai-1; a++) {
            var aLine = aLines[a]    
            // log("b comparing " + bLine + " " + aLine)
            // if (aLine == bLine) {
            if (aLine != bLine) {
                continue
            }
            if (!lastMatched) {
               // use a hash for this?
               var trimmed = (aLine || "").trim()   
               if (trimmed == "") {
                   continue
               }
               if (trimmed == "}") {
                   continue
               }
               if (trimmed.startsWith == "/>") {
                   continue
               }
               if (trimmed == "break") {
                   continue
               }
               if (trimmed == "continue") {
                   continue
               }
               if (trimmed == "return") {
                   continue
               }
            }
            lastMatched = true
            if (!showSame && (aLastMatched+1<a || bLastMatched+1<bi)) {
                ret.push("@@ -" + (aLastMatched+2) + " @@")
            }
            for (var a2=aLastMatched+1; a2<a; a2++) {
                ret.push("-" + aLines[a2])
            }
            for (var b=bLastMatched+1; b<bi; b++) {
                ret.push("+" + bLines[b])
            }
            if (showSame) {
                ret.push(" " + bLines[bi])
            }
            aLastMatched = a    
            bLastMatched = bi  
            ai = a
            continue outerLoop
        }
        
        lastMatched = false
    }
    if (i == 200000) {
        alert("likely a bug with diff code")
    }
    
    // any left over
    if (!showSame && (aLastMatched+1<aLines.length || bLastMatched+1<bLines.length)) {
        ret.push("@@ -" + (aLastMatched+2) + " @@")
    }
    if (aLastMatched + 1 < aLines.length) {
        for (var aR=aLastMatched+1; aR<aLines.length; aR++) {
            ret.push("-" + aLines[aR])
        }
    }
    if (bLastMatched + 1 < bLines.length) {
        for (var bR=bLastMatched+1; bR<bLines.length; bR++) {
            ret.push("+" + bLines[bR])
        }
    }
    return ret
}

function getAtCursor() {
    if (fx.cursorLineIndex >= fx.lines.length) {
        return
    }
    var line = fx.lines[fx.cursorLineIndex]
    var strIndex = u(fx.cursorColIndex)
    for (var i=strIndex; i>=0; i--) {
        // if ((line.charAt(i).trim() == "")) {
        // log(line.charAt(i) + " " + line.charCodeAt(i))
        if (line.charCodeAt(i) <= 32) {
            break
        }   
    }
    i += 1
    for (var j=strIndex+1; j<line.length; j++) {
        if (line.charCodeAt(j) <= 32) {
            break
        }   
    }
    return line.slice(i, j)
}

function openAtCursor() {
    var path = getAtCursor()
    if (fx.fileMode == "bash") {
        var fileName = trimPrefix(fx.bashCWD, rootLocation) + "/" + path
    } else if (fx.fileMode == "terminal") {
        // TODO: how do we know what the cwd is? 
        // isn't there a way to get the cwd of a running process?
    } else if (path.startsWith("/")) {
        var fileName = path
    } else {
        var parts = fx.fullPath.split("/")
        var basePath = parts.slice(0, -1).join("/")
        var fileName = basePath + "/" + path
    }
    addFile(fileName)
}

function urlAtCursor() {
    var url = getAtCursor()
    open(url)
}

function addSpace() {
    if (fx.cursorLineIndex >= fx.lines.length) {
        return
    }
    var line = fx.lines[fx.cursorLineIndex]
    updateLine(-1, line.slice(0, u(fx.cursorColIndex)) + " " + line.slice(u(fx.cursorColIndex)))
    fx.cursorColIndex += 1 
    updateCursorXY()
    docChanged()
    render()   
}

function backspace() {
    if (fx.cursorLineIndex >= fx.lines.length) {
        return
    }
    var line = fx.lines[fx.cursorLineIndex]
    if (fx.cursorColIndex == 0) {
    
        return
    }
    // fx.lines[fx.cursorLineIndex] = line.slice(0, u(fx.cursorColIndex) - 1) + line.slice(u(fx.cursorColIndex))
    updateLine(fx.cursorLineIndex, line.slice(0, u(fx.cursorColIndex) - 1) + line.slice(u(fx.cursorColIndex)))
    fx.cursorColIndex = expandTabIndex(line, u(fx.cursorColIndex - 1)) 
    docChanged()
    updateCursorXY()
    render()   
}
function selectFont(fontName) {
    currentFont = fonts[fontName] || fonts["Courier"]
    if (currentFont.url) {
        var font
        if (currentFont.descriptors) {
            font = new FontFace(fontName, "url(" + currentFont.url + ")")    
        } else {
            font = new FontFace(fontName, "url(" + currentFont.url + ")", currentFont.descriptors)    
        }
        font.load().then(function(loaded){
            document.fonts.add(loaded)
        }).catch(function(e){
            alert(e)
        })
    }
    updateFontScale()
}

function updateFontScale() {
    fontScale = fontScaleInput.value - 0
    if (!fontScale) {
        fontScale = 1
    }
    setFontVars()
    setCanvasHeightAccordingly()
    setCanvasWidth(canvasWidth)
    render()
}
function setFontVars() {
    fontHeight = currentFont.fontHeightPre * fontScale
    fontWidth = currentFont.fontWidthPre * fontScale
    fontCSS = (currentFont.fontSize * fontScale) + "px '"+currentFont.fontName+"', ui-monospace"
    fontCSSEmoji = (currentFont.fontSize * fontScale * .6) + "px '"+currentFont.fontName+"', ui-monospace"
    extraYEmoji = (currentFont.fontSize * fontScale * .6) / 2
}


function importPaste() {
    copyBuffer = pasteEl.value.split("\n")
    selectMode = "line"
}

function toggleDarkMode() {
    isDark = !isDark
    renderDarkMode()
}
function renderDarkMode() {
    if (!isDark) {
        darkModeButton.innerText = "dark"
        document.body.classList.remove("dark")
        document.body.classList.add("light")
        updateClassForSelector("input", "dark","light")
        updateClassForSelector("textarea", "dark","light")
        fontColor = "black"
        lightFontColor = "rgba(0, 0, 0, 0.5)"
        veryLightFontColor = "rgba(0, 0, 0, 0.1)"
        render()
        renderURL()
        return
    }
    darkModeButton.innerText = "light"
    document.body.classList.remove("light")
    document.body.classList.add("dark")
    updateClassForSelector("input", "light", "dark")
    updateClassForSelector("textarea", "light", "dark")
    // fontColor = "white"
    // fontColor = "rgba(100, 255, 100)"
    fontColor = "rgba(255, 255, 200)"
    lightFontColor = "rgba(255, 255, 255, 0.5)"
    veryLightFontColor = "rgba(255, 255, 255, 0.1)"
    render()
    renderURL()
}
function updateClassForSelector(selector, remove, add) {
    var inputs = document.querySelectorAll(selector)
    for (var i=0; i<inputs.length; i++) {
        var input = inputs[i]
        input.classList.remove(remove)
        input.classList.add(add)
    }
}

function editSearch() {
    searchText.style.display = "block"
    searchText.focus()
}
function focusSearchText() {
    log("focus search text")
    window.scrollTo(0, 0)
    searchText.setSelectionRange(0, searchText.value.length)
    searchText.style.display = "block"
    theText.style.display = "none"
    setCanvasHeightAccordingly()
}
function inputSearchText() {
    if (fx.fileMode == "directory") {
        findDown(true, true)
    }
    render()
}
function blurSearchText() {
    log("blurSearchText")
    theText.style.display = "block"
    searchText.style.display = "none"
    setCanvasHeightAccordingly()
}
function closeFile() {
    if (fx.fileMode == "fileList") {
        var fileIndex = files.indexOf(treeFilesShadow[fx.cursorLineIndex])
        if (fileIndex != -1) {
            var fileToClose = files[fileIndex]
            // try to get index again because it could have changed
            var indexToClose = files.indexOf(fileToClose)
            if (indexToClose != -1) {
                files.splice(indexToClose, 1)
            }
            fx.lines = getLinesForFileList()
            // TODO?: to the useUnicode stuff here and related places
            // or maybe don't show unicode in file list? 
            render()
            renderFileDropdown()
            renderURL()
            closeFileServer(fileToClose).then(() => {
            }).catch(e => alert(e))
        }
        fx.lines = getLinesForFileList()
    } else {
        var myFx = fx // in case it changes
        var indexToClose = files.indexOf(myFx)
        if (indexToClose != -1) {
            files.splice(indexToClose, 1)
            // this changes fx
            selectFileIndex(indexToClose-1 < 0 ? 0: indexToClose-1)
        }
        render()
        renderFileDropdown()
        renderURL()
        closeFileServer(myFx).then(() => {
        }).catch(e => alert(e))
    }
}


var bashHelpers = [
    // some common commands to use quickly
    // TODO: make these common commands configurable
    "gofmt -s -w .",
    "golangci-lint run --print-issued-lines=false",
    "git commit -m '' --author='Drew LeSueur <drewalex@gmail.com>'",
    "git checkout master",
    "git pull origin master",
    "git checkout -b ",
    "git log --all --decorate --graph -10",
    "grep -Rin '' --include=*.pm .",
    "grep -Rin '' --include=*.go .",
    "grep -Rin '' --include=*.php .",
    "find . -name '**'",
    "diff -y --width=240",
    "go test ./...",
    // a way to do `git add -p` non-interactively
    "git --no-pager diff > gitdiff",
    "open gitdiff",
    "git apply --cached gitdiff",
    "go doc -all ''",
    "clear",
    "",
    "",
]

function useExisingWD(file) {
    if (fx.fileMode == "bash") {
        file.bashCWD = fx.bashCWD
        file.originatingFullPath = fx.originatingFullPath
    } else if (fx.fileMode == "file") {
        var parts = trimPrefix(fx.fullPath, proxyPath).split("/")
        parts = parts.slice(0, parts.length - 1)
        file.bashCWD = rootLocation + parts.join("/")
        file.originatingFullPath = fx.fullPath.split("/").slice(0, -1).join("/") + "/cmd"
    } else if (fx.fileMode == "directory") {
        file.bashCWD = rootLocation + trimPrefix(fx.fullPath, proxyPath)
        file.originatingFullPath = fx.fullPath + "/cmd"
    }
}

function addCmdTab(id=0, cwd="", name="") {
    // I think this /cmd isn't hit on the server 
    // I think we need a special endpoint for serving files and not just /
    var file = makeFile(proxyPath + "/cmd", 0, bashHelpers.join("\n"))
    file.fileMode = "bash"
    if (id) {
        file.ID = id
    }
    file.name = name
    if (!cwd) {
        useExisingWD(file)
    } else {
        file.bashCWD = cwd
        file.originatingFullPath = cwd
    }
    addFileToList(file, false)
    setCurrentFile(file)
    fx.cursorLineIndex = fx.lines.length - 1
    updateCursorXY()
    runBashCommand("")
    //theText.focus()
}

// TODO: addTerminalTab and addExistingTerminalTab can probably be consolidated,
// like addCmdTab
function addTerminalTab() {
    // TODO: follow up on the path variable, seems mostly useless for now.
    var file = makeFile(proxyPath + "/terminal", 0, "")
    file.fileMode = "terminal"
    useExisingWD(file)
    addFileToList(file, false)
    setCurrentFile(file)
    fx.cursorLineIndex = fx.lines.length - 1
    updateCursorXY()
    openTerminal()
    //theText.focus()
}
function addExistingTerminalTab(id, name) {
    var file = makeFile(proxyPath + "/terminal", 0, "")
    file.fileMode = "terminal"
    file.ID = id
    if (name) {
        file.name = name
    }
    addFileToList(file, false)
    setCurrentFile(file)
    fx.cursorLineIndex = fx.lines.length - 1
    updateCursorXY()
    if (!isPollingTerminal) {
        pollTerminals()    
    }
    //theText.focus()
}
function normalizeFullPath(fullPath) {
    if (fullPath.charAt(0) != "/") {
        fullPath = "/" + fullPath
    }
    // TODO: also apply the .. and .
    var newParts = []
    var parts = fullPath.split("/")
    for (var i=0; i<parts.length; i++) {
        var part = parts[i]        
        if (part == ".") {
            continue
        }
        if (part == "..") {
            newParts.pop()
        }
        newParts.push(part)
    }
    newFullPath = newParts.join("/")
    return newFullPath
}

var urlForRefreash = location.href
function renderURL() {
    return // with workspaces we don't render url
    if (preventRender) {
        return
    }
    // For now we don't get files with bash mode.
    var filtered = files.filter(f => f.fileMode != "bash")
    var theNewPath = "/" + filtered.map(function(f) {
        if (f.fileMode == "terminal") {
            // TODO: ensure that the terminal is not the first one somewhere?
            // or at least handle it
            // TODO: encodeURIComponent? (or does it already do that?)
            return "__TERMINAL__:" + f.ID
        }
        return f.fullPath.slice(1) + ":" + (f.cursorLineIndex + 1)
        
    }).join(",")
    theNewPath += "?dark=" + (isDark ? "1" : "0") 
    history.replaceState({}, "", theNewPath)
    // urlForRefreash = theNewPath
}

function doEval() {
    var code = prompt("code")
    var resp =  eval(code)
    alert(resp)
}
function log(v) {
    var d = document.createElement("pre")
    d.style.display = "block"
    d.style.border = "1px solid blue"
    if (typeof v == "object") {
        d.innerText = JSON.stringify(v, "", "    ")
    } else {
        d.innerText = v
    }
    logEl.appendChild(d)
    logEl.scrollTop = logEl.scrollHeight
}

function docChanged(preventUndo) {
    fx.version += 1
    if (!inACPlop) {
        var maybeLastWord = getWordAtCursor().word
        if (maybeLastWord != "") {
            lastWord = maybeLastWord
        }
    }
    if (!preventUndo) {
        // var start = Date.now()
        saveUndo(preventUndo)
        // log("u1: " + (Date.now() - start))
    }
    renderSaves()
    lastRenderFullScreenForSet = false
}
function saveUndo(preventUndo) {
    // 3 ways of doing undo
    //   1. any time you want an undo point just snapshot the whole file
    //      to a stack of snapshots and just restore the whole file on undo
    //      pro: simple to implement
    //      con: more memory usage.
    //   2. any time you want an undo point just diff the lines from last undo point (lastDocState)
    //.      and add that diff to a stack of diffs
    //       then snapahot to a single variable "lastDocState"
    //.      and just reverse apply the diff on undo.
    //       pro: Less memory, theoretically allows more undos
    //.      con: more cpu usage calcing the diff
    //.      con: more complicated to implement
    //.  3. make setters for any modification of the document (instead of just manual array modification) 
    //.     in those setters we'd manually create diffs without diffing the whole document.
    //.     pro: less cpu and less memory all around
    //.     pro: would cause us to wrangle the document changes into simple functions
    //.          and we could reuse some logic for screen share
    //.     con: also complicated to implementwould have to 
    //.     con: would have to go through all changes to fx.lines and update code (that actually could be a good thing)
    //.     con: in first 2 it might be easier to not make every single change cause an undo point 
    //.          for example we currently don't want every letter typed to be an undo point. we currently undo at the line level
    //.          (see calls to docChanged)
    //. 
    var currentContents = fx.lines.join("\n")
    if (currentContents == fx.undo.stack[fx.undo.index]) {
        return
    }
    if (fx.undo.index != fx.undo.stack.length - 1) {
        fx.undo.stack.splice(fx.undo.index + 1, fx.undo.stack.length - fx.undo.index +1)
        fx.undo.yStack.splice(fx.undo.index + 1, fx.undo.yStack.length - fx.undo.index +1)
        fx.undo.xStack.splice(fx.undo.index + 1, fx.undo.xStack.length - fx.undo.index +1)
    }
    fx.undo.index += 1
    fx.undo.stack.push(currentContents)
    fx.undo.yStack.push(fx.cursorLineIndex)
    fx.undo.xStack.push(fx.cursorColIndex)
    if (fx.undo.stack.length > maxUndos) {
        fx.undo.stack.shift()
        fx.undo.yStack.shift()
        fx.undo.xStack.shift()
        fx.undo.index -= 1
    }
}

// setter for lines
// this should help keep track of changes etc
// for use in undo maybe, and streaming
// in the future you can have more granular changes about what in the line
// is being updated, like a splice?
// maybe tou can do a line diff too.
function updateLineFile(file, index, value) {
    if (index == -1) {
        index = file.cursorLineIndex
    }
    
    var theLine = value
    if (useUnicode) {
        theLine = new String(value)
        theLine.cachedGraphemes = splitter.splitGraphemes(value)
        // log("splitGraphemes2! " + Date.now())
        file.lines[index] = theLine
    } else {
        file.lines[index] = value
    }
    return theLine
}
function updateLine(index, value) {
    return updateLineFile(fx, index, value)
}
var emptyArray = []
function getCachedGraphemes(theLine, index, file, nocache) {
    if (theLine.length == 0) {
         return emptyArray  
    }
    if (theLine.cachedGraphemes) {
        return theLine.cachedGraphemes
    }
    var graphemes = splitter.splitGraphemes(theLine)
    // log("splitGraphemes! " + Date.now())
    if (nocache == "nocache") {
        return graphemes
    }
    if (typeof file == "undefined") {
        file = fx
    }
    if (typeof index == "undefined" || index == -1) {
        index = file.cursorLineIndex
    }
    theLine = new String(theLine) // removes tabCache
    theLine.cachedGraphemes = graphemes 
    // try {
        if (index < file.lines.length) {
            file.lines[index] = theLine
        }
    // } catch {
    //     var err = new Error()
    //     log(err.stack)
    // }
    return graphemes
}

function setLines(lines) {
    // TODO: calc a whole diff here?
    // because there can be multiple files
    // referencing the same lines,
    // we can't just set the lines on one
    // for when you have to update the whole object
    fx.lines = lines
    for (var i=0; i<files.length; i++) {
        if (fx != files[i] && files[i].fullPath == fx.fullPath) {
            files[i].lines = fx.lines
        }
    }
}
function repositionUndo(isUndo) {
    setLines(fx.undo.stack[fx.undo.index].split("\n"))
    if (isUndo) {
        fx.cursorColIndex = fx.undo.xStack[fx.undo.index + 1]
        fx.cursorLineIndex = fx.undo.yStack[fx.undo.index + 1]
    } else {
        fx.cursorColIndex = fx.undo.xStack[fx.undo.index]
        fx.cursorLineIndex = fx.undo.yStack[fx.undo.index]
    }
    if (fx.cursorLineIndex < fx.offsetY || fx.cursorLineIndex > fx.offsetY+maxLines) {
        fx.offsetY = max(0, fx.cursorLineIndex - 5)
    }
    if (fx.cursorColIndex < fx.offsetX || fx.cursorColIndex > fx.offsetX+maxCols) {
        fx.offsetX = max(0, fx.cursorColIndex - 5)
    }
    updateCursorXY()
    render()
}

function undo() {
    fx.undo.index = bind(fx.undo.index-1, 0, fx.undo.index)
    repositionUndo(true)
}

function redo() {
    fx.undo.index = bind(fx.undo.index+1, fx.undo.index, fx.undo.stack.length-1)
    repositionUndo(false)
}
function clearLog() {
    if (fx.fileMode == "bash") {
        runBashCommand("clear")
    } else if (fx.fileMode == "terminal") {
        // TODO: should I be using setLines?
        fx.lines = [""]
        fx.cursorLineIndex = 0
        fx.cursorColIndex = 0
        updateCursorXY()
        fx.offsetY = 0
        ensureCursorInScreen()
    }
    logEl.innerHTML = ""
    render()
}
function isNumeric(s) {
    var c = s.charCodeAt(0)
    return (c >= 48 && c <= 57)
}

function isWordyChar(c) {
    return isWordy(c.charCodeAt(0))    
}
// check for A-Za-z0-9_
function isWordy(a) {
    return (
        (a >= 65 && a <= 90) ||  // A-Z
        (a >= 97 && a <= 122) || // a-z
        (a >= 48 && a <= 57) ||  // 0-9
        (a == 95)            ||    // _
        
        // note: I kind of don't like how we depend on fx in this func, hmm
        ((fx.fileMode == "bash" || fx.fileMode == "terminal") && a == 46) || // .
        ((fx.fileMode == "bash" || fx.fileMode == "terminal") && a == 45) // -
    )
}
function isRegularWord(theLine) {
    // a little regex could replace this :)
    for (var cI=0; cI<theLine.length; cI++) {
       if (!isWordy(theLine.charCodeAt(cI))) {
         return false   
       }
    }
    return true
}
function getWordAtCursor() {
    return getWordAt(fx.lines[fx.cursorLineIndex], u(fx.cursorColIndex))
}
function getWordAt(line, x) {
    if (!line) return {start: x, end: x, word: ""}
    for (var startIndex=x-1; startIndex>=0; startIndex--) {
        if (!isWordy(line.charCodeAt(startIndex))) {
            startIndex += 1
            break
        }
    }
    if (startIndex < 0) startIndex = 0
    for (var endIndex=x; endIndex < line.length; endIndex++) {
        if (!isWordy(line.charCodeAt(endIndex))) {
            break
        }
    }
    //if (startIndex < endIndex) {
        return {start: startIndex, end: endIndex, word: line.substring(startIndex, endIndex)}
    //}
    return {start: x, end: x, word: ""}
}
function getWordBeforeCursor() {
    return getWordBefore(fx.lines[fx.cursorLineIndex], u(fx.cursorColIndex))
}
function getWordBefore(line, x) {
    if (!line) return {start: x, end: x, word: ""}
    for (var startIndex=x-1; startIndex>=0; startIndex--) {
        if (!isWordy(line.charCodeAt(startIndex))) {
            startIndex += 1
            break
        }
    }
    if (startIndex < 0) startIndex = 0
    var endIndex = x
    //if (startIndex < endIndex) {
        return {start: startIndex, end: endIndex, word: line.substring(startIndex, endIndex)}
    //}
    return {start: x, end: x, word: ""}
}
function findDownForm(e) {
    // TODO: why doesnt preventDefault autocomplete sometimes?
    e.preventDefault()
    if (fx.fileMode == "directory" && document.activeElement == searchText) {
        clickItemInDirectory()
        searchText.select()
        return   
    }
    findDown()
    return false
}

function findDown(searchDir, wrap, startTop) {
    lastAction = "move"
    shouldAutocompleteLine = false
    hasMovedSinceNewLine = true
    acWord = null
    if (searchText.value.slice(0, 1) == ":" && (searchText.value.slice(1) - 0) == searchText.value.slice(1)) {
        fx.cursorLineIndex = searchText.value.slice(1) - 1
         ensureCursorInScreen()
    }
    true
    
    var startY = fx.cursorLineIndex
    if (startTop) {
       startY = 0
    } 
    if (document.activeElement != searchText && searchText.value == "") {
        if (fx.selectedRegions.length) {
            searchText.value = getSelectedLines(fx, false).lines[0]
        } else {
            searchText.value = getWordAtCursor().word
        }
        if (searchText.value == "") {
            navForward()
            return
            // searchText.value = "// mar"+"ker"
            searchText.value = " mar"+"ker"
        }
    }
    for (var i=startY; i<fx.lines.length; i++) {
        var lineToSearch = fx.lines[i]
        var originalLineToSearch = lineToSearch
        if (!startTop && i == fx.cursorLineIndex) {
            var startX = u(fx.cursorColIndex)
            if (!searchDir && lastSearchDirForSameTerm == "down") {
                startX = u(fx.cursorColIndex + lastSearchMatchLength)   
            }
            lastSearchDirForSameTerm = "down" 
            lineToSearch = lineToSearch.substr(startX)
        }
        var pos = -1
        if (false && document.activeElement == searchText) {
            pos = lineToSearch.toLowerCase().indexOf(searchText.value.toLowerCase())
            lastSearchMatchLength = searchText.value.length 
        } else {
            if (useRegexSearch) {
                var theMatch = lineToSearch.match(cachedSearchRegexp(searchText.value))
                if (theMatch == null) {
                    pos = -1
                } else {
                    pos = theMatch.index
                    lastSearchMatchLength = theMatch[0].length 
                }
            } else {
                pos = lineToSearch.indexOf(searchText.value)
                lastSearchMatchLength = searchText.value.length
            }
        }
        if (pos != -1) {
            if (!startTop && i == fx.cursorLineIndex) {
                // compensate for that we sliced the line originally
                pos += startX
            }
            fx.cursorLineIndex = i
            fx.cursorColIndex = expandTabIndex(originalLineToSearch, pos, i, fx)
            
            updateCursorXY()
            ensureCursorInScreen()
            
            render()
            return true
        }
    }
    if (wrap) {
        findDown(searchDir, false, true)   
        return
    }
    render()
    return false
}

function ensureCursorInScreen(file) {
    if (!file) {
        file = fx
    }
    if (file.cursorLineIndex < file.offsetY) {
        file.offsetY = file.cursorLineIndex
    } else if (file.cursorLineIndex >= file.offsetY+maxLines) {
        file.offsetY = file.cursorLineIndex-maxLines +1
    }

    // TODO: there is something more elegant
    // that you can do here
    if (file.cursorColIndex < file.offsetX) {
        //file.offsetX = file.cursorColIndex
        file.offsetX = file.cursorColIndex - Math.floor(maxCols/2)
    } else if (file.cursorColIndex > file.offsetX+maxCols) {
        file.offsetX = file.cursorColIndex - Math.floor(maxCols/2)
    }
    if (file.offsetX < -5) {
        file.offsetX = -5
    }
    updateCursorXY(file)
    render()
}
// Note this won't work for certain chars
function reverse(str) {
    return str.split("").reverse().join("")
}
function findUp() {
    lastAction = "move"
    shouldAutocompleteLine = false
    hasMovedSinceNewLine = true
    acWord = null
    if (searchText.value.slice(0, 1) == ":" && (searchText.value.slice(1) - 0) == searchText.value.slice(1)) {
        fx.cursorLineIndex = searchText.value.slice(1) - 1 
        ensureCursorInScreen()
    }
    if (searchText.value == "") {
        if (fx.selectedRegions.length) {
            searchText.value = getSelectedLines(fx, false).lines[0]
        } else {
            searchText.value = getWordAtCursor().word
        }
        if (searchText.value == "") {
            navBack()
            return
            // searchText.value = "// mar"+"ker"
            searchText.value = " mar"+"ker"
        }
    }
    for (var i=fx.cursorLineIndex; i>=0; i--) {
        var lineToSearch = fx.lines[i]
        if (i == fx.cursorLineIndex) {
            lineToSearch = lineToSearch.substr(0, u(fx.cursorColIndex))
        }
        var pos = -1
        if (false && document.activeElement == searchText) {
            pos = reverse(lineToSearch.toLowerCase()).indexOf(reverse(searchText.value.toLowerCase()))
            lastSearchMatchLength = searchText.value 
        } else {
            if (useRegexSearch) {
                var theMatches = lineToSearch.matchAll(cachedSearchRegexpGlobal(searchText.value))
                var theMatch  = null
                for (theMatch of theMatches) {
                    // This lets theMatch var be the last one (or none)    
                }
                if (theMatch == null) {
                    pos = -1
                } else {
                    pos = theMatch.index
                    lastSearchMatchLength = theMatch[0].length 
                }
            } else {
                pos = reverse(lineToSearch).indexOf(reverse(searchText.value))
                lastSearchMatchLength = searchText.value 
            }
        }
        if (pos != -1) {
            if (i == fx.cursorLineIndex && !useRegexSearch) {
                pos += (fx.lines[i].length - u(fx.cursorColIndex))
            }
            fx.cursorLineIndex = i
            if (!useRegexSearch) {
                var colIndex = fx.lines[i].length - (pos + searchText.value.length)
                fx.cursorColIndex = expandTabIndex(fx.lines[i], colIndex, i)
            } else {
                // this pos is from the left
                // in the future we could probably make the non regexp more consistent where it loops to the last one. (maybe better than reversing string?)
                fx.cursorColIndex = expandTabIndex(lineToSearch, pos, null, null, "nocache")
            }
            updateCursorXY()
            ensureCursorInScreen()
            render()
            return true
        }
    }
    render()
    return false
}
function clearSearch() {
    searchText.value = ""
    render()
}

function updateCursorXY(file) {
    if (file != fx) {
        file = fx    
    }
    cursorX = (fx.cursorColIndex - fx.offsetX) * fontWidth
    cursorY = (fx.cursorLineIndex - fx.offsetY) * fontHeight
}

function indent() {
    // seems to be buggy
    // when first line indent is more than
    // last line indent
    if ((fx.lines[fx.cursorLineIndex] || "")[0] == "\t") {
        addPrefix("\t")
        return
    }
    addPrefix("    ")

}
function dedent() {
    stripPrefixes(["\t", "    "])
}

function comment(prefix) {
    var theLine
    if (fx.selectedRegions.length > 0) {
        theLine = fx.lines[fx.selectedRegions[0].startY] 
    } else {
        theLine = fx.lines[fx.cursorLineIndex]
    }
    
    if (!prefix) {
        if (
            fx.fullPath.endsWith(".sh") ||
            fx.fullPath.endsWith(".ini") ||
            fx.fullPath.endsWith(".pm") ||
            fx.fullPath.endsWith(".pl") ||
            fx.fullPath.endsWith(".env") 
        ) {
            prefix = "#"
        } else {
            prefix = "//"
        }
    }
    
    if (theLine.trim().startsWith(prefix)) {
        stripPrefixes([prefix+" ", prefix])
    } else {
        addPrefix(prefix+" ")
    }
}


function addPrefix(prefix) {
    if (fx.selectedRegions.length > 0) {
        var r = fx.selectedRegions[0]
        var firstIndent = ""
        var line = fx.lines[r.startY]
        var firstNonSpace = 0
        for (var i=0; i<line.length; i++) {
            var chr = line.charAt(i)
            if (chr != " " && chr != "\t") {
                firstNonSpace = i
                break
            }
        }
        for (var y=r.startY; y<=r.stopY; y++) {
            // fx.lines[y] = fx.lines[y].slice(0, firstNonSpace) + prefix + fx.lines[y].slice(firstNonSpace)
            updateLine(y, fx.lines[y].slice(0, firstNonSpace) + prefix + fx.lines[y].slice(firstNonSpace))
        }
    } else {
        var line = fx.lines[fx.cursorLineIndex]
        var firstNonSpace = 0
        for (var i=0; i<line.length; i++) {
            var chr = line.charAt(i)
            if (chr != " " && chr != "\t") {
                firstNonSpace = i
                break
            }
        }
        // fx.lines[fx.cursorLineIndex] = line.slice(0, firstNonSpace) + prefix + line.slice(firstNonSpace)
        updateLine(fx.cursorLineIndex, line.slice(0, firstNonSpace) + prefix + line.slice(firstNonSpace))
    }
    docChanged()
    render()
}

function stripPrefixes(prefixes) {
    if (fx.selectedRegions.length > 0) {
        var r = fx.selectedRegions[0]
        for (var y=r.startY; y<=r.stopY; y++) {
            // fx.lines[y] = stripPrefixesInner(fx.lines[y], prefixes)
            updateLine(y, stripPrefixesInner(fx.lines[y], prefixes))
            
        }
    } else {
        var line = fx.lines[fx.cursorLineIndex]
        // fx.lines[fx.cursorLineIndex] = stripPrefixesInner(line, prefixes)
        updateLine(fx.cursorLineIndex, stripPrefixesInner(line, prefixes))
    }
    docChanged()
    render()
}

function isWhiteSpace(str) {
    for (var i=0; i<str.length; i++) {
        var chr = str.charAt(i)
        if (chr != " " && chr != "\t") {
            return false
        }
    }
    return true
}
function stripPrefixesInner(line, prefixes) {
    for (var i=0; i<prefixes.length; i++) {
        var prefix = prefixes[i]
        var prefixPos = line.indexOf(prefix)
        if (prefixPos != -1) {
            if (isWhiteSpace(line.slice(0, prefixPos))) {
                line = line.slice(0, prefixPos) + line.slice(prefixPos + prefix.length)
                break
            }
        }
    }
    return line
}

function copyString(s) {
    copyBuffer = s.split("\n")    
    copyEl.value = s
}
function copy() {
    // wrapping in for loop to simulate goto
    for (var s=0; s<1; s++) {
        if (fx.selectedRegions.length>0) {
            var r = fx.selectedRegions[0]
            if (r.startY == r.stopY) {
                copyBuffer = [fx.lines[r.startY].slice(u(r.startX), u(r.stopX))]
                fx.selectedRegions = []
                render()
                break
            }
            copyBuffer = [
                unExpandSlice(fx.lines[r.startY], r.startX, -1, r.startY),
                ...fx.lines.slice(r.startY + 1, r.stopY),
                unExpandSlice(fx.lines[r.stopY], 0, r.stopX, r.stopY)
            ]
            fx.selectedRegions = []
            render()
            break
        }
        selectMode = "line"
        copyBuffer = [fx.lines[fx.cursorLineIndex]]
    }

    var copyBufferString = copyBuffer.join("\n")
    copyEl.value = copyBufferString
    
    // I think this is not working because it's on a touchmove event?
    // And not a simple on like onclick
    // navigator.clipboard.writeText(copyBufferString).then(function() {
    //    alert("copied") 
    // }, function(e) {
    //    alert("not copied: " + e) 
    // })
    
    
    // copyEl.setSelectionRange(0, copyEl.value.length)
    // var range = document.createRange()
    // range.selectNodeContents(copyEl)
    // var sel = window.getSelection()
    // sel.removeAllRanges()
    // sel.addRange(range)
    // document.execCommand("copy")
}

function runScript() {
    var oldCopyBuffer = copyBuffer
    copy()
    var theScriptLines = copyBuffer
    // add return to the last non-empty line
    for (var i=theScriptLines.length-1; i>=0; i--) {
        if (theScriptLines[i].trim() != "") {
            theScriptLines[i] = "return " + theScriptLines[i]
            break
        }            
    }
    var code = theScriptLines.join("\n")
    var f = new Function(code)
    var ret = f()
    ret = ret + ""
    copyBuffer = ret.split("\n")
    paste()
    copyBuffer = oldCopyBuffer
}

function diffFiles() {
    // second-most-recent file
    var aLines = getSelectedLines(lastFile).lines    
    var bLines = getSelectedLines(fx).lines    
    
    var start = Date.now()
    var contents = simpleDiffOld3(aLines, bLines, false).join("\n")
    log("diff3: " + (Date.now()-start))
    var f3 = makeFile("__diffOld3", 0, contents)
    f3.fileMode = "file"
    f3.cursorLineIndex = 0
    addFileToList(f3)
    
    // var oldContents = aLines.join("\n")
    // var newContents = bLines.join("\n")
    // var start = Date.now()
    // var contents = Diff.createPatch("foo", oldContents, newContents, "", "", {context:0})
    // // var contents = Diff.createPatch("foo", "aaaaa", "bbbbbb", "", "")
    // log("diffM: " + (Date.now()-start))
    // var f4 = makeFile("__diffMyers", 0, contents)
    // f4.fileMode = "file"
    // f4.cursorLineIndex = 0
    // addFileToList(f4)
    // setCurrentFile(f4)
    
    setCurrentFile(f3)
    updateCursorXY()
    ensureCursorInScreen()
}

// this is a little hacky by changing and restoring state.
function getSelectedLines(f, shouldDeleteSelected) {
    // save old
    // in scriptLines we also have "oldPreventRender" business going on. doesn't 'harm' anything but a bit ugly.
    var oldPreventRender = preventRender
    var oldCopyBuffer = copyBuffer
    var oldFx = fx
    
    // mutate
    // Setting the global fx because functions like del() and copy depend on it
    // We could instrad have extra functions that allow you to pass in
    // the file, like updateLine bs updateLineFile
    fx = f
    preventRender = true
    var isWholeFile = false
    // run and snag
    if (fx.selectedRegions.length) {
        // now copyBuffer has the lines we want to tweak
        if (shouldDeleteSelected) {
            // TODO: make it so this delete doesn't update the undo stack
            // or change use so there is no option to delete here
            del()
        } else {
            copy()
        }
    } else {
        // if nothing is selected, let's deal with all the lines
        // note that we don't yet support shouldDeleteSelected here. 
        copyBuffer = fx.lines.slice() // slice here acts as a copy. Do we need a copy? doing it to be safe
        isWholeFile = true
    }
    theLines = copyBuffer
    
    // restore
    copyBuffer = oldCopyBuffer
    preventRender = oldPreventRender
    fx = oldFx
    
    return {
        lines: theLines,
        isWholeFile: isWholeFile,
    }
}

function scriptLinesInline() {
    var oldPreventRender = preventRender
    preventRender = true
    
    // second-most-recent file
    var _t = getSelectedLines(fx, true)
    var linesToProcess = _t.lines
    var isWholeFile = _t.isWholeFile
    var s = linesToProcess[0].trim().slice(2).trim()
    if (s.slice(0, 2) == "r ") {
        var parts = s.split(" ")
        s = `x.replaceAll("${parts[1]}", "${parts[2]}")`
    } else if (s.slice(0, 2) == "l ") {
        // l w w x n r - $a $b $c $d
        var parts = s.split(" - ")
        s = `ll(x,"${parts[0].slice(2)}", "${parts.slice(1).join(" - ")}")`
    }
    var theScriptLines = [s]
    linesToProcess = linesToProcess.slice(1)
    if (theScriptLines.length) {
        // add return to the last non-empty line
        for (var i=theScriptLines.length-1; i>=0; i--) {
            if (theScriptLines[i].trim() != "") {
                theScriptLines[i] = "return " + theScriptLines[i]
                break
            }            
        }
        var funcBody = theScriptLines.join("\n")
        log("funcBody: " + funcBody)
        var f = function(x) {
            return x
        }
        try {
            line = f(line)
            f = new Function("x", funcBody)
        } catch (e) {
            alert(e)  
        }
        var retLines = []
        for (var i=0; i<linesToProcess.length; i++) {
            var line = linesToProcess[i]
            try {
                line = f(line)
            } catch (e) {
                alert(e)  
            }
            retLines.push(line)
        }    
    }
    if (isWholeFile) {
        setLines(retLines) 
        docChanged()
    } else {
        pasteLines(retLines,false, true)
    }
    
    preventRender = oldPreventRender
    render()
}
function scriptLines() {
    var oldPreventRender = preventRender
    preventRender = true
    
    // second-most-recent file
    var _t = getSelectedLines(lastFile, true)
    var linesToProcess = _t.lines
    var isWholeFile = _t.isWholeFile
    
    var theScriptLines = getSelectedLines(fx, false).lines
    
    if (theScriptLines.length) {
        // add return to the last non-empty line
        for (var i=theScriptLines.length-1; i>=0; i--) {
            if (theScriptLines[i].trim() != "") {
                theScriptLines[i] = "return " + theScriptLines[i]
                break
            }            
        }
        var funcBody = theScriptLines.join("\n")
        log("funcBody: " + funcBody)
        var f = function(x) {
            return x
        }
        try {
            line = f(line)
            f = new Function("x", funcBody)
        } catch (e) {
            alert(e)  
        }
        var retLines = []
        for (var i=0; i<linesToProcess.length; i++) {
            var line = linesToProcess[i]
            try {
                line = f(line)
            } catch (e) {
                alert(e)  
            }
            retLines.push(line)
        }    
    }
    setCurrentFile(lastFile) // second-most-recent file
    if (isWholeFile) {
        setLines(retLines) 
        docChanged()
    } else {
        pasteLines(retLines,false, true)
    }
    
    preventRender = oldPreventRender
    render()
}



function regexer(r) {
    return function(c, line, index) {
       return r.test(c)    
    }
}
function notRegexer(r) {
    return function(c, line, index) {
       return (line.length == index) || !r.test(c)    
    }
}
function ll(line, script, replacement) {
    var cmds = script.split(" ")
    var index = 0
    var startSelect = 0
    var vars = {"$": "$"}
    var varsArray = []
    var cmd
    var c
    var matchIndex = 0
    matchVars = "abcdefghijklmnoqrs"
    var findCurrentOrNext = function(capture, rs, re, process) {
        var start = -1
        
        // need to go past the end, this <=
        for (index = index; index <= line.length; index++) {
            if (start == -1) {
                // you could do fewer checks if you manage more state
                if (rs(line[index], line, index) && (index == 0 || !rs(line[index-1], line, index))) {
                    start = index    
                }
            } else {
                if (re(line[index], line, index)) {
                    // you could have a processor func
                    if (!capture) {
                        break
                    }
                    var v = line.slice(start, index) 
                    if (process) {
                       v = process(v)    
                    }
                    vars[matchVars[matchIndex]] = v 
                    varsArray.push(v)
                    matchIndex++
                    break
                }
            }
        }
    }
    for (var i=0; i<cmds.length; i++) {
        cmd = cmds[i]
        switch (cmd) {
        case "w":
            findCurrentOrNext(true, regexer(/[\w]/), notRegexer(/[\w]/))
            break
        case "x":
            findCurrentOrNext(false, regexer(/[\w]/), notRegexer(/[\w]/))
            break
        case "n":
            findCurrentOrNext(true, regexer(/[0-9\.\-]/), notRegexer(/[0-9\.\-]/), function(x) {
                return x - 0
            })
            break
        case "0":
            findCurrentOrNext(false, regexer(/[0-9\.\-]/), notRegexer(/[0-9\.\-]/))
            break
        case "r":
            findCurrentOrNext(true, regexer(/[\w]/), function(c, line, index) {
              if (index == line.length) {
                  return true
              }
              return false     
            })
            break
        // you could use closures to things like capture strings with escaping?
        }
    }
    if (typeof replacement ==  "function") {
        return replacement.apply(null, varsArray)    
    } else {
        return replacement.replace(/\$[a-z\$]/g, function(match) {
            return vars[match[1]]      
        }) 
    }
    
}
/*
r = ll(
    `-34.2 number %% 400.123 # forever young `,
    "n w n r",
    "$b is $a and $c === $d"
)
r

r = ll("1/2/300", "n 0 n", (a,b) => {
   return a + b
})
r
301
NaN
303

number is -34.2 and 400.123 === forever young 
$b is $a and $c === $d
number is -34.2 and 400.123 === forever young 
*/


// little language for manipulating lines. inspired by vim.
/*
ll(`food   => ate:  dog: and that's a wrap!`, "Ca w Cb w Cc w Ed", "yo $c $b $a ($d)")
yo dog ate food (and that's a wrap!)
: Ca : $a 
*/

function llOld(line, script, replacement) {
    // w v e ya
    var cmds = script.split(" ")
    var index = 0
    var startSelect = 0
    var vars = {"$": "$"}
    var cmd
    var c
    
    log(`${index} ${line[index]} ${wordyFunc(line[index])}`)
    var w = function(wordyFunc) {
        var finishedWord = false
        log("w at " + line.slice(index))
        var isw = wordyFunc(line[index]) 
        for (index = index; index < line.length; index++) {
            log(`${index} ${line[index]} ${wordyFunc(line[index])} (${isw})`)
            if (line[index] == " ") {
                finishedWord = true
                continue
            } 
            isw2 = wordyFunc(line[index])
            if (isw != isw2 || finishedWord) {
                break
            }
        }
    }
    var e = function(wordyFunc) {
        log("e at " + line.slice(index))
        var isw = wordyFunc(line[index]) 
        for (index = index; index < line.length; index++) {
            log(`${index} ${line[index]} ${wordyFunc(line[index])}`)
            isw2 = wordyFunc(line[index])
            if (isw != isw2) {
                index--
                log(`${index} ${line[index]} ${wordyFunc(line[index])}`)
                break
            }
        }
    }
    var endLine = function() {
        log("$ at " + line.slice(index))
        index = line.length - 1
    }
    var v = function() {
        log("v at " + line.slice(index))
        startSelect = index
    }
    var y = function() {
        log("y at " + line.slice(index))
        var varName = cmd.slice(1)
        vars[varName] = line.slice(startSelect, index+1)
    }
    var f = function() {
        log("f at " + line.slice(index))
        var theChar = cmd[1]
        for (index = index; index < line.length; index++) {
            if (line[index] == theChar) {
                break
            }
        }
    }
    var t = function() {
        log("t at " + line.slice(index))
        var theChar = cmd[1]
        for (index = index; index < line.length; index++) {
            if (line[index] == theChar) {
                index--
                break
            }
        }
    }
    var r = function() {
        log("r at " + line.slice(index))
        index++
    }
    for (var i=0; i<cmds.length; i++) {
        cmd = cmds[i]
        c = cmd[0]
        switch (c) {
        case "w":
            w(isWordyChar)
            break
        case "e":
            e(isWordyChar)
            break
        case "n":
            w(isNumberChar)
            break
        case "m":
            e(isNumberChar)
            break
        case "v":
            v()
            break
        case "$":
            endLine()
            break
        case "y":
            y()
            break
        case "C": // copy word and go to next
            v()
            e(isWordyChar)
            y()
            w()
            break   
        case "E": // copy to end
            v()
            endLine()
            y()
            break
        case "r":
            r()
            break
        case "f":
            f()
            break
        case "t":
            t()
            break
        }
    }
    return replacement.replace(/\$[a-z\$]/g, function(match) {
        return vars[match[1]]      
    }) 
}



function setCanvasHeight(h) {
    canvasHeight = h
    
    // these 2 lines are new
    c.height = canvasHeight
    c.style.height = (canvasHeight/3)+"px"
     
    maxLines = Math.floor(canvasHeight / fontHeight)
}
function setCanvasHeightAccordingly() {
    var heightReduction = 0
    if (inDebugView) {
        var statusElHeight = 200
        statusEl.style.height = statusElHeight + "px"
        logEl.style.height = statusElHeight + "px"
        heightReduction = statusElHeight * 3       
    }
    if (document.activeElement == theText || document.activeElement == searchText) {
        if (fx.fileMode == "terminal") {
            setCanvasHeight(canvasHeightKeyboardTerminal - heightReduction)
        } else {
            setCanvasHeight(canvasHeightKeyboard - heightReduction)
        }
    } else {
       if (fx && fx.fileMode == "bash") {
           setCanvasHeight(canvasHeightBash - heightReduction)   
       } else if (fx && fx.fileMode == "terminal") {
           setCanvasHeight(canvasHeightTerminal - heightReduction)   
       } else {
           setCanvasHeight(canvasHeightFull - heightReduction)   
       }
    }
    render()
}
function setCanvasWidth(w) {
    canvasWidth = w
    maxCols = Math.floor(canvasWidth / fontWidth)
}

function insertText(theLines, yOffset, xOffset) {
    selectMode = "line"
    if (xOffset == -1) {
       xOffset = theLines[yOffset].length
    }
    var oldCopyBuffer = copyBuffer
    copyBuffer = theLines
    paste()
    fx.selectedRegions = []
    fx.cursorLineIndex = fx.cursorLineIndex + yOffset + 1
    var theLine = fx.lines[fx.cursorLineIndex]
    fx.cursorColIndex = expandTabIndex(theLine, xOffset)
    ensureCursorInScreen()
    render()
    copyBuffer = oldCopyBuffer
}
function paste(unselect, pasteBefore) {
    pasteLines(copyBuffer, unselect, pasteBefore)
}
function pasteLines(copyBuffer, unselect, pasteBefore) {
    if (!hasMovedSinceCut && globalOldCopyBuffer.length) {
        copyBuffer = globalOldCopyBuffer
    }
    if (copyBuffer.length == 0) {
        return
    }
    if (selectMode == "line") {
        var theOffset = 1
        var theOffset2 = 0
        if (pasteBefore) {
            theOffset = 0
            theOffset2 = -1
        }
        fx.lines.splice(fx.cursorLineIndex + theOffset, 0, ...copyBuffer)
        var stopY = fx.cursorLineIndex + copyBuffer.length + theOffset2
        var lastLine = fx.lines[stopY] || ""
        if (!unselect) {
            fx.selectedRegions = [{
                startY: fx.cursorLineIndex + theOffset,
                // remember stopY is inclusive, stopX no
                stopY: stopY,
                startX: 0,
                stopX: expandTabIndex(lastLine, lastLine.length, stopY),
            }]
        }
    } else if (selectMode == "char") {
        if (copyBuffer.length == 1) {
            // fx.lines[fx.cursorLineIndex] = fx.lines[fx.cursorLineIndex].slice(0, u(fx.cursorColIndex)) +
            // copyBuffer[0] +
            // fx.lines[fx.cursorLineIndex].slice(u(fx.cursorColIndex))
            updateLine(fx.cursorLineIndex, fx.lines[fx.cursorLineIndex].slice(0, u(fx.cursorColIndex)) +
                copyBuffer[0] +
                fx.lines[fx.cursorLineIndex].slice(u(fx.cursorColIndex))
            )
            
            // #alternateTap
            if (!unselect) {
                var theLine = fx.lines[fx.cursorLineIndex] || ""
                var sr = {
                    startY: fx.cursorLineIndex,
                    startX: fx.cursorColIndex,
                    stopX: expandTabIndex(theLine, u(fx.cursorColIndex) + copyBuffer[0].length),
                    stopY: fx.cursorLineIndex,
                }
                fx.selectedRegions = [sr]
            }
        } else {
            var line = fx.lines[fx.cursorLineIndex]
            // fx.lines[fx.cursorLineIndex] = line.slice(0, u(fx.cursorColIndex)) +
            //     copyBuffer[0]
            updateLine(fx.cursorLineIndex, line.slice(0, u(fx.cursorColIndex)) +
                copyBuffer[0]
            )
            // copyBuffer[copyBuffer.length-1] += line.slice(u(fx.cursorColIndex))
            // fx.lines.splice(fx.cursorLineIndex+1, 0, ...copyBuffer.slice(1))
            lastLine = copyBuffer[copyBuffer.length-1] + line.slice(u(fx.cursorColIndex))
            fx.lines.splice(fx.cursorLineIndex+1, 0, ...copyBuffer.slice(1, -1), lastLine)
            
            // #alternateTap
            if (!unselect) {
                var lastCopyBufferLine = copyBuffer[copyBuffer.length - 1]
                var sr = {
                    startY: fx.cursorLineIndex,
                    startX: fx.cursorColIndex,
                    stopX: expandTabIndex(lastCopyBufferLine, lastCopyBufferLine.length, null, null, "nocache"),
                    stopY: fx.cursorLineIndex + copyBuffer.length - 1,
                }
                fx.selectedRegions = [sr]
            }
        }
    }
    docChanged()
    render()
}

var globalOldCopyBuffer = []
var hasMovedSinceCut = true
function del(preventCopy, preventDeleteWholeLine) {
    globalOldCopyBuffer = copyBuffer
    hasMovedSinceCut = false
    
    if (fx.selectedRegions.length>0) {
        var r = fx.selectedRegions[0]
        if (r.startY == r.stopY) {
            if (!preventDeleteWholeLine && r.startX == 0 && unExpandTabIndex(fx.lines[r.startY], r.stopX, r.startY) == fx.lines[r.startY].length) {
                selectMode = "line"
                if (!preventCopy) {
                    copyBuffer = [fx.lines[r.startY]]
                    // cutBuffer = [fx.lines[r.startY]]
                }
                fx.lines.splice(r.startY, 1)
                fx.selectedRegions = []
                if (r.startY > 0) {
                    // subtract 1 so we can paste right afer
                    fx.cursorLineIndex = r.startY - 1
                    updateCursorXY()
                }
                docChanged()
                render()
                return
            } else {
                // I don't remember adding this. Is this right?
                // selectMode = "char"
                if (!preventCopy) {
                    copyBuffer = [unExpandSlice(fx.lines[r.startY], r.startX, r.stopX, r.startY)]
                    // cutBuffer = [unExpandSlice(fx.lines[r.startY], r.startX, r.stopX)]
                }
                // fx.lines[r.startY] = unExpandSlice(fx.lines[r.startY], 0, r.startX) +
                //     unExpandSlice(fx.lines[r.startY], r.stopX)
                updateLine(r.startY, unExpandSlice(fx.lines[r.startY], 0, r.startX, r.startY) +
                    unExpandSlice(fx.lines[r.startY], r.stopX, -1, r.startY)
                )
                fx.selectedRegions = []
                fx.cursorLineIndex = r.startY
                fx.cursorColIndex = r.startX
                updateCursorXY()
                fx.selectedRegions = []
                docChanged()
                render()
                if (document.activeElement == theText) {
                    //theText.setSelectionRange(r.startX, r.startX)
                    setSelectionRangeForText(r.startX, r.startX)
                }
                return
            }
        }
        var fullLines = r.startX == 0 && unExpandTabIndex(fx.lines[r.stopY], r.stopX, r.stopY) == fx.lines[r.stopY].length
        if (!preventCopy) {
            // cutBuffer = [
            copyBuffer = [
                unExpandSlice(fx.lines[r.startY], r.startX, -1, r.startY),
                ...fx.lines.slice(r.startY + 1, r.stopY),
                unExpandSlice(fx.lines[r.stopY], 0, r.stopX, r.stopY)
            ]
        }
        // fx.lines[r.startY] = unExpandSlice(fx.lines[r.startY], 0,  r.startX) +
        //     unExpandSlice(fx.lines[r.stopY], r.stopX)
        updateLine(r.startY, unExpandSlice(fx.lines[r.startY], 0,  r.startX, r.startY) +
            unExpandSlice(fx.lines[r.stopY], r.stopX, -1, r.stopY)
        )
        fx.lines.splice(r.startY + 1, r.stopY-r.startY)
        if (!preventDeleteWholeLine) {
            if (fx.lines[r.startY] == "") {
                fx.lines.splice(r.startY, 1)
            }
        }
        fx.cursorLineIndex = r.startY
        fx.cursorColIndex = r.startX
        
        // if full lines then move cursor up once to paste
        if (fullLines) {
            fx.cursorColIndex = -5
            if (fx.cursorLineIndex > 0) {
                fx.cursorLineIndex -= 1
            }
        }
        updateCursorXY()
        fx.selectedRegions = []
        docChanged()
        render()
        if (document.activeElement == theText) {
            //theText.setSelectionRange(r.startX, r.startX)
            setSelectionRangeForText(r.startX, r.startX)
        }
        return
    }
    selectMode = "line"
    if (!preventCopy) {
        // cutBuffer = [fx.lines[fx.cursorLineIndex]]
        copyBuffer = [fx.lines[fx.cursorLineIndex]]
    }
    fx.lines.splice(fx.cursorLineIndex, 1)
    docChanged()
    render()
}
function getIndent(line) {
    var theIndent = ""
    for (var i=0; i<line.length; i++) {
        var theChar = line.charAt(i)
        if (theChar == " " || theChar == "\t") {
            theIndent += theChar
        } else {
            return theIndent
        }
    }
    return theIndent
}
function insertLine(closeCurly, oMode) {
    if (fx.fileMode == "directory") {
        clickItemInDirectory()
        return
    }
    lastAction = "type"
    hasMovedSinceNewLine = false
    acWord = null
    var theLine = fx.lines[fx.cursorLineIndex]
    var theIndent = getIndent(theLine)
    var prevChar = theLine[u(fx.cursorColIndex - 1)]
    var nextChar = theLine[u(fx.cursorColIndex)]
    var strIndex = theText.selectionStart
    log([prevChar, nextChar])
    
    // if they are at the beginning, or there is an auto-closer before us
    // then we don't want oMode
    // otherwise oMode is like typing o in vim
    // if (oMode && strIndex != 0 && !(prevChar in closingMap)) {
    if (oMode && strIndex != 0 && (!prevChar || isWordy(prevChar.charCodeAt(0))) && (!nextChar || isWordy(nextChar.charCodeAt(0)))) {
        strIndex = theLine.length
        // get the smaller indent
        var theNextIndent = getIndent(fx.lines[fx.cursorLineIndex + 1] || "")
        theIndent = max(theIndent, theNextIndent)
    }
    fx.lines.splice(fx.cursorLineIndex + 1, 0, theIndent + theLine.substr(strIndex))
    if (closeCurly && (prevChar in closingMap) && (nextChar == closingMap[prevChar])) {
        theIndent += "    "
        fx.lines.splice(fx.cursorLineIndex + 1, 0, theIndent)
    }
    // fx.lines[fx.cursorLineIndex] = theLine.substr(0, strIndex)
    updateLine(fx.cursorLineIndex, theLine.substr(0, strIndex))
    fx.cursorLineIndex += 1
    fx.cursorColIndex = expandTabIndex(fx.lines[fx.cursorLineIndex], theIndent.length)
    updateCursorXY()
    ensureCursorInScreen()
    docChanged()
    render()
    renderTheText(fx.lines[fx.cursorLineIndex])
}
function uploadFile(e) {
    e.preventDefault()
    let formData = new FormData();
    for (var i=0; i<filesToUpload.files.length; i++) {
        formData.append("thefiles", filesToUpload.files[i]);
    }
    fetch(proxyPath + '/myuploadfiles', {
        method: "POST", body: formData
    }).then(() => {
        alert("done uploading")
    }).catch(e => {
        alert("error uploading files:" + e)
    })
    return false
}
function newLine(e, shouldFocus) {
    var theLine = fx.lines[fx.cursorLineIndex]
    e && e.preventDefault()
    if (fx.fileMode == "bash") {
        runBashCommand(theLine)
        return false
    } else if (fx.fileMode == "terminal") {
        // #todoterminal Send the right command to the server
    }
    // insertLine(true)
    insertLine(true, true) // this one just makes a new line
    if (shouldFocus) {
        theText.focus()
        //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
        setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
    }
    return false
}
function runBashCommand(line) {
    // outer loop to simulate goto
    if (fx.fileMode != "bash") {
        return
    }
    var oldCopyBuffer = copyBuffer
    for (var s=0; s<1; s++) {
        if (line == "clear") {
            // clear everything but the last 2 lines
            // TODO: should we be using set lines here?
            fx.lines = fx.lines.slice(-4)
            if (fx.lines.length == 0) {
                fx.lines = [""]
            }
            fx.cursorLineIndex = 0
            fx.cursorColIndex = 0
            updateCursorXY()
            fx.offsetY = 0
            // render()
            // return
            line = "p"
        }

        if (line.startsWith("open ")) {
            var fileToLoad = line.split(" ")[1]
            copyBuffer = [""]
            paste(true)
            fx.cursorLineIndex += 1
            fx.cursorColIndex = 0
            ensureCursorInScreen()
            addFile(trimPrefix(fx.bashCWD, rootLocation) + "/" + fileToLoad)
            break
        }

        if (line == "p") {
            // TODO: should we be restoring the old copyBuffer here?
            copyBuffer = bashHelpers.concat([
                // Adding the cwd here because it's helpful
                fx.bashCWD
                    .split("/")
                    .reverse()
                    .join(" < ")
            ])
            paste(true)
            fx.cursorLineIndex = fx.lines.length - 2
            
            fx.cursorColIndex = 0
            updateCursorXY()
            ensureCursorInScreen()
            break
        }

        let myFx = fx
        fetch(proxyPath + "/mybash?id="+fx.ID+"&cwd="+encodeURIComponent(fx.bashCWD)+"&cmd="+encodeURIComponent(line), {
            cache: "no-cache"
        }).then(r => {
            if (r.headers.get("X-ID")) {
                myFx.ID = r.headers.get("X-ID") - 0
            }
            return r.text()
        }).then(r => {
            var oldFx = fx
            fx = myFx
            copyBuffer = r.split("\n")
            copyBuffer.unshift("") // leading newline
            // second to last item is cwd
            myFx.bashCWD = copyBuffer[copyBuffer.length - 2]
            // let's restyle the pwd after we grab it
            
            // TODO: maybe come up with something more elegant than this paste dance
            copyBuffer[copyBuffer.length - 2] = myFx.bashCWD
                .split("/")
                .reverse()
                .join(" < ")
            copyBuffer.push(line) // add the line so it's easy to run again.
            copyBuffer.push("")
            myFx.cursorColIndex = 0
            myFx.cursorLineIndex += copyBuffer.length
            myFx.cursorLineIndex = myFx.lines.length - 1
            selectMode = "line"
            paste(true)
            myFx.cursorLineIndex = myFx.lines.length - 1
            updateCursorXY()
            ensureCursorInScreen()
            copyBuffer = oldCopyBuffer
            fx = oldFx
        }).catch(e => {
            alert("There was an error running the command: " + e)
        })
    }
    copyBuffer = oldCopyBuffer
}
function saveTerminalName(name) {
    if (fx.fileMode != "terminal") {
        return
    }
    fetch(proxyPath + "/myterminalname?id="+fx.ID+"&name=" + encodeURIComponent(name), {cache: "no-cache"})
    .then(r => r.json())
    .then(r => {})
    .catch(r => {})
    fx.name = name
    renderURL()
    renderFileDropdown()
}

var allowPolling = true
var isPollingTerminal = false
function pollTerminals() {
    if (!allowPolling) {
        // so we can manually disable polling
        return false
    }
    isPollingTerminal = true
    if (!files.some(f => f.fileMode == "terminal")) {
        isPollingTerminal = false
        return
    }
    log("Polling!")
    fetch(proxyPath + "/myterminalpoll", {
        cache: "no-cache"
    }).then(r => {
        return r.json()
    }).then(r => {
        // map of terminals and their payload and maybe meta info
        log("result: " + JSON.stringify(r, "", "    "))
        for (var id in r) {
            var termInfo = r[id]
            var file = files.find(f => f.ID == id)    
            if (!file) {
                // TODO: this can happen if we get the response for
                // the poll before we even have the ID
                // we could store these values temporarily?
                // but for now we'll ignore them.
                continue
            }
            var oldCopyBuffer = copyBuffer
            // btoa("hello")
            // atob("aGVsbG8=")
            // #todoterminal: add xterm parsing here!
            var strToProcess = atob(termInfo.Base64)
            // simple parsing for now
            log("term"+JSON.stringify(strToProcess))
            var parseState = "literal"
            var controlValues = [""]
            for (var i = 0; i < strToProcess.length; i++) {
                // not calling docChanged because we don't care for terminals
                // doing this very dumb now... more optimizations later
                var theChr = strToProcess[i]
                switch (parseState) {
                    case "literal":
                        if (strToProcess[i] == "\n") {
                            file.lines.push("")
                        // for  now commenting out \r, later do I need to code the difference between newline and carriage return?
                        // } else if (strToProcess[i] == "\r") {
                        //     file.lines.push("")
                        } else if (strToProcess[i] == "\b") {
                            // copied from another part of this code // == 8    
                            var theLine = file.lines[file.cursorLineIndex]
                            if (theLine.length == 0) {
                                file.lines.splice(file.cursorLineIndex, 1)
                                file.cursorLineIndex -= 1
                                var prevLine = file.lines[file.cursorLineIndex]
                                // file.lines[file.cursorLineIndex] = file.lines[file.cursorLineIndex] + theLine
                                updateLine(file, file.cursorLineIndex, file.lines[file.cursorLineIndex] + theLine)
                                // TODO: process the index here!!!
                                file.cursorColIndex = prevLine.length
                                setSelectionRangeForText(prevLine.length, prevLine.length)
                            } else {
                                log("normal!!")
                                // file.lines[file.lines.length-1] = theLine.slice(0, -1)
                                updateLineFile(file, file.lines.length-1, theLine.slice(0, -1))
                            } 
                        } else if (strToProcess[i] == "\x1b") { // escape
                            parseState = "ESC"
                        } else if (strToProcess[i] == "\x07") { // bell
                            // do nothing
                        // } else if (strToProcess[i] == "\t") { // tab
                        } else {
                            // file.lines[file.lines.length-1] += strToProcess[i]
                            updateLineFile(file, file.lines.length-1, file.lines[file.lines.length-1] + strToProcess[i])
                        }
                        break;    
                    case "ESC":
                        switch (theChr) {
                            case "[":
                                controlValues = [""]
                                parseState = "CSI"
                                break;
                            default:
                                parseState = "literal" // for now
                            
                        }
                        break;
                    case "CSI":
                        switch (theChr) {
                            case "0":
                                controlValues[controlValues.length-1] += theChr 
                                break;
                            case "1":
                                controlValues[controlValues.length-1] += theChr 
                                break;
                            case "2":
                                controlValues[controlValues.length-1] += theChr 
                                break;
                            case "3":
                                controlValues[controlValues.length-1] += theChr 
                                break;
                            case "4":
                                controlValues[controlValues.length-1] += theChr 
                                break;
                            case "5":
                                controlValues[controlValues.length-1] += theChr 
                                break;
                            case "6":
                                controlValues[controlValues.length-1] += theChr 
                                break;
                            case "7":
                                controlValues[controlValues.length-1] += theChr 
                                break;
                            case "8":
                                controlValues[controlValues.length-1] += theChr 
                                break;
                            case "9":
                                controlValues[controlValues.length-1] += theChr 
                                break;
                            case ";":
                                controlValues.push("")
                                break;
                            case "K":
                                // TODO: clear parts of line according to rules
                                parseState = "literal"
                                break;
                            default:
                                // TODO: some action based the character here
                                // add textual representation for debugging purposes
                                // uncomment to debug
                                // file.lines[file.lines.length - 1] += " <ESC[" + controlValues.join(";") + theChr + "> "
                                // updateLineFile(file, file.lines.length - 1, file.lines[file.lines.length - 1] + " <ESC[" + controlValues.join(";") + theChr + "> ")
                                
                                parseState = "literal" // for now
                            
                        }
                        break;
                }
            }
            file.cursorLineIndex = file.lines.length - 1
            var theLine = file.lines[file.lines.length-1]
            file.cursorColIndex = expandTabIndex(theLine, theLine.length, file.lines.length-1, file)
            ensureCursorInScreen(file)
        }
        render()
        setTimeout(pollTerminals, 1)
    }).catch(e => {
        // todo: does an error in the prev block also go here
        // if so we need to make sure we don't double poll
        // as a double check, in the polling code if there id a request
        // in-flight, don't poll again.
        // alert("polling error: " + e)
        setTimeout(pollTerminals, 1)
    })
}
var sendingTerminal = false
var sendTerminalBuffer = ""
function sendTerminal(payload) {
    if (sendingTerminal) {
        sendTerminalBuffer += payload
        return
    }
    // big TODO (#todoterminal)...  serialize, consider debounce.
    // make sure we only have one of these going at a time 
    // also, binary payload?
    sendingTemrinal = true
    fetch(proxyPath + "/myterminalsend?id=" + fx.ID + "&payload=" + encodeURIComponent(payload), {
        cache: "no-cache"
    // }).then(r => {
    //     return r.json()
    }).then(r => {
        sendingTemrinal = false
        if (sendTerminalBuffer.length) {
            var tmp = sendTerminalBuffer
            sendTerminalBuffer = ""
            sendTerminal(tmp)
        }
    }).catch(e => {
        sendingTemrinal = false
        if (sendTerminalBuffer.length) {
            var tmp = sendTerminalBuffer
            sendTerminalBuffer = ""
            sendTerminal(tmp)
        }
        alert("There was an error sending terminal: " + e)
    })
}
function openTerminal() {
    if (fx.fileMode != "terminal") {
        return
    }
    if (!isPollingTerminal) {
        pollTerminals()    
    }
    var myFx = fx // in case the scope changes
    fetch(proxyPath + "/myterminalopen?cwd="+encodeURIComponent(fx.bashCWD), {
        cache: "no-cache"
    }).then(r => {
        return r.json()
    }).then(r => {
        myFx.ID = r.ID
    }).catch(e => {
        alert("There was an error running the command: " + e)
    })
}
function closeFileServer(theFile) {
    if (!theFile) {
        theFile = fx
    }
    return fetch(proxyPath + "/myclose?id=" + theFile.ID, {
        cache: "no-cache"
    // }).then(r => {
    //     return r.json()
    })
}
function stopServer() {
   fetch(proxyPath + "/stop", {
        cache: "no-cache",
        method: "POST",
        headers: {},
        body: "",
   }).then(r => {
   }).catch(e => {
   })
}

function trimPrefix(str, prefix) {
    if (str.startsWith(prefix)) {
        return str.slice(prefix.length)
    }
    return str
}
// marker aquamarine
function setSelectionRangeForText(start, end) {
    var adjustedStart = u(start)
    var adjustedEnd
    if (start == end) {
        adjustedEnd = adjustedStart
    } else {
        adjustedEnd = u(end)
    }
    theText.setSelectionRange(adjustedStart, adjustedEnd)
}

function unExpandSlice(theLine, start, end, index, file) {
    theLine = theLine || ""
    var adjustedStart = unExpandTabIndex(theLine, start, index, file)
    if (typeof end == "undefined" || end == -1) {
        return theLine.slice(adjustedStart)
    }
    var adjustedEnd = unExpandTabIndex(theLine, end, index, file)
    return theLine.slice(adjustedStart, adjustedEnd)
}

var globalTabStop = 4
function toggleTabStop() {
    switch (globalTabStop) {
        case 2:
            globalTabStop = 4
            break;    
        case 4:
            globalTabStop = 8
            break;    
        case 8:
            globalTabStop = 16
            break;    
        case 16:
            globalTabStop = 32
            break;    
        case 32:
            globalTabStop = 2
            break;    
    }
    toggleTabStopButton.innerText = globalTabStop + " tabs" 
    render()
}
var shouldSeeTabs = false
function toggleSeeTabs() {
    shouldSeeTabs = !shouldSeeTabs
    render()    
}

var eqCount = 0
function eq(a, b, message) {
    eqCount++    
    if (a != b) {
        alert("unequal at number " + eqCount + ".\ngot: " + b + "\nwant: " + a + "\nmessage: " + message )
        window.close()
    }
}


setTimeout(function() {
    return
    // useUnicode = false
    eq(0, expandTabIndexNoCache("", 0))    
    eq(0, expandTabIndexNoCache("", -1))    
    eq(1, expandTabIndexNoCache("a", -1))    
    eq(1, expandTabIndexNoCache("a", 1))
    eq(4, expandTabIndexNoCache("abcd", -1))
    eq(8,   expandTabIndexNoCache("abcd	", -1))
    eq(8, expandTabIndexNoCache("abcd\t", -1))
    eq(4, expandTabIndexNoCache("abc\t", -1))
    eq(4, expandTabIndexNoCache("ab\t", -1))
    eq(8, expandTabIndexNoCache("ab\t" + "ab\t", -1))
    eq(12, expandTabIndexNoCache("ab\t" + "ab\t" + "ab\t", -1))
    eq(12, expandTabIndexNoCache("abc\t" + "a\t" + "ab\t", -1))
    eq(10, expandTabIndexNoCache("abc\t" + "a\t" + "ab", -1))
    eq(10, expandTabIndexNoCache("abca" + "\t" + "ab", -1))
    eq(10, expandTabIndexNoCache("abca"+"a\t" + "ab", -1))
    eq(4, expandTabIndexNoCache("\t", -1))
    
    eq(8, "👩‍❤️‍👩".length)
    eq(8, splitter.splitGraphemes("👩‍❤️‍👩")[0].length)
    eq(1, expandTabIndexNoCache("👩‍❤️‍👩", -1))    
    eq(1, expandTabIndexNoCache("👩‍❤️‍👩", 8))
    eq(4, expandTabIndexNoCache("👩‍❤️‍👩👩‍❤️‍👩👩‍❤️‍👩👩‍❤️‍👩", -1))
    eq(8,   expandTabIndexNoCache("❤️❤️❤️❤️	", -1))
    eq(8, expandTabIndexNoCache("👩‍❤️‍👩❤️👩‍❤️‍👩❤️\t", -1))
    eq(4, expandTabIndexNoCache("a👩‍❤️‍👩c\t", -1))
    eq(4, expandTabIndexNoCache("😎👩‍❤️‍👩\t", -1))
    eq(8, expandTabIndexNoCache("a❤️\t" + "👩‍❤️‍👩👩‍❤️‍👩\t", -1))
    eq(12, expandTabIndexNoCache("ab\t" + "ab\t" + "ab\t", -1))
    eq(12, expandTabIndexNoCache("abc\t" + "👩‍❤️‍👩\t" + "ab\t", -1))
    eq(10, expandTabIndexNoCache("abc\t" + "a\t" + "ab", -1))
    eq(10, expandTabIndexNoCache("abca" + "\t" + "👩‍❤️‍👩b", -1))
    eq(10, expandTabIndexNoCache("👩‍❤️‍👩👩‍❤️‍👩❤️❤️"+"a\t" + "ab", -1))
    eq(4, expandTabIndexNoCache("\t", -1))
    
    eq(0, unExpandTabIndexNoCache("", 0))
    eq(1, unExpandTabIndexNoCache("a", 1))
    eq(2, unExpandTabIndexNoCache("ab", 2))
    eq(0, unExpandTabIndexNoCache("\t", 0))
    eq(0, unExpandTabIndexNoCache("\t", 1))
    eq(0, unExpandTabIndexNoCache("\t", 2))
    eq(0, unExpandTabIndexNoCache("\t", 3))
    eq(1, unExpandTabIndexNoCache("\t", 4))
    eq(2, unExpandTabIndexNoCache("\t"+"a", 5))
    eq(3, unExpandTabIndexNoCache("a\t"+"a", 5))
    eq(4, unExpandTabIndexNoCache("ab\t"+"a", 5))
    eq(5, unExpandTabIndexNoCache("ab\t"+"a\t", 8))
    eq(4, unExpandTabIndexNoCache("ab\t"+"a\t", 7))
    eq(4, unExpandTabIndexNoCache("ab\t"+"a\t", 6))
    eq(4, unExpandTabIndexNoCache("ab\t"+"a\t", 5))
    eq(3, unExpandTabIndexNoCache("ab\t"+"a\t", 4))
    
    // abcda•••@
    eq(6, unExpandTabIndexNoCache("abcd"+"a\t", 8))
    
    // abcda••@_
    eq(5, unExpandTabIndexNoCache("abcd"+"a\t", 7))
    
    // abcda•@•_
    eq(5, unExpandTabIndexNoCache("abcd"+"a\t", 6))
    
    // abcda@••_
    eq(5, unExpandTabIndexNoCache("abcd"+"a\t", 5))
    
    // abcd@•••_
    eq(4, unExpandTabIndexNoCache("abcd"+"a\t", 4))
    
    // ❤️ has length of 2
    // 👩‍❤️‍👩 has length of 8
    // 🌈 has length of 2
    eq(8, unExpandTabIndexNoCache("👩‍❤️‍👩", 1))
    eq(16, unExpandTabIndexNoCache("👩‍❤️‍👩👩‍❤️‍👩", 2))
    eq(3, unExpandTabIndexNoCache("\t"+"❤️", 5))
    eq(17, unExpandTabIndexNoCache("👩‍❤️‍👩\t"+"👩‍❤️‍👩", 5))
    eq(7, unExpandTabIndexNoCache("❤️❤️\t"+"❤️", 5))
    eq(8, unExpandTabIndexNoCache("❤️❤️\t"+"❤️\t", 8))
    eq(7, unExpandTabIndexNoCache("❤️❤️\t"+"❤️\t", 7))
    eq(7, unExpandTabIndexNoCache("🌈🌈\t"+"🌈\t", 6))
    eq(7, unExpandTabIndexNoCache("🌈🌈\t"+"🌈\t", 5))
    eq(5, unExpandTabIndexNoCache("🌈🌈\t"+"🌈\t", 4))
    
    // abcda•••@
    eq(11, unExpandTabIndexNoCache("❤️❤️❤️❤️"+"❤️\t", 8))
    
    // abcda••@_
    eq(10, unExpandTabIndexNoCache("❤️❤️❤️❤️"+"❤️\t", 7))
    
    // abcda•@•_
    eq(10, unExpandTabIndexNoCache("❤️❤️❤️❤️"+"❤️\t", 6))
    
    // abcda@••_
    eq(10, unExpandTabIndexNoCache("❤️❤️❤️❤️"+"❤️\t", 5))
    
    // abcd@•••_
    eq(8, unExpandTabIndexNoCache("❤️❤️❤️❤️"+"❤️\t", 4))
    // eq(999, -999)
}, 1)

function unExpandTabIndexNoCache(theLine, start) {
    return unExpandTabIndex(theLine, start, null, null, "nocache")
}
// go from graphical index to string index, at graphical index
function unExpandTabIndex(theLine, start, index, file, nocache) {
    var tabStop = globalTabStop
    
    if (useUnicode) {
        var actualStringIndex = 0
        var expandedIndex = 0
        var newActualStringIndex = 0
        var newExpandedIndex = 0
        var expandedLine = getCachedGraphemes(theLine, index, file, nocache)
        var i = 0
        while (true) {
            if (i >= expandedLine.length) {
                break
            }
            if (i === 5000) {
                alert("loop err 1")
                break
            }
            // ab••••••y
            var grapheme = expandedLine[i]
            if (grapheme == "\t") {
                // newExpandedIndex = expandedIndex + (tabStop - ((expandedIndex) % tabStop)) + 1   
                newExpandedIndex = expandedIndex + (tabStop - ((expandedIndex) % tabStop))   
                newActualStringIndex = actualStringIndex + 1
            } else {
                newExpandedIndex = expandedIndex + 1
                newActualStringIndex = actualStringIndex + grapheme.length
            }
            if (newExpandedIndex > start) {
                return actualStringIndex    
            }
            expandedIndex = newExpandedIndex
            actualStringIndex = newActualStringIndex
            i++
        }
        
        return newActualStringIndex
    }
    
    var lastTabPos = -1
    var netSpacesAdded = 0
    var expandedLineLength = 0
    while (true) {
        tabPos = theLine.indexOf("\t", lastTabPos + 1)
        if (tabPos == -1) {
            expandedLineLength += theLine.length - (lastTabPos + 1)
            break
        }
        expandedLineLength += tabPos - (lastTabPos + 1)
        if (expandedLineLength > start) {
            break
        }
        var numberOfSpaces = tabStop - (expandedLineLength % tabStop)
        if ((expandedLineLength + numberOfSpaces) > start) {
            netSpacesAdded += (start - expandedLineLength)
            break
        }
        expandedLineLength += numberOfSpaces

        netSpacesAdded += numberOfSpaces - 1 // subtract 1 because of the actual tab
        lastTabPos = tabPos
    }
    var adjustedStart = start - netSpacesAdded
    return adjustedStart
}
function u(start) {
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    return unExpandTabIndex(theLine, start)
}

function expandTabIndexNoCache(theLine, start) {
    return expandTabIndex(theLine, start, null, null, "nocache")
}
// go from string index to graphical index, at string index
function expandTabIndex(theLine, start, index, file, nocache) {
    theLine = theLine || ""
    var origLine = theLine
    if (!theLine.substring) {
        log("bad line")
        log(theLine)
        var err = new Error()
        log(err.stack)
    }
    
    if (start == -1) {
        start = theLine.length
    } else {
        theLine = theLine.slice(0, start)
    }
    var tabStop = globalTabStop
    
    if (useUnicode) {
        var actualStringIndex = 0
        var expandedIndex = 0
        var newActualStringIndex = 0
        var newExpandedIndex = 0
        var expandedLine = getCachedGraphemes(origLine, index, file, nocache)
        var expandedLineLength = 0
        if (start == origLine.length) {
            expandedLineLength = expandedLine.length
        } else {
            if (start == 0) {
                expandedLineLength = 0   
            } else {
                var actualLength = 0
                for (var j=0; j<expandedLine.length;j++) {
                    expandedLineLength += 1
                    actualLength += expandedLine[j].length
                    if (actualLength == start) {
                        break
                    }
                }
            }
        }
        var i = 0
        while (true) {
            if (i >= expandedLineLength) {
                break
            }
            if (i === 5000) {
                alert("loop err 2")
                break
            }
            // ab••y
            var grapheme = expandedLine[i]
            if (grapheme == "\t") {
                newExpandedIndex = expandedIndex + (tabStop - ((expandedIndex) % tabStop))   
                newActualStringIndex = actualStringIndex + 1
            } else {
                newExpandedIndex = expandedIndex + 1
                newActualStringIndex = actualStringIndex + grapheme.length
            }
            expandedIndex = newExpandedIndex
            actualStringIndex = newActualStringIndex
            i++
        }
        return expandedIndex
    }
    
    
    
    var expandedLineLength = 0
    var lastTabPos = -1
    var netSpacesAdded = 0
    while (true) {
        tabPos = theLine.indexOf("\t", lastTabPos + 1)
        if (tabPos == -1) {
            expandedLineLength += theLine.length - (lastTabPos + 1)
            break
        }
        expandedLineLength += tabPos - (lastTabPos + 1)
        var numberOfSpaces = tabStop - (expandedLineLength % tabStop)
        expandedLineLength += numberOfSpaces

        netSpacesAdded += numberOfSpaces - 1 // subtract 1 because of the actual tab
        lastTabPos = tabPos
    }
    var adjustedStart = start + netSpacesAdded
    // log({start, adjustedStart, theLine})
    // var e = new Error()
    // log(e.stack)
    return adjustedStart
}
function handleFocusAfter() {
    if (searchText.value) {
        findDown()
    } else {
        if (fx.cursorLineIndex == fx.lines.Length - 1) return
        fx.cursorLineIndex += 1
    }
    setCanvasHeightAccordingly()
    ensureCursorInScreen()
    updateCursorXY()
    render()
    theText.focus()
    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
}

function handleFocusBefore() {
    // if you have something to search, make it search.
    log("here in before land")
    if (searchText.value) {
        findUp()
    } else {
        if (fx.cursorLineIndex == 0) return
        fx.cursorLineIndex -= 1
    }
    setCanvasHeightAccordingly()
    ensureCursorInScreen()
    updateCursorXY()
    render()
    theText.focus()
    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
}

function handleFocusIn() {
    setCanvasHeightAccordingly()
    ensureCursorInScreen()
    // lastAction = "type"
    acWord = null
    render()
    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
}

function handleBlur() {
    //topPadding.style.height = "100px"
    //window.scrollTo(0, 0)
    //setTimeout(() => {window.scrollTo(0,100)}, 100)
    if (dirtyInput) {
        saveUndo()
        dirtyInput = false
        // auto saving...
        // different that the timed autosave feature
        if (fx.fileMode == "file") {
            save()
        }
    }
    setCanvasHeightAccordingly()
    render()
    window.scrollTo(0, lastPageYOffset)
    renderTheText("")
    
    

}
function handleSearchFocusBefore() {
    theText.style.display = "none"
    searchText.style.display = "block"
    searchText.focus()
    setCanvasHeightAccordingly()
    findUp()
    searchText.setSelectionRange(searchText.value.length, searchText.value.length)
    log("searchUppy")
}
function handleSearchFocusAfter() {
    theText.style.display = "none"
    searchText.style.display = "block"
    searchText.focus()
    setCanvasHeightAccordingly()
    findDown()
    searchText.setSelectionRange(searchText.value.length, searchText.value.length)
    log("searchDowny")
}

// pressing the save button disables autosave
function saveWrapper() {
    if (fx.fileMode == "bash") {
        // the save button turns into run when it's a "bash" file
        if (fx.selectedRegions.length) {
            copy()
            runBashCommand(copyBuffer.join("\n"))
        } else {
            runBashCommand(fx.lines[fx.cursorLineIndex] || "")
        }
        return
    } else if (fx.fileMode == "terminal") {
        sendTerminal("\r")
        return
    }
    autoSave = false
    save()
}
function save() {
    // using a single for loop to
    // simulate a goto
    // breaks will make sure the 'cleanup' step gets called
    for (var s=0; s<1; s++) {
        if (fx.fileMode != "file") break
        if (fx.savedVersion == fx.version) {
            break
        }
        fx.savingVersion = fx.version
        var toSave = fx.lines.join("\n") 
        var toSaveHash = md5(toSave)
        var fetchPromise
        if (saveDiffs) {
            var theDiff = simpleDiffOld3(fx.undo.lastSavedLines, fx.lines, false).join("\n")
            log(theDiff)
            if (theDiff == "") {
                fx.savedVersion = fx.savingVersion
                fx.savingVersion = -1
                render()
                renderFileDropdown()
                renderSaves()
                return
            }
            fetchPromise = fetch(proxyPath + "/saveload?fullpath=" + encodeURIComponent(fx.fullPath), {
                method: "POST",
                cache: "no-cache",
                headers: { "Content-Type": "application/x-www-form-urlencoded"},
                body: "oldmd5="+fx.undo.lastSavedHash+"&newmd5="+toSaveHash+"&diff=" + encodeURIComponent(theDiff)
            })
        } else {
            fetchPromise = fetch(proxyPath + "/saveload?f=" + encodeURIComponent(fx.fullPath), {
                method: "POST",
                cache: "no-cache",
                headers: { "Content-Type": "application/x-www-form-urlencoded"},
                body: "content=" + encodeURIComponent(toSave)
            })
        }
        var myFx = fx
        fetchPromise.then(r => r.json())
        .then(v => {
            if (v.saved) {
                myFx.savedVersion = myFx.savingVersion
                myFx.savingVersion = -1
                myFx.undo.lastSavedLines = toSave.split("\n")
                myFx.undo.lastSavedHash = toSaveHash
            } else {
                alert("issue saving: " + v.error)
                saveDiffs = false
            }
            render()
            renderFileDropdown()
            renderSaves()
        })
        .catch(e => alert(e))
        render()
    }

    if (autoSave) {
        setTimeout(save, saveEveryMS)
    }

    renderFileDropdown()
    renderSaves()
}
if (autoSave) {
    setTimeout(save, saveEveryMS)
}

var ctrlDown = false
var keyMaping = {
    "Enter": "\r", // need to include \n too?
    "Shift": "", // we'd just send upercase letters
    "CapsLock": "",   
    "Backspace": "\b",
}
function handleKeydown(e) {
    // TODO: this is where you could wrap or unwrap quotes, etc
    if (fx.fileMode == "terminal") {
        var mapped = e.key
        if (ctrlDown) {
            // todo add more conditions
            var v = e.key.toUpperCase().charCodeAt(0)-64
            if (v < 0) {
                return
            }
            mapped = String.fromCharCode(v)
        } else {
            mapped = keyMaping[e.key]
            if (typeof mapped == "undefined") {
                mapped = e.key        
            }
        }
        
        if (mapped === "") {
            return
        }
        sendTerminal(mapped)
        log(e.key + "(" + mapped + ") (" + e.keyCode + ")" + "("+ JSON.stringify(mapped)+")")
        
        ctrlDown = false
        e.stopPropagation()
        e.preventDefault()
        return false
    }
    wasDelete = e.keyCode == 8
    // 8 means backspace
    if (e.keyCode == 8 && theText.selectionStart == 0 && fx.cursorLineIndex != 0) {
        e.preventDefault()
        var theLine = fx.lines[fx.cursorLineIndex]

        fx.lines.splice(fx.cursorLineIndex, 1)
        
        fx.cursorLineIndex -= 1
        var prevLine = fx.lines[fx.cursorLineIndex]
        // fx.lines[fx.cursorLineIndex] = fx.lines[fx.cursorLineIndex] + theLine
        updateLine(fx.cursorLineIndex, fx.lines[fx.cursorLineIndex] + theLine)
        // TODO: process the index here!!!
        fx.cursorColIndex = prevLine.length
        updateCursorXY()
        docChanged()
        render()
        //theText.setSelectionRange(prevLine.length, prevLine.length)
        setSelectionRangeForText(prevLine.length, prevLine.length)
        return true // could be false too?
    }
    
    if (document.activeElement == theText && fx.selectedRegions.length) {
        e.preventDefault()    
        var closer = closingMap[e.key]
        if (!closer) {
            return false
        }
        if (fx.selectedRegions[0].startY != fx.selectedRegions[0].stopY) {
            // for now only deal with singe line
            return false
        }
        var selectedRegion = JSON.parse(JSON.stringify(fx.selectedRegions[0]))
        // for now only deal with singe line
        var oldCopyBuffer = copyBuffer 
        
        del(false, true)
        var part = copyBuffer[0]
        if (!part) {
            return false
        }
        if (part.slice(0, 1) == e.key && part.slice(-1) == closer) {
            copyBuffer = [part.slice(1,-1)]    
            selectedRegion.stopX -= 2
        } else {
            copyBuffer = [e.key + part + closer]    
            selectedRegion.stopX += 2
        }
        paste()
        fx.selectedRegions = [selectedRegion]
        copyBuffer = oldCopyBuffer
        docChanged()
        render()
        return false
    }
    return true
}

var closingMap = {
    "[": "]",
    "(": ")",
    "{": "}",
    "<": ">",
    "'": "'",
    "`": "`",
    '"': '"',
}
var dirtyInput = false
function saveLine() {
    dirtyInput = true
    lastAction = "type"
    acWord = null
    // useUnicode you could fix this part up?
    var lastTyped = theText.value[theText.selectionStart - 1]
    var secondLastTyped = theText.value[theText.selectionStart - 2] || ""
    var nextChar = theText.value[theText.selectionStart] || ""
    // fx.cursorColIndex = theText.selectionStart
    var theLine = updateLine(-1, theText.value)
    // fx.cursorColIndex = expandTabIndex(theText.value, theText.selectionStart)
    fx.cursorColIndex = expandTabIndex(theLine, theText.selectionStart)
    
    
    // Note: handle newline portion too.

    // doing for to be able to break
    for (var s=0; s<1; s++) {
        if (
            !wasDelete &&
            lastTyped in closingMap
        ) {
            // first some common checks
            if (lastTyped == "'" && secondLastTyped != " " && secondLastTyped != "" && secondLastTyped != ",") {
                break
            }
            
            if (lastTyped == "<" && theText.value.substring(0, theText.selectionStart - 1).trim() != "") {
                break
            }
            var mainClosers = "({["
            var mainClosersEnd = ")}]"
            if (mainClosers.indexOf(lastTyped) != -1 && nextChar != "" && nextChar != " " && nextChar != "," && mainClosersEnd.indexOf(nextChar) == -1) {
                break
            }
            // renderTheText sets theText.value 
            // theText.value =
            renderTheText(
                theText.value.slice(0, theText.selectionStart) +
                closingMap[lastTyped] +
                theText.value.slice(theText.selectionStart)
            )
            updateLine(-1, theText.value)
            //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
            setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
        }
    }
    // we used to do equivalent updateLine once here but now potentially do it twice with the closers
    cursorX = (fx.cursorColIndex - fx.offsetX) * fontWidth
    cursorY = (fx.cursorLineIndex - fx.offsetY) * fontHeight
    docChanged(true)

    // you need to tell the render to not update the text area
    // weird bugs will happen without this
    inEdit = true
    ensureCursorInScreen()
    render()
    inEdit = false
}
function bind(v, min, max) {
    if (v < min) v = min
    if (v > max) v = max
    return v
}

function r(x) {
    return Math.round(x)
}
function rW(x) {
    return Math.round(x/fontWidth)
}
function rH(y) {
    return Math.round(y/fontHeight)
}
var fillStyleMap = {
    black: 0,
    white: 1,
    brown: 2,
    yellow: 3,
    orange: 4,
    blue: 5,
    // TODO: add updated highlight line here this one is old
    "rgba(0, 255, 255, 0.15)": 6,
    "rgba(0, 0, 0, 0.5)": 7,
    "rgba(255, 255, 255, 0.5)": 8,
}
function fillStyleIndex(f) {
  if (!(f in fillStyleMap)) {
      return f
  }
  return fillStyleMap[f]
} 
var mockCanvasContext = {
    commands: [],
    lastFillStyle: "black",
    fillStyle: "black",
    lastFont: "",
    font: "",
    lastTextBaseline: "",
    textBaseline: "",
    lastY: -9999,
    lastX: -9999,
    lastWasString: false,
    lastWasStringIndex: -1,
    fillRect: function(x, y, w, h) {
      if (this.fillStyle == "rgba(255, 0, 0, 0.5)") {
          // hack for not rendering red ghost cursor
          return
      }
      if (this.lastFillStyle != this.fillStyle) {
          this.lastFillStyle = this.fillStyle
          var fsi = fillStyleIndex(this.fillStyle)
          if (fsi <= 2) {
              this.commands.push(fsi + 7)    
          } else {
              this.commands.push([2, fsi])    
          }
      }
      this.commands.push([1, r(x), r(y), r(w), r(h)])    
    },
    fillText: function(str, x, y) {
      if (this.lastFillStyle != this.fillStyle)  {
          this.lastWasString = false    
          this.lastFillStyle = this.fillStyle
          var fsi = fillStyleIndex(this.fillStyle)
          if (fsi <= 2) {
              this.commands.push(fsi + 7)    
          } else {
              this.commands.push([2, fsi])    
          }
          // this.commands.push([2, (this.fillStyle)])    
      }
      if (this.lastFont != this.font) {
          this.lastWasString = false    
          this.lastFont = this.font
          this.commands.push([3, this.font])    
      }
      if (this.lastTextBaseline != this.textBaseline) {
          this.lastWasString = false    
          this.lastTextBaseline = this.textBaseline
          this.commands.push([4, this.textBaseline])    
      }
      if (rH(y) == this.lastY) {
          if (this.lastWasString) {
              if ((rW(x) - this.lastX) == 1) {
                // you really only care about isNumeric for the first one after?
                // so you could do one more optimization. 
                if (!isNumeric(str)) {
                    this.commands[this.lastWasStringIndex] += (str)
                } else {
                    this.commands[this.lastWasStringIndex] += (" " + str)
                }
              } else {
                this.commands[this.lastWasStringIndex] += (" " + str + rW(x))
              }
              this.lastX = rW(x)    
              return
          }
          this.commands.push(str + rW(x))
          this.lastWasString = true    
          this.lastWasStringIndex = this.commands.length - 1    
          // this.commands.push([str + r(x)])    
          // this.commands.push([str, r(x)])    
          // this.commands.push([0, str, r(x)])    
      } else {
          this.lastWasString = false    
          // this.commands.push([str+r(x), r(y)])
          this.commands.push([str, rW(x), rH(y)])
          // this.commands.push([0, str, r(x), r(y)])
          this.lastY = rH(y)    
      }
      this.lastX = rW(x)    
    },
}
// var serverViewFeature = true
var serverViewFeature = false
var sendingViewToServer = false
var shouldSendViewToServer = false
var lastViewBodyToSend = ""
// var ws = new WebSocket("wss://" + location.host + "/myws/wsrender")
function sendViewToServer() {
   // ideas for server render
   // 1. call render with a mocked canvas context and store all the commands to send to server
   //    the viewer will just long poll to get the latest view and render
   //    use some sort of compression, but each screen is basically the whole current frame
   //    pro: super simple to implement
   //    con: sending the whole screen every change is heavy.
   // 2. like option 1 but have 3 layers - 
   //      current line,
   //     everything but the current line,
   //     the cursor position
   // 3. a light version like #1, but don't worry about snapshotting
   //    the canvas commands, just render straight text of the screen
   //    and cursor position. it won't highlight the search word though.
   //    render it in an actual text area
   //    (hmm maybe you could make the search word blink client side)
   //    pro: super simple to implement
   // 4. save diffs any time document changes and keep a local state of the document
   //    on the screenshare client. See comments around undo.
   //    we could do a diff of the while document every change...
   //    but probably better would be the "setter functions" that make the diffs as you go
   //    (still because we are using an os level input box, we may have to diff the current line.)
   //    pro: likely much more fluid rendering
   //    con: much more complicated?
   //    con: having to not miss any messages on the client.
   //    con: how to handle when screenshare clients refresh page?
   //         would server have to keep track of document state?
   //         ah, maybe every few saves the server has to resnapshot the whole document? 
   //         then diffs would be from most recent server snapshot
   //         there's a lot I haven't thought through with this option.
   // 5. like option 3 but just send the diff of the simple rendered screen.
   //    the server will keep the last n number of full screens.
   //    when the client asks for the latest screen (including the version number they are seeing)
   //    the server will do a diff of what they have and what they need.
   //    if the version that the client has is too old, it gets the full text again.
   //    pro: still only dealing with current screen
   //    con: not as fluid as a more advanced solution
   // I am starting to like option 5
   // 6. thinking more about 4. 
   if (sendingViewToServer) {
       shouldSendViewToServer = true
       return
   }
   var viewBodyToSend = JSON.stringify(mockCanvasContext.commands)
   if (viewBodyToSend == lastViewBodyToSend) {
       // this optimization might not be as big as I thought
       return
   }
   
   totalViewBytesSent += viewBodyToSend.length
   totalViewRequests += 1 
   // try {
   //     ws.send(viewBodyToSend)
   // // you could wait to make sure you server got it before sending again.
   // } catch (e) {
   //      log(e) 
   // }
   // return

   lastViewBodyToSend = viewBodyToSend
   sendingViewToServer = true
   fetch(proxyPath + "/render", {
        cache: "no-cache",
        method: "POST",
        headers: {
          'Content-Type': 'application/json',
          'X-File': fx.fullPath, // I want to believe
          'X-Search': searchText.value,
          // 'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: viewBodyToSend,
   }).then(r => {
       sendingViewToServer = false
       if (shouldSendViewToServer) {
           shouldSendViewToServer = false
           sendViewToServer()
       }
   }).catch(e => {
       sendingViewToServer = false
       alert("error rendering to server: " + e)
       if (shouldSendViewToServer) {
           shouldSendViewToServer = false
           sendViewToServer()
       }
   })
      
}
var renderURLTimeout
var waitingRender = false
var lastRender = 0
// var maxFrameRate = 16
var maxFrameRate = 0
var waitingServerRender = false
var lastServerRender = 0
var maxServerFrameRate = 100
var lastRenderFx = null
var lastRenderOffsetX = -9999
var lastRenderOffsetY = -9999
var lastRenderCursorLineIndex = -9999

// TODO: potentially deprecate this
var lastRenderFullScreenForSet = false

function render() {
    if (preventRender) {
        return
    }
    
    // Now that file names contain line numbers
    // let's render the url nore frequently
    clearTimeout(renderURLTimeout)
    renderURLTimeout = setTimeout(function () {
        renderURL()
    }, 1000)
    
    var timeSinceRender = Date.now() - lastRender
    if (timeSinceRender < maxFrameRate) {
        if (!waitingRender) {
            waitingRender = true
            var localInEdit = inEdit
            setTimeout(function () {
                waitingRender = false
                // doing this inEdit dance was important at least for
                // starting to implement emojis
                // I think it prevents setting the selectionRange to an incorrect index
                // when the unExpandTabIndex didn't fully support emojis
                // resulting in typing 2 red hearts turning into a black heart and a red heart
                var oldInEdit = inEdit
                inEdit = localInEdit
                render()
                inEdit = oldInEdit
            }, maxFrameRate - timeSinceRender)
        }
        return
    }
    lastRender = Date.now()
    

    var start = Date.now()
    var shouldSetIt = false
    if (fx == lastRenderFx && lastRenderOffsetY == fx.offsetY && lastRenderOffsetX == fx.offsetX) {
        if (lastRenderFullScreenForSet) {
            minY = min(fx.cursorLineIndex, lastRenderCursorLineIndex) - fx.offsetY - 1   
            maxY = max(fx.cursorLineIndex, lastRenderCursorLineIndex) - fx.offsetY + 2    
            t.clearRect(0, minY * fontHeight, c.width, (maxY - minY) * fontHeight)
        } else {
            c.width = c.width // one way to clear
            shouldSetIt = true
        }
    } else {
        c.width = c.width // one way to clear
        lastRenderFullScreenForSet = false
    }
    renderInternal()
    if (shouldSetIt) {
        // lastRenderFullScreenForSet = true
    }
    // log("r1: " + (Date.now() - start))
    if (inDebugView) {
        s.innerHTML =
            lastWord + " " +
            fx.version + "/" + fx.savedVersion +
            "/" + fx.savingVersion +
            " p:" + cursorX + "," + cursorY +
            " c:" + fx.cursorColIndex + "," + fx.cursorLineIndex +
            " " + (r ? `s:${r.startX},${r.startY}:${r.stopX},${r.stopY}` : "s:--") +
            " " + selectMode
            // theStatus.fileTree = fileTree
        theStatus.shouldAutocompleteLine = shouldAutocompleteLine
        theStatus.lastWord = lastWord
        theStatus.lastCleared = lastCleared
        theStatus.totalViewRequests = totalViewRequests 
        theStatus.totalViewBytesSent = totalViewBytesSent 
        // theStatus.acWord = acWord
        statusEl.innerText = JSON.stringify(theStatus, null, "    ")
    }
    // this is commented out because of iphone 12 mini slowness
    // see renderSaves()
    // if (fx.fileMode == "file")   {
    //     if (fx.savingVersion != -1) {
    //         saveButton.style.backgroundColor = "gray"
    //         saveButton.innerText = "saving"
    //     } else if (fx.version == fx.savedVersion) {
    //         saveButton.style.backgroundColor = ""
    //         saveButton.innerText = "saved"
    //     } else {
    //         saveButton.style.backgroundColor = "red"
    //         saveButton.innerText = "save"
    //     }
    // } else if (fx.fileMode == "bash") {
    //     // TODO: consider not setting this every render
    //     saveButton.innerText = "run"
    // } else if (fx.fileMode == "terminal") {
    //     // TODO: consider not setting this every render
    //     saveButton.innerText = "run"
    // }
    // marker aquamarine setting text
    
    if (!inEdit) {
        // TODO: an idea is to not do this in the render step at all
        // but do it whenever we change cursorLineIndex or cursorColIndex
        // maybe use a setter for that to manage it better
        // this may be more efficient too.
        
        if (fx.selectedRegions.length) {
            // theText.value = (fx.selectedRegions[0].stopY - fx.selectedRegions[0].startY + 1) + " lines selected"    
            if (agressiveRender || (touchCount == 0)) {
                renderTheText((fx.selectedRegions[0].stopY - fx.selectedRegions[0].startY + 1) + " lines selected")
            }
        } else {
            // TODO: this if statement only needed on iphone 12 mini!!! ???
            // TODO: check other iphone 12s
            // theText.value = cursorLine
	    	if (agressiveRender || (touchCount == 0 && document.activeElement == theText)) {
                renderTheText(cursorLine)
            }
        }
        
        // I don't think we need to do this part
        // theTextBefore.value = fx.lines[fx.cursorLineIndex - 1] || ""
        // theTextAfter.value = fx.lines[fx.cursorLineIndex + 1] || ""
        
        
        // set the selection range back to what it was
        // if it needs to be changed, some functions will change it
        // after the call to render.
        // TODO: have a state variable for what it should be.
        // if this is not here then after tap to erase we loose cursor pos
        // we can maybe come up with a way around it
        // Note this also happens somewhere in onMove
        // TODO: does it need to happen in both places?
    	if (agressiveRender || (touchCount == 0 && document.activeElement == theText)) {
            if (document.activeElement == theText) {
                setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
            }
        }
        // log("expanded:" + expandTabIndex(cursorLine, cursorLine.length))
    }
    
    
    
    if (serverViewFeature) {
        // this render bock was recently moved into the serverViewFeature conditional
        var timeSinceServerRender = Date.now() - lastServerRender
        if (timeSinceServerRender < maxServerFrameRate) {
            if (!waitingServerRender) {
                waitingServerRender = true
                var localInEdit = inEdit
                setTimeout(function () {
                    waitingServerRender = false
                    // TODO: isolate this so it only async does the server part!
                    // it is going to possibly update things on the main text box
                    var oldInEdit = inEdit
                    inEdit = localInEdit
                    render()
                    inEdit = oldInEdit
                }, maxServerFrameRate - timeSinceServerRender)
            }
            return
        }
        lastServerRender = Date.now()
        
        // server rendering
        var oldOffsetX = fx.offsetX
        var oldMaxCols = maxCols
        var oldMaxLines = maxLines
        var oldT = t // canvas rendering context
        fx.offsetX = -5
        if (maxCols < 120) {
            maxCols = 120
        }
        if (maxLines < 32) {
            maxLines = 32
        }
        
        // 5 for the line number margin
        var section = Math.floor((fx.cursorColIndex + 5) / maxCols)
        fx.offsetX = (section * maxCols) - 5
        // log(section)
        
        t = mockCanvasContext
        mockCanvasContext.lastFillStyle = "black",
        mockCanvasContext.fillStyle = "black",
        mockCanvasContext.lastFont = "",
        mockCanvasContext.font = "",
        mockCanvasContext.lastTextBaseline = "",
        mockCanvasContext.textBaseline = "",
        mockCanvasContext.commands = [[5, fontWidth.toFixed(2)-0, fontHeight.toFixed(2)-0, maxCols, maxLines, isDark ? 1 : 0]]
        
        // var start = Date.now()
        renderInternal()
        // log("r2: " + (Date.now() - start))
        
        fx.offsetX = oldOffsetX
        maxCols = oldMaxCols
        maxLines = oldMaxLines
        t = oldT
        sendViewToServer()
    }
    
    lastRenderFx = fx
    lastRenderOffsetY = fx.offsetY
    lastRenderOffsetX = fx.offsetX
    lastRenderCursorLineIndex = fx.cursorLineIndex
}

// this is a workaround for iphone 12 mini issue where dom is slow
// and we can't blindly update it in the render loop
// TODO: you can make bash and terminal faster too. 
var renderedSaveRed = false
function renderSaves() {
    if (!fx) {
        return
    }
    if (fx.fileMode == "file")   {
        if (fx.savingVersion != -1) {
            saveButton.style.backgroundColor = "gray"
            saveButton.innerText = "saving"
            renpderedSaveRed = false
        } else if (fx.version == fx.savedVersion) {
            saveButton.style.backgroundColor = ""
            saveButton.innerText = "saved"
            renderedSaveRed = false
        } else if (!renderedSaveRed) {
            saveButton.style.backgroundColor = "red"
            saveButton.innerText = "save"
            renderedSaveRed = true
        }
    } else if (fx.fileMode == "bash") {
        // TODO: consider not setting this every render
        saveButton.innerText = "run"
    } else if (fx.fileMode == "terminal") {
        // TODO: consider not setting this every render
        saveButton.innerText = "run"
    }
}

var theTextValue = ""
function renderTheText(v) {
    // TODO: why when i uncomment the if
    // and i type and hit enter it duplicates the line?
    // if (v != theTextValue) {
        theText.value = v
        theTextValue = v
    // }
}
 
var splitter = new GraphemeSplitter()

var renderDuration = 0
var renderCount = 0   
var rendersInLastSecond = 0
function renderInternal() {
    var startRenderTime = Date.now()
    // the selected areas
    for (var i=0; i<fx.selectedRegions.length;i++) {
        // todo: normalize region start and stop
        // todo: draw the cursors after the selected regions
        var r = fx.selectedRegions[i]
        t.fillStyle = "magenta"
        for (var y=r.startY-fx.offsetY; y<=r.stopY-fx.offsetY; y++) {
            var line = fx.lines[y + fx.offsetY] || ""
            if (r.startY == r.stopY) {
                t.fillRect((r.startX-fx.offsetX)*fontWidth, y*fontHeight, (r.stopX-r.startX)*fontWidth, fontHeight)
            } else if (y==r.startY-fx.offsetY) {
                t.fillRect((r.startX-fx.offsetX)*fontWidth, y*fontHeight, (expandTabIndex(line, line.length, y + fx.offsetY)-r.startX)*fontWidth, fontHeight)
            } else if (y==r.stopY-fx.offsetY) {
                t.fillRect((0-fx.offsetX)*fontWidth, y*fontHeight, r.stopX*fontWidth, fontHeight)
            } else {
                t.fillRect((0-fx.offsetX)*fontWidth  , y*fontHeight, expandTabIndex(line, line.length, y + fx.offsetY)*fontWidth, fontHeight)
            }
        }
    }
    
    // draw line where your cursor is for help with finding
    var highlightLine = true
    if (highlightLine) {
        // t.fillStyle = "rgba(0, 255, 255, 0.15)"
        // more apparent highlight line
        if (isDark) {
            t.fillStyle = "rgba(0, 128, 128, 0.55)"
        } else {
            t.fillStyle = "rgba(0, 255, 255, 0.55)"
        }
        // go twice as wide as you need, for server rendering purposes
        t.fillRect(0, (fx.cursorLineIndex - fx.offsetY) * fontHeight, c.width*2, fontHeight)
    }

    // render autocomplete word
    if (acWord) {
        t.fillStyle = "orange"
        // marker aquamarine
        for (var y=acWord.startY-fx.offsetY; y<=acWord.stopY-fx.offsetY; y++) {
            var line = fx.lines[y + fx.offsetY] || ""
            if (acWord.startY == acWord.stopY) {
                t.fillRect((acWord.startX-fx.offsetX)*fontWidth, y*fontHeight, (acWord.stopX-acWord.startX)*fontWidth, fontHeight)
            } else if (y==acWord.startY-fx.offsetY) {
                t.fillRect((acWord.startX-fx.offsetX)*fontWidth, y*fontHeight, (expandTabIndex(line, line.length, y + fx.offsetY)-acWord.startX)*fontWidth, fontHeight)
            } else if (y==acWord.stopY-fx.offsetY) {
                t.fillRect((0-fx.offsetX)*fontWidth, y*fontHeight, acWord.stopX*fontWidth, fontHeight)
            } else {
                t.fillRect((0-fx.offsetX)*fontWidth  , y*fontHeight, expandTabIndex(line, line.length, y + fx.offsetY)*fontWidth, fontHeight)
            }
        }
    }
    
    t.font = fontCSS
    t.textBaseline = "top"
    var r = fx.selectedRegions[0]
    // TODO: this element is hitten
    // consider removing it.


    // row highlight, what is this? remove it
    // t.fillStyle = "rgba(0, 128, 128, 0.5)"
    // t.fillRect(0, yPos, canvasWidth, fontHeight)
    // t.fillStyle = cursorType == "move" ? "cyan" : "yellow"

    // Note, we tried doing an extra loop for line numbers first so we change colors less
    //but didn't seem like it improved things
    var minY = 0 
    var maxY = maxLines 
    if (lastRenderFullScreenForSet && fx == lastRenderFx && lastRenderOffsetY == fx.offsetY && lastRenderOffsetX == fx.offsetX) {
        minY = min(fx.cursorLineIndex, lastRenderCursorLineIndex) - fx.offsetY - 1   
        maxY = max(fx.cursorLineIndex, lastRenderCursorLineIndex) - fx.offsetY + 2    
    }
    for (var y=minY; y < maxY; y++) {
        // show the end of the document
        // if (y + fx.offsetY >= fx.lines.length) {
        //   t.fillStyle = "#222"
        //   t.fillRect(0, y*fontHeight, canvasWidth, fontHeight)
        // }

        // highlight search
        var theLine = fx.lines[y + fx.offsetY] || ""
        var highlightStartSearch = 0
        var matchLength = 0
        if (theLine && searchText.value.length) {
            // max 20 highlights per line
            for (var _i=0; _i<20; _i++) {
                if (fx.fileMode == "directory") {
                    var pos = theLine.toLowerCase().indexOf(searchText.value.toLowerCase(), highlightStartSearch)
                    if (pos == -1) {
                        break
                    }
                    matchLength = searchText.value.length
                    highlightStartSearch = pos + matchLength
                } else {
                    if (useRegexSearch) {
                        var theMatch = theLine.substr(highlightStartSearch).match(cachedSearchRegexp(searchText.value))
                        if (theMatch == null) {
                            break    
                        }
                        matchLength = theMatch[0].length
                        pos = highlightStartSearch + theMatch.index  
                        highlightStartSearch = pos + matchLength 
                    } else {
                        var pos = theLine.indexOf(searchText.value, highlightStartSearch)
                        if (pos == -1) {
                            break
                        }
                        matchLength = searchText.value.length
                        highlightStartSearch = pos + matchLength
                    }
                }
                // lime
                if (isDark) {
                    t.fillStyle = "blue"
                } else {
                    t.fillStyle = "yellow"
                }
                
                // TODO: expanding the same line, we could come up with optimization for that
                var startHighlightPos = expandTabIndex(theLine, pos, y + fx.offsetY)
                var startFillHighlight = (startHighlightPos - fx.offsetX) * fontWidth
                var highlightLength = (expandTabIndex(theLine, pos+matchLength, y + fx.offsetY)-startHighlightPos) * fontWidth
                t.fillRect(
                    startFillHighlight,
                    y * fontHeight,
                    highlightLength,
                    fontHeight
                )
            }
        }

        if (true) {
            if (y + fx.offsetY < fx.lines.length) {
                var lineNumber = (y+fx.offsetY+1).toString().padStart(4, " ")
                if (fx.offsetX < -1) {
                    // Line numbers
                    
                    if (fx.lines[y + fx.offsetY] != "" && fx.lines[y + fx.offsetY - 1] == fx.lines[y + fx.offsetY]) {
                        // handy feature to see if lines are same
                        t.fillStyle = "lime"
                    } else {
                        t.fillStyle = "brown"
                    } 
                    for (var i=0; i<-fx.offsetX-1; i++) {
                        var lineNumberIndex = fx.offsetX + marginLeft + i
                        var lineNoChr = lineNumber.charAt(lineNumberIndex)
                        if (lineNoChr != " ") {
                            t.fillText(lineNoChr, i*fontWidth, y*fontHeight)
                        }
                    }
                }
            }
        }
        // TODO: set variable for line.trim()
        var textFillStyle 
        // the actual text
        
        // TODO: maybe pull some of this out of the loop
        let cachedTrim
        var trim = function() {
            if (typeof cachedTrim != "undefined") {
                return cachedTrim
            }
            cachedTrim = theLine.trim()
            return cachedTrim    
        }
        if (fx.fileMode != "terminal") {
            if (theLine.startsWith("+")) {
                textFillStyle = isDark ? "lime" : "green"
            } else if (theLine.startsWith("-")){
                textFillStyle = "red"
            } else if (trim().startsWith("// mar"+"ker ") || trim().startsWith("# mar"+"ker ")) {
                // do a fill rect of the color that comes after
                // Not using save and restore because my mock canvas doesn't support it
                var oldFillStyle = t.fillStyle
                // var theFillStyle = trimPrefix(theLine.trim(), "// mar"+"ker ").split(" ")[0]
                var theFillStyle = trimPrefix(trimPrefix(trim(), "// mar"+"ker "), "# mar"+"ker ").split(" ")[0]
                t.fillStyle = theFillStyle
                // go twice as wide as you need, for server rendering purposes
                t.fillRect(0, y * fontHeight, c.width*2, fontHeight)
                textFillStyle = fontColor
                if (knownContrastingColors[t.fillStyle]) {
                    textFillStyle = knownContrastingColors[t.fillStyle]
                } else {
                    colorGetterEl.style.backgroundColor = t.fillStyle
                    // I think the t.fillStyle gets normalized as #RRGGBB, so you could have used that.
                    var rgbColor = window.getComputedStyle(colorGetterEl).backgroundColor
                    var grayed = ll(rgbColor, "n n n", function(r, g, b) {
                        // googled this
                        return (0.3 * r) + (.59 * g) + (.11 * b)
                    })
                    // log("looking up color " + theFillStyle + " "+ grayed)
                    if (grayed < 128) {
                        textFillStyle = "white"    
                    } else {
                        textFillStyle = "black"    
                    }
                    knownContrastingColors[t.fillStyle] = textFillStyle
                }
                t.fillStyle = oldFillStyle
                
            } else if (trim().startsWith("//") || trim().startsWith("#")) {
                // comments are gray
                textFillStyle = lightFontColor
            } else {
                // feature to gray out lines before where you are scrolled to
                // var spaceCount = getSpaceCount(theLine)
                // if (spaceCount < fx.offsetX && (y + fx.offsetY) != fx.cursorLineIndex) {
                //     t.fillStyle = lightFontColor
                // } else {
                //     t.fillStyle = fontColor
                // }
                textFillStyle = fontColor
            }
        } else {
            textFillStyle = fontColor
        }


        theLine = theLine || ""
        var expandedLine = ""
        var tabStop = globalTabStop
        var afterLastTabPos = 0
        
        // expandedLine = [...expandedLine]
        if (useUnicode) {
            // you could render inline here
            
            if (theLine.tabCache) {
                expandedLine = theLine.tabCache    
            } else if (theLine == "") {
                expandedLine = []
            } else {
                expandedLine = getCachedGraphemes(theLine, y + fx.offsetY)
                expandedLine = expandedLine.slice() // copy it
                var i = 0
                
                // TODO: you can potentially also cache this part
                while (true) {
                    i++
                    if (i === 500) {
                        alert("loop err 3")
                        break
                    }
                    var tabPos = expandedLine.indexOf("\t", afterLastTabPos)
                    if (tabPos == -1) {
                        break
                    }
                    var numberOfSpaces = tabStop - ((tabPos) % tabStop) -1
                    // log("tab at position: " + tabPos + ", num: " + numberOfSpaces)
                    // TODO: you can used cached repeated \t array
                    
                    expandedLine.splice(tabPos, 0, ...("\t".repeat(numberOfSpaces).split("")))
                    afterLastTabPos = tabPos + numberOfSpaces + 1
                }
                if ((y + fx.offsetY) < fx.lines.length) {
                    fx.lines[y + fx.offsetY].tabCache = expandedLine
                    // log("saving tab cache " + (theLine instanceof String) + " " + theLine)
                }
                
            }
        } else {
            // TODO: you can potentially also cache this part
            while (true) {
                tabPos = theLine.indexOf("\t", afterLastTabPos)
                if (tabPos == -1) {
                    expandedLine += theLine.substr(afterLastTabPos, theLine.length)
                    break
                }
                expandedLine += theLine.substring(afterLastTabPos, tabPos)
                // now add the correct number of spaces, taking into account the tabStop
                var numberOfSpaces = tabStop - (expandedLine.length % tabStop)
                expandedLine += "\t".repeat(numberOfSpaces)
                afterLastTabPos = tabPos + 1
            }
        }
        
        // one option is to draw the whole line in one go
        // likely more optimal, wouln't have to do the unicode stuff
        // but harder to know wrangle width of the font?
        var extraY = 0
        for (var x=0; x < maxCols; x++) {
            if ((x+fx.offsetX) >= expandedLine.length) {
                break    
            }
            var chr = expandedLine[x+fx.offsetX] || ""
            if (chr == "\t") {
                if (shouldSeeTabs) {
                    t.fillStyle = veryLightFontColor
                    t.fillText("•", x*fontWidth, y*fontHeight)
                }
            } else if (chr != "" && chr != " ") {
                t.fillStyle = textFillStyle
                
                if (useUnicode) {
                    if (chr.length > 1) {
                        t.font = fontCSSEmoji
                        extraY = extraYEmoji
                    } else {
                        t.font = fontCSS
                        extraY = 0
                    }
                    t.fillText(chr, x*fontWidth, y*fontHeight + extraY)
                } else {
                    t.fillText(chr, x*fontWidth, y*fontHeight)
                }
            }
            if (useUnicode) {
                // revert back
                t.font = fontCSS
            }
        }
    }

    // red ghost cursor
    t.fillStyle = "rgba(255, 0, 0, 0.5)"
    t.fillRect(cursorX, cursorY, 4, fontHeight)

    // cursor
    if (touchCount == 0) {
        t.fillStyle = "orange"
    } else {
        t.fillStyle = "pink"
    }
    var yPos = (fx.cursorLineIndex - fx.offsetY) * fontHeight
    var xPos = (fx.cursorColIndex - fx.offsetX) * fontWidth
    t.fillRect(xPos, yPos, 4, fontHeight)
    cursorLine = fx.lines[fx.cursorLineIndex] || ""
    
    var duration = Date.now() - startRenderTime
    // TODO: audit render for performance
    // also, we are calling it too much, cut down on number of times we call it
    
    renderCount += 1
    renderDuration += duration
    rendersInLastSecond += 1
    if (renderCount == 50) {
        log("render avg: " + Math.round(renderDuration/renderCount))
        renderCount = 0
        renderDuration = 0
    }
}

false && setInterval(function() {
    if (rendersInLastSecond > 0) {
        log("rendersInLastSecond: " + rendersInLastSecond)
    }
    rendersInLastSecond = 0
}, 1000)

// simple cache for regexp so we don't need to recompile in render loop
// also so I don't have to keep track of whenever searchText.value is set (although maybe consider doing it that way in another pass) 
var lastSearchRegexpText = ""
var lastSearchRegexp = null
function cachedSearchRegexp(str) {
    if (str == lastSearchRegexpText) {
        return lastSearchRegexp
    }
    lastSearchRegexpText = str
    try {
        lastSearchRegexp = new RegExp(lastSearchRegexpText)   
    } catch (e) {
        lastSearchRegexpText = ""
        lastSearchRegexp = null 
    }
    return lastSearchRegexp
}

// just like cachedSearchRegexp but a global regexp for searching backwards
var lastSearchRegexpGlobalText = ""
var lastSearchRegexpGlobal = null
function cachedSearchRegexpGlobal(str) {
    if (str == lastSearchRegexpGlobalText) {
        return lastSearchRegexpGlobal
    }
    lastSearchRegexpGlobalText = str
    try {
        lastSearchRegexpGlobal = new RegExp(lastSearchRegexpGlobalText, 'g')   
    } catch (e) {
        lastSearchRegexpGlobalText = ""
        lastSearchRegexpGlobal = null 
    }
    return lastSearchRegexpGlobal
}

function ensureSign(sign, v) {
    if (sign < 0 && v > 0) return -v
    if (sign > 0 && v < 0) return -v
    return v
}

// todo: use min, max in some places where you used bind
function min(a, b) {
    return a < b ? a : b
}

function max(a, b) {
    return a > b ? a : b
}

function moveHomeEndAction() {
    log("moveHomeEndAction")
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    switch (moveHomeEndDirection) {
       case "up":
           // TODO: jump to markers once you add that feature?
           // make an implicit marker of where you last were?
           var oldSearchText = searchText.value
           // searchText.value = "// mar"+"ker "
           searchText.value = " mar"+"ker "
           var found = findUp()
           searchText.value = oldSearchText
           if (!found) {
               fx.cursorLineIndex = 0
           }
           break;
       case "down":
           // TODO: jump to markers
           var oldSearchText = searchText.value
           // searchText.value = "// mar"+"ker "
           searchText.value = " mar"+"ker "
           var found = findDown()
           searchText.value = oldSearchText
           if (!found) {
               fx.cursorLineIndex = fx.lines.length - 1
           }
           break;
       case "left":
           var theIndent = getIndent(theLine)
           fx.cursorColIndex = expandTabIndex(theLine, theIndent.length)
           break;
       case "right":
           fx.cursorColIndex = expandTabIndex(theLine, theLine.length)
           break;
   }
   if (document.activeElement == theText) {
       //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
       setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
   }
   ensureCursorInScreen()
   render()
}

var touchCount = 0
function onStart(e) {
    touchCount = e.touches.length
    e.preventDefault()
    // this handles all the touch interactions
    // first define the closuure functions

    // this is global
    if (e.touches.length == 1) {
        selectAction = function() {
            // return early in case we are already selecting
            if (cursorType == "select") {
                return
            }
            fx.selectedRegions = []
            cursorType = "select"
            var line = fx.lines[fx.cursorLineIndex] || ""
            selectedRegion.startX = bind(fx.cursorColIndex, 0, expandTabIndex(line, line.length))
            selectedRegion.startY = bind(fx.cursorLineIndex, 0, fx.lines.length-1)
            // Note how the stopY is inclusive
            // But the stopX is exclusive.
            // for some reason seemed natural to do it like that
            // was here
            selectedRegion.stopX = bind(fx.cursorColIndex, 0, expandTabIndex(line, line.length))
            selectedRegion.stopY = bind(fx.cursorLineIndex, 0, fx.lines.length - 1)
            if (fx.cursorColIndex < 0) {
                selectedRegion.stopped = true
                selectMode = "line"
                selectedRegion.stopX = expandTabIndex(line, line.length)
            } else {
                selectMode = "char"
            }
            fx.selectedRegions.push(selectedRegion)
            render()
        }
    }
    var onMove = function(e) {
        lastAction = "move"
        lastSearchDirForSameTerm = ""
        shouldAutocompleteLine = false
        hasMovedSinceNewLine = true
        hasMovedSinceCut = true
        acWord = null
        clearTimeout(selectTimeout)
        if (e.touches.length > 1) {
            return
        }
        if (cursorType != "select") {
            selectTimeout = setTimeout(selectAction, selectTimeoutMillis)
        }
        var diffTouchX = e.touches[0].pageX - startTouchX
        var diffTouchY = e.touches[0].pageY - startTouchY
        //cursorX = bind(startX + diffTouchX*touchScale, 0, canvasWidth)
        //cursorY = bind(startY + diffTouchY*touchScale, 0, canvasHeight)

        moved = true
        if (diffTouchX > 10 || diffTouchY > 10) {
            movedWithBuffer = true
        }
        var diffLastTouchX = e.touches[0].pageX - lastTouchX
        var diffLastTouchY = e.touches[0].pageY - lastTouchY
        var signX = diffLastTouchX < 0 ? -1: 1
        var signY = diffLastTouchY < 0 ? -1 : 1
        thePow = firstMove ? 1 : 2
        if (!lockX) {
            cursorX = cursorX + ensureSign(signX, Math.round(Math.pow(diffLastTouchX, thePow)*touchScaleX))
        }
        cursorY = cursorY + ensureSign(signY, Math.round(Math.pow(diffLastTouchY, thePow)*touchScaleY))
        lastTouchX = e.touches[0].pageX
        lastTouchY = e.touches[0].pageY

        var changedY = false
        //var maxHeight = canvasHeight
        var maxHeight = (maxLines -1 ) * fontHeight
        if (cursorY > maxHeight) {
            var extendY = cursorY - maxHeight
            cursorY = maxHeight
            fx.offsetY += Math.ceil(extendY/fontHeight)
            if (fx.offsetY > fx.lines.length - 10) fx.offsetY = fx.lines.length - 10
            changedY = true
        } else if (cursorY < 0) {
            var extendY = cursorY
            cursorY = 0
            fx.offsetY += Math.floor(extendY/fontHeight)
            changedY = true
            if (fx.offsetY < 0) fx.offsetY = 0
        }

        var maxWidth = (maxCols -1) * fontWidth
        //var maxWidth = canvasWidth
        if (cursorX > maxWidth) {
            var extendX = cursorX - maxWidth
            cursorX = maxWidth
            // if (!changedY) fx.offsetX += Math.round(extendX/fontWidth)
            if (!changedY) fx.offsetX += Math.ceil(extendX/fontWidth)
        } else if (cursorX < 0) {
            var extendX = cursorX
            cursorX = 0
            // if (!changedY) fx.offsetX += Math.round(extendX/fontWidth)
            if (!changedY) fx.offsetX += Math.floor(extendX/fontWidth)
            if (fx.offsetX < -marginLeft) fx.offsetX = -marginLeft
        }
        var oldCursorLineIndex = fx.cursorLineIndex
        // maybe have a setter for this?
        fx.cursorLineIndex = Math.round(cursorY/fontHeight) + fx.offsetY
        if (oldCursorLineIndex != fx.cursorLineIndex && dirtyInput) {
            log("saving undo")
            saveUndo()
            dirtyInput = false
        }
        
        // TODO: this so we can get into full line autocomplete mode
        // by scrolling into an empty line and starting to type
        // wondering if this is optimal enough.
        var _line = fx.lines[fx.cursorLineIndex] || ""
        if (_line.trim() == "") {
            hasMovedSinceNewLine = false
        }   
        fx.cursorColIndex = Math.round(cursorX/fontWidth) + fx.offsetX
        firstMove = false
        if (cursorType == "select") {
            var line = fx.lines[fx.cursorLineIndex] || ""
            selectedRegion.stopX = bind(fx.cursorColIndex, 0, expandTabIndex(line, line.length))
            selectedRegion.stopY = bind(fx.cursorLineIndex, 0, fx.lines.length-1)
            selectedRegion.stopped = true
            if (fx.cursorColIndex < 0) {
                var _line = fx.lines[fx.cursorLineIndex] || ""
                selectedRegion.stopX = expandTabIndex(_line, _line.length)
            }

        }
        render()
        // See comment in render asking if we need to do this here too
        // this optimization was for Nokia 1.4, 
    	if (agressiveRender || (touchCount == 0 && document.activeElement == theText)) {
            if (document.activeElement == theText) {
                setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
            }
        }
        return false
    }
    var onEnd = function(e) {
        touchCount = e.touches.length
        clearTimeout(selectTimeout)
        if (e.touches.length != 0) {
            return
        }
        document.body.removeEventListener("touchmove", onMove)
        moveListenerCount = max(moveListenerCount-1, 0)
        document.body.removeEventListener("touchend", onEnd)
        endListenerCount = max(endListenerCount-1, 0)

        // it's not straightforward to do a setTimeout
        // here because iOS Safari doesn't like to focus
        // text elements when not responding to user action
        // maybe there are workarounds.
        if (!moved && cursorType == "move") {
            if (fx.fileMode == "directory") {
                // #filestuff
                clickItemInDirectory()
                return
            }

            if (fx.fileMode == "fileList") {
                var file = treeFilesShadow[fx.cursorLineIndex]
                if (file.fileToken == fileToken) {
                    // #filestuff
                    setCurrentFile(file)
                    return
                }
                // here load file that hasn't been loaded
                // in this case "file" var is just a string
                // #filestuff
                // TODO: you could see if there is already one "directory" file here!
                // also TODO: you could not overwrite the lastFile when showing the files view.
                fx = lastFile || files[0]
                addFile(file)
                return
            }
            

            if (fx.cursorColIndex == -5) {
                // since we are in the margin, let's force it
                // to paste line-style.
                if (fx.fileMode == "terminal") {
                    sendTerminal(copyBuffer.join("\r"))
                    return   
                }
                selectMode = "line"
                paste()
                return
            }
            if (fx.fileMode == "terminal") {
                // #todoterminal send a tab?
                if (document.activeElement == theText) {
                    sendTerminal("\t")
                } else {
                    theText.focus()
                }
                return
            }
            // if (fx.cursorColIndex >= -4 && fx.cursorColIndex <= -1) {
            //     var oldCopyBuffer = copyBuffer
            //     copyBuffer = cutBuffer
            //     paste()
            //     copyBuffer = oldCopyBuffer
            //     return
            // }
            if (fx.cursorColIndex == -4) {
                del()
                return
            }
            if (fx.cursorColIndex == -3) {
                copy()
                paste()
                fx.selectedRegions = []
                return
            }
            if (fx.cursorColIndex == -2) {
                copy()
                return
            }
            if (fx.cursorColIndex == -1) {
                insertLine(true, true)
                return
            }

            if (document.activeElement == theText) {
                // #alternateTap
                var w = getWordBeforeCursor()
                if (lastAction == "move" || w.word == "") {
                    var w = getWordAtCursor()
                    if (w.word == "" || w.start == fx.cursorColIndex) {
                        selectMode = "char"
                        paste(false)
                    } else if (w.word != "") {
                        var sr = {}
                        sr.startY = fx.cursorLineIndex
                        sr.startX = w.start
                        sr.stopY = fx.cursorLineIndex
                        sr.stopX = w.end
                        fx.selectedRegions = [sr]
                        render()
                    }
                } else {
                    acWordToggle()
                }
            }

            if (document.activeElement != theText) {
                if (fx.cursorLineIndex >= fx.lines.length) {
                    fx.cursorLineIndex = fx.lines.length - 1
                    updateCursorXY()
                    render()
                }
                
                // This part for moving the cursor where you tapped (if you want that feature) 
                // if (false) {
                if (false) {
                    var bbox = c.getBoundingClientRect()
                    var pointX = startTouchX - bbox.left
                    var pointY = startTouchY - bbox.top
                    log([pointX, pointY])
                    fx.cursorColIndex = Math.round(
                        ((pointX * 3)/fontWidth) + fx.offsetX
                    )  
                    fx.cursorLineIndex = Math.round(
                        ((pointY * 3)/fontHeight) + fx.offsetY
                    )
                    log([startTouchX, startTouchY, fx.cursorColIndex, fx.cursorLineIndex])
                    updateCursorXY()  
                }
                
                if (true) {
                    // the handleFocusIn function will do some
                    // processing
                    theText.focus()
                }
            }
        }

        cursorType = "move"
        // #alternateTap
        if (false && !selectedRegion.stopped) {// this only matters if it is selected I think
            // TODO: what is this feature?
            // for selecting a word?
            // selectWord Fearure
            // this happens when you hold down for a while and then let go
            // we should deprecate this?
            var w = getWordAtCursor()
            if (w.word != "") {
                selectedRegion.startY = fx.cursorLineIndex
                selectedRegion.startX = w.start
                selectedRegion.stopY = fx.cursorLineIndex
                selectedRegion.stopX = w.end
            } else {
                fx.selectedRegions = []
            }
        }
        render()
    }

    var onMoveWhileSelected = function(e) {
        moved = true
        var diffStartTouchX = e.touches[0].pageX - startTouchX
        var diffStartTouchY = e.touches[0].pageY - startTouchY
        lastTouchX = e.touches[0].pageX
        lastTouchY = e.touches[0].pageY
        if (Math.abs(diffStartTouchX) < 5 && Math.abs(diffStartTouchY) < 5) {
            return
        }
        if (Math.abs(diffStartTouchX) > Math.abs(diffStartTouchY)) {
            if (diffStartTouchX < 0) {
                dedent()
            } else {
                indent()
            }
        } else {
            if (diffStartTouchY < 0) {
                del()
            } else {
                copy()
            }
        }
        // stop handling it once it's handled
        document.body.removeEventListener("touchmove", onMoveWhileSelected)
        moveListenerCount = max(moveListenerCount-1, 0)
    }
    var onEndWhileSelected = function(e) {
        touchCount = e.touches.length
        if (!moved && fx.selectedRegions.length) {
            fx.selectedRegions = []
        }
        document.body.removeEventListener("touchmove", onMoveWhileSelected)
        moveListenerCount = max(moveListenerCount-1, 0)
        document.body.removeEventListener("touchend", onEndWhileSelected)
        endListenerCount = max(endListenerCount-1, 0)
        render()
    }
    
    var onEndForEdges = function(e) {
        touchCount = e.touches.length
        document.body.removeEventListener("touchend", onEndForEdges)
        clearTimeout(moveHomeEndTimeout)
        render()
    }

    var startTouchX = e.touches[0].pageX
    var startTouchY = e.touches[0].pageY
    var startX = cursorX
    var startY = cursorY
    var lastTouchX = startTouchX
    var lastTouchY = startTouchY
    var lastTime = Date.now()
    var firstMove = true
    var moved = false
    var movedLong = false
    var prevCopyBufferForTouch = null
    var movedWithBuffer = false
    var selectedRegion = {}

    // scroll right and left and move cursor right and left or up and down
    // TODO: remove some duplication here. especially the bounds checks. Make a setter functions.
    if (startTouchX > ((canvasWidth/3) - 40)) {
        var bbox = c.getBoundingClientRect()
        if (startTouchY - bbox.top < (bbox.height/2)) {
            moveHomeEndDirection = "down"
            moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
            fx.cursorLineIndex += 1
            if (fx.cursorLineIndex >= fx.lines.length) {
                fx.cursorLineIndex = fx.lines.length - 1
            }
            ensureCursorInScreen()
            if (fx.selectedRegions.length) {
                fx.selectedRegions[0].stopY += 1
                if (fx.selectedRegions[0].stopY > fx.lines.length - 1) { // stopY is inclusive I think, stopX isn't
                    fx.selectedRegions[0].stopY = fx.lines.length - 1
                }    
                var theLine = fx.lines[fx.selectedRegions[0].stopY] || ""
                fx.selectedRegions[0].stopX = expandTabIndex(theLine, theLine.length, fx.selectedRegions[0].stopY)
            } else if (document.activeElement != theText) {
                fx.offsetY += 1
                if (fx.offsetY > fx.lines.length - 10) {
                    fx.offsetY = lines.length - 10
                }
            }
        } else if (fx.selectedRegions.length) {
            fx.selectedRegions[0].stopX += 1
            var theLine = fx.lines[fx.selectedRegions[0].stopY] || ""
            var expandedIndex = expandTabIndex(theLine, theLine.length, fx.selectedRegions[0].stopY)
            if (fx.selectedRegions[0].stopX > expandedIndex) {
                fx.selectedRegions[0].stopX = expandedIndex
            }    
        } else if (fx.fileMode == "fileList" || fx.fileMode == "directory") {
            fx.cursorLineIndex += 1
            if (fx.cursorLineIndex >= fx.lines.length) {
                fx.cursorLineIndex = fx.lines.length - 1
            }
            ensureCursorInScreen()
        } else {
            moveHomeEndDirection = "right"
            moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
            // the "true ||" essentially comments out the shift screen to the left feature
            // in practice it wasn't that helpful because I did one char at a time
            if (true || document.activeElement == theText) {
                fx.cursorColIndex += 1
                if (document.activeElement == theText) {
                    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
                    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
                }
                ensureCursorInScreen()
            } else {
                var origOffsetX = fx.offsetX
                // scroll by tabstop?
                if (false && fx.offsetX < 0) {
                    fx.offsetX = 0
                }  else {
                    // var tabStop = 4
                    var tabStop = 1 // we changed this to only move one cursor at a time
                    fx.offsetX = Math.ceil((fx.offsetX + 1) / tabStop) * tabStop
                }
                ////fx.offsetX += Math.floor(maxCols/2)
                // fx.cursorColIndex += fx.offsetX - origOffsetX
                fx.cursorColIndex += 1
            }
        }
        document.body.addEventListener("touchend", onEndForEdges)
        updateCursorXY()
        render()
        return
    } else if (startTouchX < 40) {
        var bbox = c.getBoundingClientRect()
        if (startTouchY - bbox.top < (bbox.height/2)) {
            moveHomeEndDirection = "up"
            moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
            fx.cursorLineIndex -= 1
            if (fx.cursorLineIndex < 0) {
                fx.cursorLineIndex = 0
            }
            ensureCursorInScreen()
            if (fx.selectedRegions.length) {
                fx.selectedRegions[0].stopY -= 1
                if (fx.selectedRegions[0].stopY < fx.selectedRegions[0].startY) {
                    fx.selectedRegions[0].stopY = fx.selectedRegions[0].startY
                }    
                var theLine = fx.lines[fx.selectedRegions[0].stopY] || ""
                fx.selectedRegions[0].stopX = expandTabIndex(theLine, theLine.length, fx.selectedRegions[0].stopY)
            } else if (document.activeElement != theText) {
                fx.offsetY -= 1
                if (fx.offsetY < 0) {
                    fx.offsetY = 0
                }
            }
        } else if (fx.selectedRegions.length) {
            fx.selectedRegions[0].stopX -= 1
            if (fx.selectedRegions[0].stopX < 0) {
                fx.selectedRegions[0].stopY = 0
            }    
        } else if (fx.fileMode == "fileList" || fx.fileMode == "directory") {
            fx.cursorLineIndex -= 1
            if (fx.cursorLineIndex < 0) {
                fx.cursorLineIndex = 0
            }
            ensureCursorInScreen()
        } else {
            moveHomeEndDirection = "left"
            moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
            // the "true ||" essentially comments out the shift screen to the left feature
            // in practice it wasn't that helpful because I did one char at a time
            if (true || document.activeElement == theText) {
                fx.cursorColIndex -= 1
                if (document.activeElement == theText) {
                    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
                    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
                }
                ensureCursorInScreen()
            } else {
                var origOffsetX = fx.offsetX
                if (false && fx.offsetX <= 0) {
                    fx.offsetX = -5
                }  else {
                    // var tabStop = 4
                    var tabStop = 1 // we changed this to only move one cursor at a time
                    fx.offsetX = Math.floor((fx.offsetX-1) / tabStop) * tabStop
                }
                // fx.cursorColIndex += fx.offsetX - origOffsetX
                fx.cursorColIndex -= 1
                if (fx.cursorColIndex < -5) {
                     fx.cursorColIndex = -5    
                }
            }
        }
        if (fx.cursorColIndex < -5){
            fx.cursorColIndex = -5
        }
        // if (fx.cursorColIndex < 0){
        //     fx.cursorColIndex = 0
        // }
        if (fx.offsetX < -5){
            fx.offsetX = -5
        }
        document.body.addEventListener("touchend", onEndForEdges)
        updateCursorXY()
        render()
        return
    }


    if (fx.selectedRegions.length) {
        // idea: if 2 touches while selected
        // do something else like comment
        document.body.addEventListener("touchmove", onMoveWhileSelected)
        moveListenerCount += 1
        document.body.addEventListener("touchend", onEndWhileSelected)
        endListenerCount += 1
    } else {
        if (e.touches.length > 1 && cursorType != "select") {
            // this selectAction is the one from the first touch
            // select action will not get set on the second touch
            selectAction()
            return
        }

        var bbox = c.getBoundingClientRect()
        
        if (startTouchY - bbox.top < 40) {
            if (document.activeElement == theText) {
               shouldAutocompleteLine = true
            } else if (false) { // commenting out the page down feature
                var origOffsetY = fx.offsetY
                fx.offsetY -= Math.round(maxLines/2) 
                if (fx.offsetY <= 0) {
                    fx.offsetY = 0
                }
                fx.cursorLineIndex += fx.offsetY - origOffsetY
                updateCursorXY()
                render()
                return
            }
        }
        // commenting out the page down feature
        if (false && (bbox.top + bbox.height) - startTouchY < 40) {
            if (document.activeElement == theText) {
            } else {
                var origOffsetY = fx.offsetY
                fx.offsetY += Math.round(maxLines/2) 
                if (fx.offsetY >= lines.length - 10) {
                    fx.offsetY = lines.length - 10
                }
                fx.cursorLineIndex += fx.offsetY - origOffsetY
                updateCursorXY()
                render()
                return
            }
        }

        selectTimeout = setTimeout(selectAction, selectTimeoutMillis)
        document.body.addEventListener("touchmove", onMove)
        moveListenerCount += 1
        document.body.addEventListener("touchend", onEnd)
        endListenerCount += 1
    }
    render()
}
function clickItemInDirectory() {
    var prefix = fx.fullPath
    // To prevent leading double slash
    if (prefix == "/") {
        prefix = ""
    }
    var addPath = fx.lines[fx.cursorLineIndex]
    if (addPath == "..") {
        var parts = prefix.split("/")
        if (parts.length > 0) {
            parts = parts.slice(0, parts.length - 1)
        }
        var newFullPath = parts.join("/")
    } else {
        var newFullPath = prefix + "/" + addPath
    }
    var preventSelect = true
    if (fx.cursorColIndex != -5) {
        closeFile()
        preventSelect = false
    }
    addFile(newFullPath, preventSelect)
}
// marker orange
var shouldAutocompleteLine = false
// NEW FIND WORD
var acWord = null
function acWordToggle(recursive) {
    if (acWord == null) {
        var w
        if (lastAction == "move") {
            w = getWordAtCursor()
        } else {
            if (shouldAutocompleteLine) {
                w = {
                    // do we need statrt and end
                    word: (fx.lines[fx.cursorLineIndex] || "").trim() 
                }  
            } else {
                w = getWordBeforeCursor()
            }
        }

        acWord = {
            startY: fx.cursorLineIndex,
            stopY: fx.cursorLineIndex,
            hasPlopped: false,
            seen: {}
        }
        var theLine = fx.lines[fx.cursorLineIndex]
        if (lastAction == "type") {
            // start on autocomplete line
            //if (theLine.substring(0, w.start)
            acWord.prefix = w.word
            acWord.word = w.word
            acWord.startX = fx.cursorColIndex
            acWord.stopX = fx.cursorColIndex
            
            // to prevent autocomplet in the middle
            // of a word from getting that compound word.
            var _w = getWordAtCursor()
            acWord.seen[_w.word] = true

            // if it's the start of the line
            // do autocomplete whole line
            // works for languages where lines start with words usually
            //if (theLine.trim() == w.word) {
            // if (theLine.trim() == w.word && !hasMovedSinceNewLine) {
            if (shouldAutocompleteLine) {
                acWord.autocompleteLine = true
            }
            shouldAutocompleteLine = false 
        } else {
            acWord.startX = expandTabIndex(theLine, w.start)
            acWord.stopX = expandTabIndex(theLine, w.end)
            acWord.word = w.word
        }
        acWord.fileIndex = files.indexOf(fx)
        if (acWord.fileIndex == -1) {
            acWord.fileIndex = 0
        }
        acWord.findUpX = fx.lines[fx.cursorLineIndex].length
        acWord.findUpY = fx.cursorLineIndex
        if (acWord.autocompleteLine) {
            acWord.findUpY = fx.cursorLineIndex <= 0 ? 0 : fx.cursorLineIndex - 1
        }
        acWord.findDownX = 0
        acWord.findDownY = fx.cursorLineIndex + 1
        acWord.findDirection = false // true: up, false: down
        acWord.toggleCount = 0
        acWord.clearedWord = acWord == ""
        acWord.pasteLastCleared = false
        acWord.pastedLastTyped = false
        acWord.pastedCopyBufferInLine = false
        // acWord.pastedCutBufferInLine = false
        acWord.findUpDone = false
        acWord.findDownDone = false
        // so replacements don't affect search
        acWord.origLine = fx.lines[fx.cursorLineIndex]
    }
    // single for loop so we can break
    loopBlock:
    for (var s=0; s<1; s++) {
        if (acWord.prefix) {
            // just autocomplete
            var loopCount = 0
            var found = ""
            loopFind:
            while (true) {
                found = ""
                loopCount += 1
                if (loopCount > 1000) {
                    alert("eek!")
                    break loopFind
                }
                acWord.findDirection = !acWord.findDirection
                if (acWord.fileIndex >= files.length) {
                    //alert("allDone")
                    acPlop([""])
                    if (!acWord.autocompleteLine) {
                       shouldAutocompleteLine = true
                    } 
                    if (acWord.autocompleteLine && !acWord.hasPlopped && !recursive) {
                        acWord = null
                        log("all done")
                        acWordToggle(true)
                        return
                    }
                    acWord = null
                    log("all done")
                    return
                }
                if (acWord.findUpDone && acWord.findDownDone) {
                    acWord.findUpX = 0
                    acWord.findDownX = 0
                    acWord.findUpY = -1
                    acWord.findDownY = 0
                    acWord.findDirection = true // so next loop it goes down
                    acWord.findUpDone = true
                    acWord.findDownDone = false
                    if (acWord.fileIndex == files.indexOf(fx) && acWord.fileIndex != 0) {
                        acWord.fileIndex = 0
                    } else {
                        acWord.fileIndex+=1
                        if (acWord.fileIndex == files.indexOf(fx)) {
                            acWord.fileIndex+=1
                        }
                    }
                    continue loopFind
                }
                if (!acWord.findUpDone && acWord.findDirection) {
                    found = acFindUp().word
                    if (found == "") {
                        acWord.findUpDone = true
                        continue loopFind
                    }
                    break loopFind
                }

                if (!acWord.findDownDone) {
                    found = acFindDown().word
                    if (found == "") {
                        acWord.findDownDone = true
                        continue loopFind
                    }
                }

                if (found == "") {
                    continue loopFind
                }

                break loopFind
            }

            // here we have found a word
            log({okfound: found})
            acPlop([trimPrefix(found, acWord.prefix)])
            break loopBlock
        }
        
        // here we have no prefix, not autocompleting
        if (!acWord.clearedWord && acWord.word != "") {
            acWord.clearedWord = true
            lastCleared = acWord.word
            acPlop([""])
            break loopBlock
        }
        
        if (!acWord.pastedLastTyped && lastWord && lastWord != acWord.word) {
            acWord.pastedLastTyped = true
            acPlop([lastWord])
            break loopBlock
        }
        
        if (!acWord.pasteLastCleared && lastCleared && lastCleared != acWord.word) {
            acWord.pasteLastCleared = true
            acPlop([lastCleared])
            break loopBlock
        }
        

        if (!acWord.pastedCopyBufferInLine && copyBuffer.length) {
            acWord.pastedCopyBufferInLine = true
            acPlop(copyBuffer)
            break loopBlock
        }
        
        // if (!acWord.pastedCutBufferInLine && cutBuffer.length) {
        //     acWord.pastedCutBufferInLine = true
        //     acPlop(cutBuffer)
        //     break loopBlock
        // }
        acWord.clearedWord = false
        acWord.pasteLastCleared = false
        acWord.pastedLastTyped = false
        acWord.pastedCopyBufferInLine = false
        // acWord.pastedCutBufferInLine = false
        acPlop([acWord.word])
    }
    acWord.toggleCount += 1
}
// marker orange
var inACPlop = false
function acPlop(buff) {
    if (buff[0].length > 0){
       acWord.hasPlopped = true
    }
    inACPlop = true
    // TODO: compare with old implementation
    // replaceFindWord
    // this one calls more orher funcs like del()
    // and paste() and we might cause a little extra work
    var oldPreventRender = preventRender
    preventRender = true
    var oldCopyBuffer = copyBuffer
    var oldCutBuffer = cutBuffer
    copyBuffer = buff
    var oldSelectMode = selectMode
    fx.selectedRegions = [{
        startX: acWord.startX,
        stopX: acWord.stopX,
        startY: acWord.startY,
        stopY: acWord.stopY,
    }]
    selectMode = "char"
    del(true, true) // note that del does a lot more than maybe we need
    acWord.stopY = acWord.startY
    paste()
    acWord.stopY = acWord.startY + copyBuffer.length - 1
    if (copyBuffer.length == 1) {
        var theLine = fx.lines[fx.cursorLineIndex] || ""

        acWord.stopX = expandTabIndex(theLine, u(acWord.startX) + copyBuffer[0].length)
    } else {
        var lastCopyBufferLine = copyBuffer[copyBuffer.length - 1]
        // note. we don't cache this
        acWord.stopX = expandTabIndex(lastCopyBufferLine, lastCopyBufferLine.length, null, null, "nocache")
    }
    // marker aquamarine autocomplete
    if (!acWord.autocompleteLine) {
        fx.cursorColIndex = acWord.stopX
    }
    fx.cursorLineIndex = acWord.stopY
    updateCursorXY()
    ensureCursorInScreen()
    copyBuffer = oldCopyBuffer
    cutBuffer = oldCutBuffer
    selectMode = oldSelectMode
    fx.selectedRegions = []
    preventRender = oldPreventRender
    render()
    inACPlop = false
}
function acFindUp() {
    var w = {start: -1, end: -1, word: ""}
    for (acWord.findUpY; acWord.findUpY>=0; acWord.findUpY--) {
        var line = files[acWord.fileIndex].lines[acWord.findUpY] || ""
        // so word being changed doesn't affect cursor
        if (acWord.fileIndex == files.indexOf(fx) && acWord.startY == acWord.findUpY) {
            line = acWord.origLine
        }
        if (acWord.findUpX < 0) {
            acWord.findUpX = line.length
        }

        if (acWord.autocompleteLine) {
            var trimmedLine = line.trim()
            if (trimmedLine.startsWith(acWord.prefix)) {
                // Also make sure it's not a regular word
                // because we would have seen it in the non autocompleteLine flow.
                if (isRegularWord(trimmedLine)) {
                    continue   
                }
                // the start and end don't matter
                var seen = acWord.seen[trimmedLine]
                if (!seen) {
                    acWord.seen[trimmedLine] = true
                    return {word: trimmedLine}
                }
            }
            continue
        }

        for (acWord.findUpX; acWord.findUpX>=0; acWord.findUpX--) {
            w = getWordAt(line, acWord.findUpX)
            if (w.word != "") {
                acWord.findUpX = w.start - 1
            }
            var seen = acWord.seen[w.word]
            if (!seen && w.word != "" &&
                (acWord.prefix == "" || (w.word != acWord.prefix && w.word.startsWith(acWord.prefix)))) {
                if (acWord.findUpX < 0) {
                    acWord.findUpY -= 1
                }
                acWord.seen[w.word] = true
                return w
            }
        }
    }
    return {start: -1, end: -1, word: ""}
}

function acFindDown() {
    var w = {start: -1, end: -1, word: ""}
    for (acWord.findDownY; acWord.findDownY<files[acWord.fileIndex].lines.length; acWord.findDownY++) {
        var line = files[acWord.fileIndex].lines[acWord.findDownY] || ""

        if (acWord.autocompleteLine) {
            var trimmedLine = line.trim()
            if (trimmedLine.startsWith(acWord.prefix)) {
                // Also make sure it's not a regular word
                // because we would have seen it in the non autocompleteLine flow.
                if (isRegularWord(trimmedLine)) {
                    continue   
                }
                // the start and end don't matter
                var seen = acWord.seen[trimmedLine]
                if (!seen) {
                    acWord.seen[trimmedLine] = true
                    return {word: trimmedLine}
                }
            }
            continue
        }

        for (acWord.findDownX; acWord.findDownX < line.length; acWord.findDownX++) {
            w = getWordAt(line, acWord.findDownX)
            if (w.word != "") {
                acWord.findDownX = w.end + 1
            }
            var seen = acWord.seen[w.word]
            if (!seen && w.word != "" &&
                (acWord.prefix == "" || (w.word != acWord.prefix && w.word.startsWith(acWord.prefix)))) {
                if (acWord.findDownX >= line.length) {
                    acWord.findDownY += 1
                    acWord.findDownX = 0
                }
                acWord.seen[w.word] = true
                return w
            }
        }
        acWord.findDownX = 0
    }
    return {start: -1, end: -1, word: ""}
}
// END NEW FIND WORD
function doFormat() {
    if (!confirm("format code?")) {
        return 
    }
    setLines(simpleFormat(fx.lines))
    docChanged()
    render()
}
function simpleFormat(lines) {
    // this will work as long as every indent
    // has another lone that "closes" it
    /*
    split lines
    store for each line if it's more intented
    or less indented
    */
    var newLines = []
    var lastSpaceCount = 0
    var currentIndent = 0
    for (var i=0; i<lines.length; i++) {
        var line = lines[i]
        if (line.trim() == "") {
            newLines.push("")
            continue
        }
        var spaceCount = getSpaceCount(line)
        if (spaceCount > lastSpaceCount) {
            currentIndent += 1
        } else if (spaceCount < lastSpaceCount) {
            currentIndent -= 1
        }
        if (currentIndent < 0) {
            currentIndent = 0
        }
        newLines.push(
            " ".repeat(globalTabStop * currentIndent) +
            line.trim()
        )

        lastSpaceCount = spaceCount
    }
    return newLines
}

function getSpaceCount(line) {
    spaceCount = 0
    for (var i=0; i<line.length; i++) {
        var chr = line[i]
        if (chr == " ") {
            spaceCount += 1
        } else if (chr == "\t") {
            spaceCount += globalTabStop
        } else {
            break
        }
    }
    return spaceCount
}

// if it's at 0 (or only ondented) you could do
// if, func, for, var!!

function selectFileRow(e) {
    if (!e.target.hasAttribute("data-index")) {
        // thinking we get here if they tap in the margin
        // or now the handle
        return
    }
    var index = e.target.getAttribute("data-index")
    
    if (index == 0 && reorderFiles) {
        // simple (alt+tab) within file
        // Won't work if we alrady have been having back.
        if (fx.locationIndex == fx.locationStack.length - 1) {
            navBack()
        } else {
            navForward()
        } 
        return
    }
    selectFileIndex(index)
}
function selectFileIndex(index) {
    var file = files[index]
    // put it at the beginning.
    
    if (reorderFiles) {
        files.splice(index, 1)
        files.unshift(file)
    }
    setCurrentFile(file)
}

function moveFileAllTheWayLeft() {
    var theIndex = files.indexOf(fx)
    if (theIndex == -1) {
        return
    } 
    if (theIndex == 0) {
        return
    } 
    files.splice(theIndex, 1)   
    files.splice(0, 0, fx)   
    render()
    renderFileDropdown()
}
function moveFileLeft() {
    var theIndex = files.indexOf(fx)
    if (theIndex == -1) {
        return
    } 
    if (theIndex == 0) {
        return
    } 
    files.splice(theIndex, 1)   
    files.splice(theIndex - 1, 0, fx)   
    render()
    renderFileDropdown()
}
function moveFileRight() {
    var theIndex = files.indexOf(fx)
    if (theIndex == -1) {
        return
    } 
    if (theIndex == files.length - 1) {
        return
    } 
    files.splice(theIndex, 1)   
    files.splice(theIndex+1, 0, fx)   
    render()
    renderFileDropdown()
}

var uniqueID = 0
function getUniqueID() {
   uniqueID++
   return uniqueID
}

var fileToken = {}

function makeFile(fullPath, cursorLineIndex, contents) {
    var theLines = contents.split("\n")
    return {
        // fullPath should have the leading slash
        fullPath: fullPath,
        name: "",
        undo: {
            index: 0,
            stack: [contents],   
            xStack: [0],
            yStack: [0],
            lastSavedLines: JSON.parse(JSON.stringify(theLines)),
            lastSavedHash: md5(contents),
        },
        lines: theLines,
        cursorLineIndex: cursorLineIndex,
        cursorColIndex: 0,
        offsetY: cursorLineIndex, // you could get smarter about this
        offsetX: 0,
        fileMode: "file",
        bashCWD: "",
        originatingFullPath: "",
        version: 0,
        savedVersion: 0,
        savingVersion: -1,
        uniqueID: getUniqueID(),
        fileToken: fileToken,
        selectedRegions: [],
        
        locationStack: [],
        locationIndex: -1,
        lastOffsetY: -1,
    }
}
function addFileToList(file) {
    if (initialFileAdding) {
        files.push(file)
    } else {
        // add it after current file if it exists in list, otherwise unshift it to the start.
        var theIndex = files.indexOf(fx)
        if (theIndex != -1) {
            files.splice(theIndex + 1, 0, file)
        } else {
            files.unshift(file)
        }
    }
    renderFileDropdown()
}
function addFile(fullPath, preventSelect, id) {
    
    fullPath = normalizeFullPath(fullPath)
    if (fullPath == "") {
        return
    }
    
    // adding file to list beforehand to preserve order
    
    var cursorLineIndex = 0
    var parts = fullPath.split(":")
    fullPath = parts[0]
    if (parts.length > 1) {
        cursorLineIndex = (parts[1] - 1) || 0   
    }
    // If the file is already in the list of open files.
    // then let it have a reference to the existing lines, like vim does.
    for (var i=0; i<files.length; i++) {
        if (files[i].fullPath == fullPath) {
            duplicateFile(files[i], cursorLineIndex, id)
            return
        }
    }
    
    var file = makeFile(fullPath, cursorLineIndex, "")
    file.ID = id
    addFileToList(file)
    if (!initialFileAdding) {
        if (!preventSelect) {
            setCurrentFile(file)
        }
        renderURL()
    }
    fetchFile(fullPath, file, id).then(() => {
        for (var i=0; i<files.length; i++) {
            if (files[i] != file && files[i].fullPath == file.fullPath) {
                // TODO: is this needed, I think duplicateFile should get these?
                files[i].lines = file.lines
                files[i].undo = file.undo
            }
        }
        updateCursorXY()
        render()
    }).catch(e => {
        alert("Error loading file " + e)
    })
}

function verifyLoadedMD5(f, md5String) {
    if (!md5String) {
        return
    }
    if (md5String != f.undo.lastSavedHash) {
        log(`md5s don't match ${f.fullPath} ${md5String}; ${f.undo.lastSavedHash}`)
    } else {
        log(`md5s DO match ${f.fullPath} ${md5String}; ${f.undo.lastSavedHash}`)
    }
    
}

function renderFileDropdown() {
    fileRow.innerHTML = ""
    for (var fileI=0; fileI<files.length; fileI++) {
        var file = files[fileI]
        // Todo, what causes this bug
        if (!file) {
            var err = new Error()
            log("null file error")
            log(err.stack)
            log({fileI, files})
            // this bug keeps biting me every once in a while
            alert("null file issue!! on " + fileI)
            return
        }
        // this is for the "grip handles" because we are experimenting with selecting files ontouchstart.
        // if (fileI % 5 == 0 && fileI != 0) {
        //     var button = document.createElement("div")
        //     button.className = "longButton handle"
        //     button.innerText = ""
        //     fileRow.appendChild(button)
        // }
        var button = document.createElement("div")
        button.className = "longButton"
        // button.className = "square"
        button.setAttribute("data-index", fileI)
        var theName = ""
        if (file.fileMode == "terminal" && file.name) {
            theName = file.name
        } else {
            var parts = file.fullPath.split("/")
            theName = parts[parts.length - 1]
        }
        button.innerText = theName.substr(0, 15)
        if (fx == file) {
            button.classList.add("selected")
            
        }
        fileRow.appendChild(button)
        
    }
    renderSaves()

}
var treeFiles = []
var fileTree = {}
var treeFilesShadow = []
// marker green
function treeToLines(theTree, path, indent, kPrefix) {
    var theKeys = Object.keys(theTree)
    theKeys.sort()
    // for (var k in theTree) {
    for (var ki = 0; ki < theKeys.length; ki++ ) {
        var k = theKeys[ki]
        
        var childKeys = Object.keys(theTree[k])
        // Do I need this?
        childKeys.sort()
        if (false && (childKeys.length == 1)) {
            kPrefix += k + "/"
            if (theTree[k][childKeys[0]].fileToken == fileToken) {
                treeFiles.push(indent + kPrefix + "/" + childKeys[0])
                treeFilesShadow.push(theTree[k][childKeys[0]])
            } else {
                newPath = path + "/" + k + "/" + childKeys[0]
                treeToLines(theTree[k][childKeys[0]], newPath, indent + "", kPrefix)
            }
            continue
        }
 
        kPrefix = ""
        if (theTree[k].fileToken == fileToken) {
            if (theTree[k].fileMode == "file") {
                treeFiles.push("" + indent + kPrefix + k)
            } else if (theTree[k].fileMode == "bash") {
                treeFiles.push("" + indent + kPrefix + k)
            } else if (theTree[k].fileMode == "terminal") {
                // same as others but a separate if statement so we can easily change it later
                treeFiles.push("" + indent + kPrefix + k)
            } else {
                treeFiles.push("" + indent + kPrefix + k)
            }
            // add that suffix if you want to show the line they are on
            // + "    " + (theTree[k].lines[theTree[k].cursorLineIndex]|| "").trim() )
            treeFilesShadow.push(theTree[k])
        } else {
            treeFiles.push("" + indent + kPrefix + k)
            var newPath = path + "/" + k
            treeFilesShadow.push(newPath)
            treeToLines(theTree[k], newPath, indent + "  ", "")
        }
    }
}

function getLinesForFileList() {
    fileTree = {}
    
    // reset the index
    for (var i=0; i<files.length; i++) {
        // tmpIndex should only be used in this function
        files[i].tmpIndex = i
    }
    
    // doing the slice so we don't mutate the original array
    var sortedFiles = files.slice().sort(function(f1, f2) {
        if (f1.fileMode == "bash") {
            // TODO: should we set the fullPath for bash to be the CWD?  
            return (f1.originatingFullPath + f1.tmpIndex) > (f2.originatingFullPath + f2.tmpIndex)
        } else if (f1.fileMode == "terminal") {
            // #todoterminal: how get the cwd of the process (/proc/fd) ?
            return (f1.originatingFullPath + f1.tmpIndex) > (f2.originatingFullPath + f2.tmpIndex)
        } else {
            return (f1.fullPath + f1.tmpIndex) > (f2.fullPath + f2.tmpIndex)
        }
    })
    
    // taking advantage of sorted order here
    for (var fileI=0; fileI<sortedFiles.length; fileI++) {
        var f = sortedFiles[fileI]
        // var parts = (f.fullPath + ":" + (f.cursorLineIndex+1)).split("/")
        // var parts = (f.fullPath + "(" + (f.tmpIndex) + ")").split("/")
        var parts = (f.fullPath + "(" + (f.ID) + ")").split("/")
        if (f.fileMode == "bash") {
            // parts = (f.originatingFullPath + ":" + (f.cursorLineIndex+1)).split("/")
            // parts = (f.originatingFullPath + " (" + (f.tmpIndex+1) + ")").split("/")
            parts = ["(cmd)", (f.tmpIndex+"").padStart(2, "0") + ": " + (f.name || "")]
        } else if (f.fileMode == "terminal") {
            // #todoterminal: how get the cwd of the process (/proc/fd) ?
            parts = ["(terminal)", (f.tmpIndex+"").padStart(2, "0") + ": " + (f.name || "")]
        }
        // var parts = (f.fullPath).split("/")
        var curTree = fileTree 
        for (var partI=0; partI<parts.length; partI++) {
           var part = parts[partI]
           if (part == "") {
              continue
           }
           
           var childTree = curTree[part]
           if (!childTree) {
              if (partI == parts.length-1) {
                  childTree = f
              } else {
                  childTree = {}
              }
              curTree[part] = childTree
           }
           curTree = childTree 
        }
    }
    // marker lime
    treeFiles = []
    treeFilesShadow = []
    
    
    for (let i = 0; i < files.length; i++) {
        // treeFiles.push(files[i].fullPath.split("/").reverse().join(" < "))
        treeFiles.push(files[i].name || files[i].fullPath.split("/").slice(-1)[0])
        // treeFilesShadow.push(files[i].fullPath)
        treeFilesShadow.push(files[i])
    }
    treeFiles.push("-")
    treeFilesShadow.push(null)
    
    treeToLines(fileTree, "", "", "")
    return treeFiles
}


function seeFiles() {
    if (fx.fileMode == "fileList") {
        setCurrentFile(lastFile)
        return
    }
    var contents = getLinesForFileList().join("\n")
    var f = makeFile("__", 0, contents)
    f.fileMode = "fileList"

    f.cursorLineIndex = 0
    var fileIndex = treeFilesShadow.indexOf(fx)
    if (fileIndex != -1) {
        f.cursorLineIndex = fileIndex
    }

    setCurrentFile(f)
    updateCursorXY()
    ensureCursorInScreen()
}
function setCurrentFile(file) {
    if (!file) {
        return
    }

    // #filestuff
    // this check doesn't seem to work
    // alt-tab after viewing files is broken
    if (fx && fx.fileMode != "fileList" && fx != file) {
        lastFile = fx
    }
    fx = file
    if (fx.fileMode == "bash") {
        bashToolbar1.classList.remove("hidden")
        bashToolbar2.classList.remove("hidden")
        terminalToolbar1.classList.add("hidden")
        terminalToolbar2.classList.add("hidden")
    } else if (fx.fileMode == "terminal") {
        bashToolbar1.classList.add("hidden")
        bashToolbar2.classList.add("hidden")
        terminalToolbar1.classList.remove("hidden")
        terminalToolbar2.classList.remove("hidden")
    } else {
        bashToolbar1.classList.add("hidden")
        bashToolbar2.classList.add("hidden")
        terminalToolbar1.classList.add("hidden")
        terminalToolbar2.classList.add("hidden")
    }
    fileNameInput.value = file.name || ""
    setCanvasHeightAccordingly()
    updateCursorXY()
    searchText.setAttribute("placeholder", fx.fullPath + " (search)")
    render()
    renderFileDropdown()

}

function duplicateFile(f, cursorLineIndex, id="") {
    if (f.fileMode == "terminal") {
        return
    }
    var fc = JSON.parse(JSON.stringify(f))
    fc.fileToken = fileToken
    fc.uniqueID = getUniqueID()
    fc.ID = id
    
    if (id == "") {
        fetch(proxyPath + "/duplfile?idtodup="+f.ID+"&id="+id, {
            cache: "no-cache"
        }).then(r => {
            if (r.headers.get("X-ID")) {
                fc.ID = r.headers.get("X-ID") - 0
            }
        }).catch(e => {
            alert("Error duplicating file " + e)
        })
    }
    // copy everything but reference lines
    fc.lines = f.lines
    fc.undo = f.undo
    addFileToList(fc)
    setCurrentFile(fc)
    if (cursorLineIndex != -1) {
        fc.cursorLineIndex = cursorLineIndex
        ensureCursorInScreen()
    }
    renderURL()
    // TODO: eventually, update cursor position
    // when text to one file is added.
}

// also see makeFile
function fetchFile(fullPath, file, id="") {
    var isDir = false
    var newID = 0
    var md5String = ""
    fullPath = normalizeFullPath(fullPath)
    return fetch(proxyPath + "/saveload?fullpath=" + encodeURIComponent(fullPath) + "&raw=1&id="+id, {
        cache: "no-cache"
    }).then(r => {
        if (r.headers.get("X-Is-Dir") == "1") {
            isDir = true
        }
        
        // only gets id if new file
        if (r.headers.get("X-ID")) {
            file.ID = r.headers.get("X-ID") - 0
        }
        md5String = r.headers.get("X-MD5")
        return r.text()
    }).then(b => {
        file.lines = b.split("\n")
        file.undo = {
            stack: [b],
            index:0,
            xStack: [0],
            yStack: [0],
            lastSavedLines: JSON.parse(JSON.stringify(file.lines)),
            lastSavedHash: md5(b),
        }
        file.loadedFirstTime = true
        if (isDir) {
            file.fileMode = "directory"
            file.cursorLineIndex = 1
        } else {
            file.fileMode = "file"
        }
        verifyLoadedMD5(file, md5String)
    }).catch(e => {
        alert("Error loading file " + e)
    })
}

function reloadAll() {
    var seen = {}
    for (var i=0; i<files.length; i++) {
        var theFile = files[i]
        if (!seen[theFile.fullPath]) {
            reloadFile(theFile)    
        }
        seen[theFile.fullPath] = true
    }
}

function reloadFile(theFile) {
    if (theFile.fileMode != "file" && theFile.fileMode != "directory") {
        return
    }
    // Update all the other instances of this same file, no matter if it's the current file I guess
    fetchFile(theFile.fullPath, theFile, theFile.ID).then(() => {
        for (var i=0; i<files.length; i++) {
            if (files[i].fullPath == theFile.fullPath) {
                files[i].lines = theFile.lines
                files[i].undo = theFile.undo
            }
        }
        render()
    }).catch(e => {
        alert("Error loading file " + e)
    })
    
}

var inDebugView = false
function debugView() {
    inDebugView = !inDebugView
    if (inDebugView) {
       statusEl.classList.remove("hidden")
       logEl.classList.remove("hidden")
    } else {
       statusEl.classList.add("hidden")
       logEl.classList.add("hidden")
    }
    setCanvasHeightAccordingly()
}



var maxUndos = 30

var fx

var files = []

var lines = []
// the actual lines will be put here by the server
// LINES GO HERE

var fileMode = "file"
// FILEMODE DIRECTORY GOES HERE

var rootLocation = "" // will be set server side
// ROOTLOCATION GOES HERE
// var paths = decodeURIComponent(location.pathname).split(",")
var paths = (location.pathname).split(",")

var firstFileMD5 = ""
// FIRSTFILEMD5 GOES HERE


var initialFileAdding = false
function oldStuff() {
    // The first one get's "hydrated" by the server
    // ay, joining just to split again. Clean up.
    var cursorLineIndex = 0
    var parts = paths[0].split(":")
    var fullPath = parts[0]
    if (parts.length > 1) {
        cursorLineIndex = (parts[1] - 1) || 0   
    } 
    var initialFile = makeFile(fullPath, cursorLineIndex, lines.join("\n"))
    initialFile.fileMode = fileMode
    initialFile.bashCWD = rootLocation
    initialFile.loadedFirstTime = true 
    verifyLoadedMD5(initialFile, firstFileMD5)
    var serverLoadFirstFile = true
    var ajaxLoadStartIndex
    if (serverLoadFirstFile) {
        ajaxLoadStartIndex = 1
        addFileToList(initialFile)
        setCurrentFile(initialFile)
    } else {
       ajaxLoadStartIndex = 0
    }
    
    
    // Subsequent ones will get added after the fact.
    // Starting at index 1 for this reason.
    // TODO: remove this? #wschange
    var initialFileAdding = true
    for (var i=ajaxLoadStartIndex; i<paths.length; i++) {
        if (paths[i].startsWith("__TERMINAL__")) {
            parts = paths[i].split(":")
            var id = parts[1]
            addExistingTerminalTab(id)
        } else {
            addFile(paths[i])
        }
    }
    setCurrentFile(files[0])
}

// add exising files
// TODO: you should hydrate this in the first pageload.
// and maybe at least hydrate the first file.
fetch(proxyPath + "/myfiles", {
    cache: "no-cache"
}).then(r => {
    return r.json()
}).then(r => {
    for (var serverFile of r) {
        // TODO: fix inconsistent file naming #inconsistentFileNaming
        if (serverFile.Type == "terminal") {
            addExistingTerminalTab(serverFile.ID, serverFile.Name)
        } else if (serverFile.Type == "shell") {
           addCmdTab(serverFile.ID, serverFile.CWD, serverFile.Name)
        } else {
            addFile(serverFile.FullPath + ":" + (serverFile.LineNumber || 1), false, serverFile.ID)
        }
    }
    initialFileAdding = false
    preventRender = false
    render()
    renderDarkMode()
}).catch(e => {
    alert("error loading files: " + e)
})


function updateName() {
    var name = prompt("Name:")
    if (!name) {
        return
    }
    fx.name = name
    saveOrder()
}
function saveOrder() {
   var serverFiles = []
    for (var i = 0; i < files.length; i++) {
        var f = files[i]
        // TODO: fix inconsistent file naming #inconsistentFileNaming
        serverFiles.push({
            "ID": f.ID,
            "Name": f.name,
            "Type": f.fileMode == "bash" ? "shell" : f.fileMode,
            "FullPath": f.fullPath,
            "LineNumber": f.cursorLineIndex + 1,
            "CWD": f.bashCWD,
        })
    }
    fetch(proxyPath + "/mysaveorder", {    
        cache: "no-cache",
        method: "POST",
        body: JSON.stringify(serverFiles),
    // }).then(r => {
    //     return r.json()
    // }).then(r => {
    }).catch(e => {
        alert("error saving order: " + e)
    })
}


var ust = new URLSearchParams(window.location.search)
if (ust.has("dark")) {
    isDark = ust.get("dark") == "1"
}



// make sure when selecting in the margin
// that the selectMode is   line!
// add a threshold for move, like 5px or something.
// todo: in select mode, swipe down is paste. even paste over
// I turned off "Predictive" to get more vertical space
</script>
</body>
</html>
