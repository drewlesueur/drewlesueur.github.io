<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset='utf-8'>
<style>
* { margin: 0; padding: 0; 
  background-color: black; color: white;
}
body { background-color: black; }
.text { border: none; color: cyan;
/*border: 1px solid lime;*/
}
.toolbar {
  display: flex;
  flex-flow: row nowrap;
  --flex-flow: row wrap;
  width: 375px;
  overflow: scroll;
  -webkit-overflow-scrolling: touch;
}
.toolbar div {
  --font-family: 'Courier';
  background-color: #077;
  border: 0px solid cyan;
  color: white;
  padding: 0px;
  width: 40px;
  height: 40px;
  margin: 1px;
  flex: 1 0 auto;
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;

}
</style>
<div id=topPadding style="height: 0px;"></div>
<!-- status bar -->
<div id=s style="font-size: 12px;
position: absolute;
bottom: 80px; right:0;
z-index: 999;
color: cyan;
"></div>

<form onsubmit=newLine(event)>

<input id=theTextBefore class=text
style="font: 8px Courier;
width: 375px;
/* display: none; see what it looks like without */
height:1px; overflow: hidden;
"
onfocus=handleFocusBefore()
onblur=handleBlur()
>
<input id=theText class=text
style="font: 16px Courier;
width: 375px; height:30px;
--position:absolute; top: 100px;
"
onfocus=handleFocusIn()
onblur=handleBlur()
oninput=saveLine()
onkeydown=handleKeydown(event)
>
<input id=theTextAfter class=text
style="font: 8px Courier;
width: 375px;
/* display: none; see what it looks like without */
height:1px; overflow: hidden;
"
onfocus=handleFocusAfter()
onblur=handleBlur()
>
<input type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>

<!-- 
as of now the canvas doesn't get resized
so it has to be at least as big as the biggest canvasHeight x canvasWith size.
Also note that the css width needs to be 1/3 of
the with attribute, and same for height.
-->
<canvas id=c width=1125 height=1560
style="width: 375px; height:520px;
border: 0px solid lime;;
"
ontouchstart=onStart(event)
></canvas>
<div class=toolbar>
  <div onclick=findDown()>find down</div>
  <div onclick=clearSearch()>clear search</div>
  <div onclick=insertLine()>new<br>line</div>
  <div onclick=del()>delete line</div>
  <div onclick=deleteWord()>delete word</div>
  <div onclick=paste()>paste</div>
  <div onclick=dup()>duplicate line</div>
  <div onclick=copy()>copy</div>
</div>
<div class=toolbar>
  <div onclick=doEval()>eval</div>
  <div onclick=indent()>indent</div>
  <div onclick=dedent()>dedent</div>
  <div onclick=comment()>//</div>
  <div onclick=unComment()>un //</div>
  <div onclick=pasteLastWord()>last word</div>
  <div onclick=deleteCharacter()>delete char</div>
  <div onclick=addSpace()>add space</div>
  <div onclick=jsFunc()>js func</div>
  <div onclick=toggleLog()>toggle log</div>
  <div onclick=clearLog()>clear log</div>
  <div onclick=findUp()>find up</div>
  <div onclick=undo()>undo</div>
  <div onclick=redo()>redo</div>
  <div onclick=join()>join</div>
  <div onclick=custom('func')>js func</div>
  <div onclick=replace()>replace</div>
  <div onclick=selStart()>select start</div>
  <div onclick=rselEnd()>select end</div>
</div>

<div>
<input type=text id=searchText
  style="font-size: 20px"
>
<div id=bottomPadding style="height: 0px;"></div>
</div>

</div>
<script>
// it's important that this go in it's own script tag
window.onerror = function(message, url, lineNumber, columnNumber, error) {
    alert(lineNumber + ": " + message)
}
</script>
<script>
var undoIndex = 0
var maxUndos = 30
</script>
<script>
var t = c.getContext("2d")
var version = 0
var savedVersion = 0
var savingVersion = -1
var saveEveryMS = 3000
var lastWord = ""
var fontScale = 1
var fontHeight=36 * fontScale
var fontWidth=18 * fontScale
var fontCSS = (30 * fontScale) + "px 'Courier'"
var cursorX=0
var cursorY=0
var offsetX = 0
var offsetY = 0
// 4 chars for line number and 1 for space
var marginLeft = 5

// Note that the width and height need to match
// the width and height of the canvas tag attribute.
var canvasWidth=1125
// I turned off "Predictive" to get more vertical space
var canvasHeightKeyboard=1000
var canvasHeightFull=c.height
var maxLines = 0
var maxCols = Math.ceil(canvasWidth / fontWidth)
var canvasHeight = 0
setCanvasHeight(canvasHeightFull)
var pointWidth=325
var pointHeight=500
var touchScale=2 // was 3 for a while
var cursorLineIndex = 0
var cursorColIndex = 0

var inEdit = false
var copyBuffer = []
var selectMode = "line"
var selectAction 
var cursorType = "move"
// cursorType can be 
// * move
// * select

var selectTimeout
var selectTimeoutMillis = 500
var selectedRegions = []

function doEval() {
  var code = prompt("code")
  var resp =  eval(code)
  alert(resp)
}
function log(v) {
  logLines.push(v)
}
function toggleLog() {
 logShown = !logShown
 if (logShown) {
   lines = logLines
 } else {
   lines = contentLines
 }
 render()
}

function undo() {
  undoIndex = bind(undoIndex-1, 0, undoIndex)
  lines = undoStack[undoIndex].split("\n")
  render()
}

function redo() {
  undoIndex = bind(undoIndex+1, undoIndex, undoStack.length-1)
  lines = undoStack[undoIndex].split("\n")
  render()
}
function clearLog() {
  logLines = []
  if (logShown) lines = logLines
  render()
}
// check for A-Za-z0-9_
function isWordy(a) {
  return (
     (a >= 65 && a <= 90) ||  // A-Z
     (a >= 97 && a <= 122) || // a-z
     (a >= 48 && a <= 57) ||  // 0-9
     (a == 95)                // _
  ) 
}
function getWordAtCursor() {
  return getWordAt(cursorLineIndex, cursorColIndex)  
}
function getWordAt(y, x) {
  var line = lines[y]
  if (!line) return {start: -1, end: -1, word: ""}
  log("getting word: " + line)
  for (var startIndex=x-1; startIndex>=0; startIndex--) {
    if (!isWordy(line.charCodeAt(startIndex))) {
       startIndex += 1
       break
    }
  }
  if (startIndex < 0) startIndex = 0
  for (var endIndex=x; endIndex < line.length; endIndex++) {
    if (!isWordy(line.charCodeAt(endIndex))) {
      break
    }
  }
  if (endIndex == lines.length - 1) endIndex = lines.length
  log(`start: ${startIndex} end: ${endIndex}`)
  //if (startIndex < endIndex) {
    return {start: startIndex, end: endIndex, word: line.substring(startIndex, endIndex)}
  //}
  return {start: -1, end: -1, word: ""}
}
function findDown() {
  if (searchText.value == "") {
    searchText.value = getWordAtCursor().word
  }
  log("searching for: " + searchText.value)
  for (var i=cursorLineIndex; i<lines.length; i++) {
    var lineToSearch = lines[i]
    if (i == cursorLineIndex) {
      lineToSearch = lineToSearch.substr(cursorColIndex)
    }
    var pos = lineToSearch.indexOf(searchText.value)
    if (pos != -1) {
      offsetY = i
      cursorLineIndex = i
      cursorColIndex = pos + searchText.value.length
      updateCursorXY()
      render()
      return
    }
  }
  alert("not found")
}
function clearSearch() {
  searchText.value = ""
}

function jsFunc() {
  selectMode
  docChanged()
  render()
}

function updateCursorXY() {
  cursorX = (cursorColIndex - offsetX) * fontWidth
  cursorY = (cursorLineIndex - offsetY) * fontHeight
}

function dup() {
  copy()
  paste() 
}

function indent() {
  addPrefix("  ")
}
function dedent() {
  stripPrefixes(["\t", "  "])
}

function comment() {
  addPrefix("//")
}
function unComment() {
  stripPrefixes(["\t", " "])
}

function addPrefix(prefix) {
 if (selectedRegions.length > 0) {
   var r = selectedRegions[0]
   for (var y=r.startY; y<=r.stopY; y++) {
     lines[y] = prefix + lines[y]
   }
 } else {
   lines[cursorLineIndex] = prefix + lines[cursorLineIndex]
 }
 docChanged()
 render()
}

function stripPrefixes(prefixes) {
 if (selectedRegions.length > 0) {
   var r = selectedRegions[0]
   for (var y=r.startY; y<=r.stopY; y++) {
     lines[y] = stripPrefixesInner(lines[y], prefixes)
   }
 } else {
   var line = lines[cursorLineIndex]
   lines[cursorLineIndex] = stripPrefixesInner(line, prefixes)
 }
 docChanged()
 render()
}

function stripPrefixesInner(line, prefixes) {
  for (var i=0; i<prefixes.length; i++) {
    var prefix = prefixes[i]
    if (line.startsWith(prefix)) {
      return line.slice(prefix.length)
    } 
  }
  return line 
}

function copy() {
  if (selectedRegions.length>0) {
    var r = selectedRegions[0]
    if (r.startY == r.stopY) {
      copyBuffer = [lines[cursorLineIndex].slice(r.startX, r.stopX)]  
      selectedRegions = []
      render()
      return
    }
    copyBuffer = [
      lines[r.startY].slice(r.startX),
      ...lines.slice(r.startY + 1, r.stopY),
      lines[r.stopY].slice(0, r.stopX)
    ]
    selectedRegions = []
    render()
    return
  }
  selectMode = "line" 
  copyBuffer = [lines[cursorLineIndex]]
}

function docChanged() {
   if (logShown) return
   version += 1
   var maybeLastWord = getWordAtCursor().word
   if (maybeLastWord != "") {
     lastWord = maybeLastWord
   }
}

function setCanvasHeight(h) {
  canvasHeight = h
  maxLines = Math.ceil(canvasHeight / fontHeight)
}

function paste() {
  if (selectMode == "line") {
    lines.splice(cursorLineIndex + 1, 0, ...copyBuffer)
    cursorLineIndex += 1
  } else if (selectMode == "char") {
    if (copyBuffer.length == 1) {
      lines[cursorLineIndex] = lines[cursorLineIndex].slice(0, cursorColIndex) +
        copyBuffer[0] +
        lines[cursorLineIndex].slice(cursorColIndex)
    } else {
      var line = lines[cursorLineIndex]
      lines[cursorLineIndex] = line.slice(0, cursorColIndex) +
        copyBuffer[0]
      copyBuffer[copyBuffer.length-1] += line.slice(cursorColIndex)
      lines.splice(cursorLineIndex+1, 0, ...copyBuffer.slice(1))
    }
  }
  docChanged()
  render()
}

// TODO: make lastWord an array.
function pasteLastWord() {
  var oldCopyBuffer = copyBuffer
  var oldSelectMode = selectMode
  copyBuffer = [lastWord]
  selectMode = "char"
  deleteWord()
  paste()
  copyBuffer = oldCopyBuffer
  selectMode = oldSelectMode
}

function addSpace() {
  var line = lines[cursorLineIndex]
  lines[cursorLineIndex] = line.slice(0, cursorLineIndex) + 
    " " + line.slice(cursorLineIndex)
  render()
  docChanged()
}
function deleteCharacter() {
  var line = lines[cursorLineIndex]
  lines[cursorLineIndex] = line.slice(0, cursorLineIndex) + 
    line.slice(cursorLineIndex + 1)
  docChanged()
  render()
}

function del() {
  if (selectedRegions.length>0) {
    var r = selectedRegions[0]
    if (r.startY == r.stopY) {
      if (r.startX == 0 && r.stopX == lines[r.startY].length) {
        selectMode = "line" 
        copyBuffer = [lines[r.startY]]
        lines.splice(r.startY, 1)
        selectedRegions = []
        docChanged()
        render()
        return
      } else {
        copyBuffer = [lines[r.startY].slice(r.startX, r.stopX)]  
        lines[r.startY] = lines[r.startY].substr(0, r.startX) +
        lines[r.startY].substr(r.stopX)
        selectedRegions = []
        cursorLineIndex = r.startY
        cursorColIndex = r.startX
        updateCursorXY()
        selectedRegions = []
        docChanged()
        render()
        theText.setSelectionRange(r.startX, r.startX)
        return
      }
    }
    copyBuffer = [
      lines[r.startY].slice(r.startX),
      ...lines.slice(r.startY + 1, r.stopY),
      lines[r.stopY].slice(0, r.stopX)
    ]

    lines[r.startY] = lines[r.startY].slice(0, r.startX) + 
      lines[r.stopY].slice(r.stopX)
    lines.splice(r.startY + 1, r.stopY-r.startY)
    if (lines[r.startY] == "") {
      lines.splice(r.startY, 1)
    }
    cursorLineIndex = r.startY
    cursorColIndex = r.startX
    updateCursorXY()
    selectedRegions = []
    docChanged()
    render()
    theText.setSelectionRange(r.startX, r.startX)
    return
  }
  selectMode = "line" 
  copyBuffer = [lines[cursorLineIndex]]
  lines.splice(cursorLineIndex, 1)
  docChanged()
  render()
}
function deleteWord(e) {
  var w = getWordAtCursor()
  if (w.word == "") {
    return
  }
  var line = lines[cursorLineIndex]
  lines[cursorLineIndex] = line.slice(0, w.start) + line.slice(w.end)
  cursorColIndex = w.start
  updateCursorXY()
  docChanged()
  docChanged()
  render()
}
function getIndent(line) {
   var theIndent = ""
   for (var i=0; i<line.length; i++) {
     var theChar = line.charAt(i)
     if (theChar == " " || theChar == "\t") {
       theIndent += theChar
     } else {
      return theIndent
    }
  }
  return theIndent  
}
function insertLine(closeCurly) {
  theLine = lines[cursorLineIndex]
  var theIndent = getIndent(theLine)
  if (closeCurly && theLine.endsWith("{")) {
    lines.splice(cursorLineIndex + 1, 0, theIndent + "}")
    theIndent += "  "
  }
  lines.splice(cursorLineIndex + 1, 0, theIndent + theLine.substr(theText.selectionStart))
  lines[cursorLineIndex] = theLine.substr(0, theText.selectionStart)
  cursorLineIndex += 1
  cursorColIndex = theIndent.length
  updateCursorXY()
  docChanged()
  render()
}
function newLine(e) {
  e.preventDefault()
  insertLine(true)
  theText.focus()
  theText.setSelectionRange(cursorColIndex, cursorColIndex)
  return false
}

function handleFocusAfter() {
  if (cursorLineIndex == lines.Length - 1) return
  cursorLineIndex += 1
  setCanvasHeight(canvasHeightKeyboard)
  if (cursorLineIndex < offsetY || cursorLineIndex > (offsetY + maxLines)) {
    offsetY = cursorLineIndex - maxLines
  }
  updateCursorXY()
  render()
  theText.focus()
  theText.setSelectionRange(cursorColIndex, cursorColIndex)
}

function handleFocusBefore() {
  if (cursorLineIndex == 0) return
  cursorLineIndex -= 1
  setCanvasHeight(canvasHeightKeyboard)
  if (cursorLineIndex < offsetY || cursorLineIndex > (offsetY + maxLines)) {
    offsetY = 0
  }
  updateCursorXY()
  render()
  theText.focus()
  theText.setSelectionRange(cursorColIndex, cursorColIndex)
}

function handleFocusIn() {
  setCanvasHeight(canvasHeightKeyboard)
  if (cursorLineIndex < offsetY || cursorLineIndex > (offsetY + maxLines)) {
    offsetY = cursorLineIndex - maxLines
  }
  render()
  theText.setSelectionRange(cursorColIndex, cursorColIndex)
}

function handleBlur() {
  //topPadding.style.height = "100px"
  //window.scrollTo(0, 0)
  //setTimeout(() => {window.scrollTo(0,100)}, 100) 
  setCanvasHeight(canvasHeightFull)
  render()
}

function save() {
    // using a single for loop to
    // simulate a goto
    // breaks will make sure the 'cleanup' step gets called
    for (var s=0; s<1; s++) { 
      if (logShown) break
      if (savedVersion == version) {
        break
      }
      if (undoIndex != undoStack.length - 1) {
          undoStack.splice(undoIndex + 1, undoStack.length - undoStack +1)
      }
      undoIndex += 1
      undoStack.push(lines.join("\n"))
      if (undoStack.length > maxUndos) {
        undoStack.shift()
        undoIndex -= 1
      }
      savingVersion = version
      fetch(location.href, {
        method: "POST",
        cache: "no-cache",
        headers: { "Content-Type": "application/x-www-form-urlencoded"},
        body: "content=" + encodeURIComponent(lines.join("\n"))
      })
      .then(r => r.json())
      .then(v => {
          if (v.saved) {
            savedVersion = savingVersion
            savingVersion = -1
          }
          render()
      })
      .catch(e => alert(e))
      render()
    }
    setTimeout(save, saveEveryMS)
}
setTimeout(save, saveEveryMS)

function handleKeydown(e) {
  // 8 means backspace
  if (e.keyCode == 8 && theText.selectionStart == 0 && cursorLineIndex != 0) {
    e.preventDefault()
    var theLine = lines[cursorLineIndex]

    lines.splice(cursorLineIndex, 1)
    cursorLineIndex -= 1
    var prevLine = lines[cursorLineIndex]
    lines[cursorLineIndex] = lines[cursorLineIndex] + theLine
    cursorColIndex = prevLine.length
    updateCursorXY()
    docChanged()
    render()
    theText.setSelectionRange(prevLine.length, prevLine.length)
  }
  return true
}

function saveLine() {
  // TODO: consider auto-closing parens.
  cursorColIndex = theText.selectionStart
  lines[cursorLineIndex] = theText.value
  cursorX = (cursorColIndex - offsetX) * fontWidth
  cursorY = (cursorLineIndex - offsetY) * fontHeight
  docChanged()

  // you need to tell the render to not update the text area
  // weird bigs will happen without this
  inEdit = true
  render()
  inEdit = false
}
function bind(v, min, max) {
  if (v < min) v = min
  if (v > max) v = max
  return v
}
function charAt(lines, y, x) {
  var line = lines[y]
  if (!line) return ""
  var theChar = line[x]
  if (!theChar) return ""
  return theChar
}

function render() {
  var selStart = theText.selectionStart
  var selEnd = theText.selectionEnd
  c.width = c.width // one way to clear

  // the selected areas
  for (var i=0; i<selectedRegions.length;i++) {
    // todo: normalize region start and stop
    // todo: draw the cursors after the selected regions
    var r = selectedRegions[i]
    t.fillStyle = "magenta"
    for (var y=r.startY-offsetY; y<=r.stopY-offsetY; y++) {
      var line = lines[y + offsetY] || ""
      if (r.startY == r.stopY) {
        t.fillRect((r.startX-offsetX)*fontWidth, y*fontHeight, (r.stopX-r.startX)*fontWidth, fontHeight)  
      } else if (y==r.startY-offsetY) {
        t.fillRect((r.startX-offsetX)*fontWidth, y*fontHeight, (line.length-r.startX)*fontWidth, fontHeight)  
      } else if (y==r.stopY-offsetY) {
        t.fillRect((0-offsetX)*fontWidth, y*fontHeight, r.stopX*fontWidth, fontHeight)  
      } else {
        t.fillRect((0-offsetX)*fontWidth  , y*fontHeight, line.length*fontWidth, fontHeight) 
      }
    } 
  }

  t.fillStyle = "rgba(255, 0, 0, 0.5)"
  t.fillRect(cursorX, cursorY, 6, fontHeight)
  var yPos = (cursorLineIndex - offsetY) * fontHeight
  var xPos = (cursorColIndex - offsetX) * fontWidth
  //t.fillStyle = "rgba(0, 128, 128, 0.5)"
  //t.fillRect(0, yPos, canvasWidth, fontHeight)
  t.fillStyle = cursorType == "move" ? "cyan" : "white"
  t.fillRect(xPos, yPos, 6, fontHeight)

  t.font = fontCSS
  t.textBaseline = "top"
  var r = selectedRegions[0]
  s.innerHTML = version + "/" + savedVersion +
    "/" + savingVersion +
    " p:" + cursorX + "," + cursorY + 
    " c:" + cursorColIndex + "," + cursorLineIndex + 
    " " + (r ? `s:${r.startX},${r.startY}:${r.stopX},${r.stopY}` : "s:--") +
    " " + selectMode
  for (var y=0; y <= maxLines; y++) {
    var lineNumber = (y+offsetY).toString().padStart(4, " ")
    if (offsetX < -1) {
      //t.fillStyle = "magenta"
      t.fillStyle = "cyan"
      for (var i=0; i<-offsetX-1; i++) {
        var lineNumberIndex = offsetX + marginLeft + i
        t.fillText(lineNumber.charAt(lineNumberIndex), i*fontWidth, y*fontHeight)
      }
    }

    t.fillStyle = "white"
    for (var x=0; x <= maxCols; x++) {  
      t.fillText( charAt(lines, y+offsetY, x+offsetX), x*fontWidth, y*fontHeight)
    }
  }
  cursorLine = lines[cursorLineIndex] || ""
  if (!inEdit) {
    theText.value = cursorLine
    theTextBefore.value = lines[cursorLineIndex - 1] || ""
    theTextAfter.value = lines[cursorLineIndex + 1] || ""
  }

  // set the selection range back to what it was
  // if it needs to be changed, some functions will change it
  // after the call to render.
  // TODO: have a state variable for what it should be.
  if (document.activeElement == theText) {
      theText.setSelectionRange(selStart, selEnd)
  }
 // alert(charAt(lines, 0, 0))
}

function ensureSign(sign, v) {
  if (sign < 0 && v > 0) return -v
  if (sign > 0 && v < 0) return -v
  return v
}

// todo: use min, max in some places where you ised bind
function min(a, b) {
  a < b ? a : b
}

function max(a, b) {
  a > b ? b : a
}

// TODO: keep tapping when in "insert mode" to toggle words
// look for the closest word. go up, down, up down
// but also make the first one delete the word.
function onStart(e) {
  log("start touch called and there are " + e.touches.length + " touches")
  e.preventDefault()
  // this handles all the touch interactions
  // first define the closuure functions
  
  // this is global
  if (e.touches.length == 1) {
    selectAction = function() {
      log("select called and there are " + e.touches.length + " touches")
      selectedRegions = []
      cursorType = "select"
      var line = lines[cursorLineIndex] || ""
      selectedRegion.startX = bind(cursorColIndex, 0, line.length)
      selectedRegion.startY = bind(cursorLineIndex, 0, lines.length-1)
      // Note how the stopY is inclusive
      // But the stopX is exclusive.
      // for some reason seemed natural to do it like that
      selectedRegion.stopX = bind(cursorColIndex, 0, line.length)
      selectedRegion.stopY = bind(cursorLineIndex, 0, lines.length - 1)
      if (cursorColIndex < 0) {
        selectedRegion.stopped = true
        selectMode = "line"
        selectedRegion.stopX = (lines[cursorLineIndex]  || "").length
      } else {
        selectMode = "char"
      }
      selectedRegions.push(selectedRegion)
      hasSelected = true
      render()
    }
  }
  var onMove = function(e) {
    if (e.touches.length > 1) {
      return
    }
    if (!hasSelected) {
      clearTimeout(selectTimeout)
      //selectTimeout = setTimeout(selectAction, selectTimeoutMillis)
    }
    //var diffTouchX = e.touches[0].pageX - startTouchX
    //var diffTouchY = e.touches[0].pageY - startTouchY
    //cursorX = bind(startX + diffTouchX*touchScale, 0, canvasWidth)
    //cursorY = bind(startY + diffTouchY*touchScale, 0, canvasHeight)
    
    moved = true
    var diffLastTouchX = e.touches[0].pageX - lastTouchX
    var diffLastTouchY = e.touches[0].pageY - lastTouchY
    var signX = diffLastTouchX < 0 ? -1: 1
    var signY = diffLastTouchY < 0 ? -1 : 1
    thePow = firstMove ? 1 : 2
    cursorX = cursorX + ensureSign(signX, Math.round(Math.pow(diffLastTouchX, thePow)*touchScale))
    cursorY = cursorY + ensureSign(signY, Math.round(Math.pow(diffLastTouchY, thePow)*touchScale))
    lastTouchX = e.touches[0].pageX
    lastTouchY = e.touches[0].pageY

    var changedY = false
    if (cursorY > canvasHeight) {
      var extendY = cursorY - canvasHeight
      cursorY = canvasHeight //Math.round(canvasHeight - (canvasHeight/4))
      offsetY += Math.ceil(extendY/fontHeight)
      if (offsetY > lines.length - 10) offsetY = lines.length - 10
      changedY = true
    } else if (cursorY < 0) {
      var extendY = cursorY
      cursorY = 0
      offsetY += Math.floor(extendY/fontHeight)
      changedY = true
      if (offsetY < 0) offsetY = 0
    }
    if (cursorX > canvasWidth) {
      var extendX = cursorX - canvasWidth
      cursorX = canvasWidth //Math.round(canvasHeight - (canvasHeight/4))
      
      // if (!changedY) offsetX += Math.round(extendX/fontWidth)
      if (!changedY) offsetX += Math.ceil(extendX/fontWidth)
    } else if (cursorX < 0) {
      var extendX = cursorX
      cursorX = 0
      // if (!changedY) offsetX += Math.round(extendX/fontWidth)
      if (!changedY) offsetX += Math.floor(extendX/fontWidth)
      if (offsetX < -marginLeft) offsetX = -marginLeft
    }
    cursorLineIndex = Math.round(cursorY/fontHeight) + offsetY
    cursorColIndex = Math.round(cursorX/fontWidth) + offsetX
    firstMove = false
    if (cursorType == "select") {
      var line = lines[cursorLineIndex] || ""
      selectedRegion.stopX = bind(cursorColIndex, 0, line.length)
      selectedRegion.stopY = bind(cursorLineIndex, 0, lines.length-1)
      selectedRegion.stopped = true
      if (cursorColIndex < 0) {
        selectedRegion.stopX = (lines[cursorLineIndex] || "").length
      }

    }
    render()
    if (document.activeElement==theText) {
      theText.setSelectionRange(cursorColIndex, cursorColIndex)
    }
    return false
  }
  var onEnd = function(e) {
    log("end called and there are " + e.touches.length + " touches")
    if (e.touches.length != 0) {
      return
    }
    clearTimeout(selectTimeout)
    // it's not straightforward to do a setTimeout
    // here because iOS Safari doesn't like to focus
    // text elements when not responding to user action
    // maybe there are workarounds.
    // TODO: hasSelected is about the same as cursorType == "move" 
    if (!moved && cursorType == "move") {
      if (cursorColIndex == -5) {
        // since we are in the margin, let's force it
        // to paste line-style.
        selectMode = "line"
        paste()
        return
      }
      if (cursorColIndex == -4) {
        del()
        return
      }
      if (cursorColIndex == -1) {
        insertLine()
        return
      }
      
      if (document.activeElement != theText) {
        log("calling focus")
        offsetY = bind(cursorLineIndex - 5, 0, cursorLineIndex)
        updateCursorXY()
        //topPadding.style.height=0
        theText.focus()
        theText.setSelectionRange(cursorColIndex, cursorColIndex)
      }  
    } 
    document.body.removeEventListener("touchmove", onMove)
    document.body.removeEventListener("touchend", onEnd)
    cursorType = "move"
    if (!selectedRegion.stopped) {
      var w = getWordAtCursor()
      if (w.word != "") {
        selectedRegion.startY = cursorLineIndex
        selectedRegion.startX = w.start
        selectedRegion.stopY = cursorLineIndex
        selectedRegion.stopX = w.end
      } else {
        selectedRegions = []
      }
    }
    render()
  } 

  var onMoveWhileSelected = function(e) {
    moved = true
    var diffStartTouchX = e.touches[0].pageX - startTouchX
    var diffStartTouchY = e.touches[0].pageY - startTouchY
    lastTouchX = e.touches[0].pageX
    lastTouchY = e.touches[0].pageY
    if (Math.abs(diffStartTouchX) < 5 && Math.abs(diffStartTouchY) < 5) {
      return
    }
    if (Math.abs(diffStartTouchX) > Math.abs(diffStartTouchY)) {
      if (diffStartTouchX < 0) {
        dedent()
      } else {
        indent()
      } 
    } else {
      if (diffStartTouchY < 0) {
        del()
      } else {
        copy()
      }
    }
    // stop handling it once it's handled
    document.body.removeEventListener("touchmove", onMoveWhileSelected)
  }
  var onEndWhileSelected = function(e) {
    if (!moved && selectedRegions.length) {
       selectedRegions = []
    }
    document.body.removeEventListener("touchmove", onMoveWhileSelected)
    document.body.removeEventListener("touchend", onEndWhileSelected)
    render()
  }

  var startTouchX = e.touches[0].pageX
  var startTouchY = e.touches[0].pageY
  var startX = cursorX
  var startY = cursorY
  var lastTouchX = startTouchX
  var lastTouchY = startTouchY
  var lastTime = Date.now()
  var firstMove = true
  var moved = false
  var hasSelected = false
  var selectedRegion = {}
  

  if (selectedRegions.length) {
    // idea: if 2 touches while selected
    // do something else like comment
    document.body.addEventListener("touchmove", onMoveWhileSelected)
    document.body.addEventListener("touchend", onEndWhileSelected)
  } else {
    if (e.touches.length == 2) {
      // this selectAction is the one from the first touch
      // select action will not get set on the second touch
      selectAction()
      return
    }
    if (document.activeElement == theText) {
      toggleWord()
    }
    //selectTimeout = setTimeout(selectAction, selectTimeoutMillis)
    document.body.addEventListener("touchmove", onMove)
    document.body.addEventListener("touchend", onEnd)
  }  
  render()
}

function resetFindWord() {
  findWordCount = 0
  findWordUpY = 0
  findWordUpX = 0
  findWordDownY = 0
  findWordDownX = 0
  findWordY = -1
  findWordX = -1
  findWordPrefix = ""
  findWordEndY = -1
  findWordEndX = -1
}

var findWordCount = 0
var findWordUpY = 0
var findWordUpX = 0
var findWordDownY = 0
var findWordDownX = 0
var findWordY = -1
var findWordX = -1
var findWordEndY = -1
var findWordEndX = -1
var findWordPrefix = ""
var findWordUpDone = false
var findWordDownDone = false
// replaceFindWord will be like delete and Paste
// calls that we aleeady have (jist copy functionality
// for now.
function findWordUp() {
  var w
  for (findWordUpY; findWordUpY>=0; findWordUpY--) {
    var line = lines[findWordUpY]
    if (!line) {
      return []  
    }
    for (findWordUpX; findWordUpX>=0; findWordUpX--) {
      w = getWordAtIndex(findWordUpY, findWordUpX)
      if (w.word != "") {
        findWordUpX = w.start - 1
        break
      }
    }
  }
  
  findWordUpY -= 1
  return w
}

// if it's at 0 (or only ondented) you could do
// if, func, for, var!!

function replaceFindWord(r) {
  findWordEndY = findWordY + r.length - 1
  if (findWordY == findWordEndY) {
    findWordEndX = findWordX + r[0].length
  } else {
    findWordEndX = r[r.length - 1].length     
  }
 
}
function toggleWord() {
  if (findWordY == cursorLineIndex && findWordX == cursorColIndex) {
  } else {
    resetFindWord()
    var w = getWordAtCursor()
    findWordY = cursorLineIndex
    findWordX = cursorColIndex
    findWordUpY = cursorLineIndex
    findWordUpX = cursorColIndex - 1
    findWordDownY = cursorLineIndex
    findWordDownX = cursorColIndex + w.end
    
    if (w.word != "") {
      if (w.end == cursorColIndex) {
        findWordPrefix = w.word 
      } else {
        findWordX = w.start
        cursorLineIndex = w.start
        updateCursorXY()
      }
    }
  }
 
  // for loop to simulate goto
  for (var s=0; s<1; s++) {
    if (findWordCount == 0) {
      replaceFindWord([""])
      break
    }
    if (findWordCount == 1) {
      replaceFindWord(copyBuffer)
      break
    }
    if (findWordCount % 2 == 0) {
      var w = findWordUp()
      replaceFindWord([w.word])
      break 
    }
    var w = findWordDown()
    replaceFindWord([w.word])
    break 
  }  
  
  findWordCount += 1
  docChanged()
  render()
}


var lines = []
var logLines = []
var logShown = false
// the actual lines will be put here by the server
// LINES GO HERE
var contentLines = lines
var undoStack = [lines.join("\n")]
render()
// make sure when selecting in the margin
// that the selectMode is   line!
// bug with log and missing data??!
// add a threshold for move, like 5px or something.
</script>

