<!doctype html>
<html>
<head>
<script>
var proxyPath = ""
// PROXYPATH GOES HERE

var isGitBash = false
// ISGITBASH GOES HERE

</script>
<!--<meta name="viewport" content="width=device-width, initial-scale=1">
-->

<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, max-scale=1">
<meta name="apple-mobile-web-app-title" content="Editor">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

<meta charset='utf-8'>
<script>
document.write(`
<!-- For now not loading in third party diff library. -->
<!--<script src="`+proxyPath+`/tepublic/diff.js"></scr`+`ipt>-->
<script src="`+proxyPath+`/tepublic/md52.js"></scr`+`ipt>
<!-- For now not loading in grapheme splitter to save pageload. -->
<!-- it means we can't use emojis, other unicode chars for now -->
<!-- <script src="`+proxyPath+`/tepublic/grapheme-splitter.js"></scr`+`ipt>
 -->
`)
</script>
<style>
* {
    margin: 0; padding: 0;
    box-sizing: border-box;
}
.dark {
    background-color: black;
    color: white;
}
.light {
    background-color: lightyellow;
    -- background-color: white;
    color: black;
}
.text { border: none; color: cyan;
}


.fullWidth {
    width: 100%;
}


.toolbar {
    display: flex;
    flex-flow: row nowrap;
    overflow: scroll;
    -webkit-overflow-scrolling: touch;
}
.hidden {
   display: none;
}

body.dark .toolbar div {
    /* see renderDarkMode */
    color: rgba(255, 255, 200);
    border: 1px solid rgba(255, 255, 200);
    --opacity: 0.7;
}
body.dark .toolbar div.selected {
    background-color: gray;
    color: black;
    border: 1px solid black;
}
body.light .toolbar div {
    color: black;
    border: 1px solid black;
}
body.light .toolbar div.selected {
    background-color: black;
    color: rgba(255, 255, 200);
    border: 1px solid rgba(255, 255, 200);
}

.toolbar div {
    --border-radius: 17px;
}
.toolbar .square {
    padding: 0px;
    width: 40px;
    height: 34px;
    margin: 1px;
    flex: 1 0 auto;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}
.toolbar .longButton {
    padding: 0px;
    width: 80px;
    -- width: 60px;
    height: 34px;
    margin: 1px;
    flex: 1 0 auto;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}
.toolbar .middleButton {
    padding: 0px;
    width: 60px;
    height: 34px;
    margin: 1px;
    flex: 1 0 auto;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}

#fileRow div {
    font-size: 10px !important;
}

input[type="text"] {
    font-size: 16px;
    --border: 1px solid cyan;
    border: none;
}

#searchText {
    border: none;
}
#searchText::placeholder {
    --color: red;
    font-size: 10px;
}
#theText::placeholder {
    font-size: 12px;
}
</style>
</head>
<body class=dark>
<div id=topPadding style="height: 0px;"></div>
<div style="
    display: flex;
    flex-flow: row nowrap;
">
    <pre id=statusEl class=hidden style="overflow:scroll; font-size: 10px;">
    </pre>
    <div id=logEl class=hidden style="height: 450px; width:240px;
    overflow:scroll;
    -webkit-overflow-scrolling: touch;
    font-size:10px;"
    ></div>
</div>
<!-- status bar -->
<div id=s style="font-size: 12px;
display: none;
position: absolute;
top: 10px; right:0;
z-index: 999;
color: magenta;
opacity: 0.5;
"></div>

<form onsubmit="runEditorCommand(event)">
    <input class=fullWidth type=text id=editorCommandText
        style="display: none;
        font: 16px Courier;
        height: 24px;
        outline: none;
        "
        onfocus="focusEditorCommandText()"
        oninput="inputEditorCommandText()"
        onblur="blurEditorCommandText()"
    >

    <input class=dark type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>
<form onsubmit="findDownForm(event)">
    <input id=searchTextBefore class=fullWidth type=text
    style="
    font: 8px Courier;
    height:1px; overflow: hidden;
    display: block;"
    onfocus=handleSearchFocusBefore()
    xonblur=handleBlur()
    >

    <input class=fullWidth type=text id=searchText
        style="display: none;
        font: 16px Courier;
        height: 24px;
        outline: none;
        "
        onfocus="focusSearchText()"
        oninput="inputSearchText()"
        onblur="blurSearchText()"
    >

    <input id=searchTextAfter class=fullWidth type=text
    style="
    font: 8px Courier;
    height:1px; overflow: hidden;
    display: block;
    "
    onfocus=handleSearchFocusAfter()
    xonblur=handleBlur()
    >

    <input class=dark type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>

<form onsubmit="newLine(event, true)">

<input type=text id=theTextBefore class=fullWidth
style="
font: 8px Courier;
/* display: none; see what it looks like without */
height:1px; overflow: hidden;
display: block;"
onfocus=handleFocusBefore()
onblur=handleBlur()
>
<input id=theText class=fullWidth type=text
style="
font: 16px Times;
padding: 0;
color: brown;
height: 24px;
outline: none;
display: block;
"
onfocus=handleFocusIn()
onblur=handleBlur()
oninput=saveLine()
onkeydown=handleKeydown(event)
autocomplete="off"
>
<input type=text id=theTextAfter class=fullWidth
style="
font: 8px Courier;
/* display: none; see what it looks like without */
height:1px; overflow: hidden;
display: block;
"
onfocus=handleFocusAfter()
onblur=handleBlur()
>
<input class=dark type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>
<!--
Note that the css width needs to be 1/3 of
the with attribute, and same for height.
See canvasHeightFull
The width and height here are placeholders
They get changed later on.
-->
<div id=canvasWrapper style="position: relative;">
    <canvas id=c width=99 height=99
    style="width: 375px; height:10px;
    display: block;"
    ontouchstart=onStart(event)
    ></canvas>
    <div id="iframeContainer" style="position:absolute; top:0; left:0;">
        <div id="iframeCursor" style="z-index:100; position:absolute; top:0; left:0; border-radius: 5px; border: 1px solid black; width: 10px; height: 10px; background-color: white;">
        </div>
    </div>
</div>
<div class="toolbar xhidden" id=fileRow onclick=selectFileRow(event)>
</div>
<div class="toolbar hidden" id=terminalToolbar1 style="--display: none">
    <div class=middleButton onclick='sendTerminal("\x03"); event.preventDefault()'>^C</div>
    <div class=middleButton onclick='sendTerminal("git add -p"); event.preventDefault()'>-p</div>
    <!-- don't really need tab because touching the screen gets you tab-->
    <!--<div class=middleButton onclick='sendTerminal("\t"); event.preventDefault() '>tab</div>
    -->
    <div class=middleButton onclick=runScriptAndPasteButtonPress()>paste</div>
    <div class=middleButton id=slot1Button onclick='sendTerminal(slot1Input.value); event.preventDefault()'>slot 1</div>
    <div class=middleButton onclick='sendTerminal("\x1b[A"); event.preventDefault()'>up</div>
    <div class=middleButton id=slot2Button onclick='sendTerminal(slot2Input.value); event.preventDefault()'>slot 2</div>
    <div class=middleButton id=slot3Button onclick='sendTerminal(slot3Input.value); event.preventDefault()'>slot 3</div>
    <div class=middleButton onclick='sendTerminal("\x1b"); event.preventDefault()'>esc</div>
    <div class=middleButton onclick='ctrlDown = true; event.preventDefault()'>ctrl</div>
    <div class=middleButton onclick='sendTerminal("\x1b[B"); event.preventDefault()'>down</div>
    <div class=middleButton onclick='sendTerminal("\x1b[D"); event.preventDefault()'>left</div>
    <div class=middleButton onclick='sendTerminal("\x1b[C"); event.preventDefault()'>right</div>
</div>

<div class="toolbar hidden" id=iframeToolbar1 style="--display: none">
    <div class=square onclick="fx.iframe.contentWindow.location.reload()">refresh iframe</div>
</div>

<div class="toolbar hidden" id=workspaceToolbar onclick=selectWorkspaceToolbar(event) style="--display: none">
</div>

<div class="toolbar hidden" id=shellToolbar1 style="--display: none">
    <div class=square onclick=openAtCursor()>open</div>
    <div class=square onclick='runShellCommand("git diff")'>diff</div>
    <div class=square onclick='runShellCommand("git diff --cached")'>diff --cached</div>
    <div class=square onclick='readySameCommitAsBefore()'>commit -m</div>
    <div class=square onclick='runShellCommand("git push origin HEAD")'>push origin H</div>


    <!-- this one tries to make light backgroud, but doesn't work with mac sed.
    <div class=square onclick='runShellCommand("git add -u :/")'>add -u :/</div>
    <div class=square onclick='runShellCommand("git branch")'>branch</div>
    <div class=square onclick='runShellCommand("git status")'>status</div>
    <div class=square onclick='runShellCommand("rm coverage.out coverage.html; if go test -cover -coverprofile coverage.out ./...; then go tool cover -func=coverage.out; go tool cover -o=coverage.html -html=coverage.out; fi")'>gotest</div>
    <div class=square onclick='runShellCommand("rm coverage.out coverage.html; if go test -cover -coverprofile coverage.out ./...; then go tool cover -func=coverage.out; go tool cover -o=coverage.html -html=coverage.out; sed -i &apos;s/black;/white;/g&apos; coverage.html; fi")'>gotest</div>
    <div class=square onclick='insertText(["git commit -m &apos;&apos;"], 0, 15)'>commit -m</div>
    <div class=square onclick='insertText(["git checkout "], 0, -1)'>checkout</div>
    <div class=square onclick='insertText(["git checkout -b "], 0, -1)'>checkout -b</div>
    -->


</div>
<div class="toolbar hidden" id=shellToolbar2 style="--display: none">
    <!--
    <div class=square onclick='runShellCommand("git log -10")'>log -10</div>
    <div class=square onclick='runShellCommand("git log -p -3")'>log -p -3</div>
    <div class=square onclick='runShellCommand("cd ..")'>cd ..</div>
    <div class=square onclick='runShellCommand("git stash")'>stash</div>
    <div class=square onclick='runShellCommand("git stash pop")'> stash pop</div>
    <div class=square onclick='runShellCommand("git pull origin master")'>pull origin m</div>
    -->
</div>
<!--<div class="toolbar xhidden" id=fileRow ontouchstart=selectFileRow(event)>-->
<!--Select file row was here-->
<div class=toolbar>
    <div id=clearSearchButton class=square onclick=clearSearch()>clear search</div>
    <div class=square onclick=editSearch()>edit search</div>

    <div class=square onclick=closeFile()>close</div>
    <div id=saveButton class=square onclick=saveWrapper()>save</div>
    <div class=square onclick=seeFiles()>files</div>
</div>
<div class=toolbar>
    <div class=square onclick="osCopyText()">os copy</div>
    <div class=square onclick="osPasteText()">os paste</div>
    <div id=runScriptAndPasteButton class=square onclick=runScriptAndPasteButtonPress()>run script</div>
    <div class=square onclick=redo()>redo</div>
    <div class=square onclick=undo()>undo</div>
</div>
<div class=toolbar>
    <div class=square onmousedown="setCurrentFile(lastFile)" ontouchstart="setCurrentFile(lastFile); event.preventDefault(); event.stopPropagation()">alt tab</div>
    <div class=square onclick="duplicateFile(fx, -1)">dupl file</div>
    <div class=square onclick=addCmdTab()>cmd</div>
    <div class=square onclick=addTerminalTab()>xterm</div>
    <div class=square onclick=editEditorCommandText()>editor cmd</div>
    <div class=square onclick="deleteBelow();">del below</div>
</div>
<!-- Stuff after here is after the fold -->
<div class=toolbar>
    <div class=square onclick="copyBuffer = [location.href]; osCopyText()">copy url</div>
    <div class=square onclick="copyString(fx.fullPath + ':' + (fx.cursorLineIndex + 1))">copy path</div>
    <div class=square onclick="showDiff()">show diff</div>
    <div class=square onclick="setHighlightMatches()">set highlight</div>
    <div id=darkModeButton class=square onclick="toggleDarkMode()">light</div>
    <div class=square onclick=openAtCursor()>open</div>
    <div class=square onclick=scriptLines()>script lines</div>
</div>
<div class=toolbar>
    <div class=square onclick=debugView()>debug view</div>
    <div class=square onclick=doEval()>eval</div>
    <div class=square onclick="reloadAll()">reload all</div>
    <div class=square onclick="comment('--')">--</div>
    <div class=square onclick="clearTrailingWhitespace()">&times; tr whitespace</div>
    <div class=square onclick="searchText.value = getWordAtCursor().word; render();">highlight word</div>
    <div id=toggleTabStopButton class=square onclick="toggleTabStop()">tabs</div>
</div>
<div class=toolbar>
    <div class=square onclick=doFormat()>format</div>
    <div class=square onclick="toggleSeeTabs()">see tabs</div>
    <div class=square onclick="diffFiles()">diff files</div>
    <div id=darkModeButton class=square onclick="toggleCompactRender()">compact</div>
    <div class=square onclick="moveFileLeft()">move left</div>
    <div class=square onclick="moveFileRight()">move right</div>
    <div class=square onclick="stopServer()">stop server</div>
</div>
<div class=toolbar>
    <div class=square onclick="moveFileAllTheWayLeft()">move home</div>
    <div class=square onclick="downloadFile()">Download</div>
    <div class=square onclick="saveWorkspace()">save workspace</div>
    <div class=square onclick="location.href = proxyPath + '/login'">login</div>
    <div class=square onclick=urlAtCursor()>visit</div>
    <div class=square onclick="doRefresh()">refresh</div>
</div>
<div class=toolbar>
    <div class=square onclick="window.open(location.origin+location.pathname+'/saveload?browser=1&fullpath=' + encodeURIComponent(fx.fullPath))">open browser</div>
    <div class=square onclick="navigator.clipboard.writeText(location.origin+location.pathname+'/saveload?browser=1&fullpath=' + encodeURIComponent(fx.fullPath))">copy browser</div>
    <div class=square onclick="addIframe(location.origin+location.pathname+'/saveload?browser=1&fullpath=' + encodeURIComponent(fx.fullPath))">iframe browser</div>
    <div class=square onclick="doSizing(); render()">do sizing</div>
    <div class=square onclick=gotoDefinition()>goto def</div>
</div>
<div class=toolbar>
    <!--<div class=square onclick=addSpace()>space</div>
    <div class=square onclick=backspace()>backspace</div>
    <div class=square onclick="theText.focus()">insert</div>
    <div class=square onclick="newLine(null, false)">new line</div>

    <div class=square onclick=comment()>//</div>
    <div id=findUpButton class=square onclick=findUp()>find up</div>
    <div id=findDownButton class=square onclick=findDown()>find down</div>
    <div class=square onclick=clearLog()>clear log</div>
    <div class=square onclick=reloadFile(fx)>reload</div>

    -->
</div>
<div class=toolbar>
    <select onclick="selectFont('')">
    </select>
</div>
<div class=toolbar>
    <!--
        <div class=longButton onclick="selectFont('Monospace')">Monospace</div>
        <div class=longButton onclick="selectFont('Droid Sans Mono')">DSM</div>
    -->
    <div class=longButton onclick="selectFont('Menlo')">Menlo</div>
    <div class=longButton onclick="selectFont('VictorMono')">Victor Mono</div>
    <div class=longButton onclick="selectFont('VictorMonoMedium')">Victor Mono M</div>
    <div class=longButton onclick="selectFont('VictorMonoSemiBold')">Victor Semi Bold</div>
    <div class=longButton onclick="selectFont('AnonymousPro')">Anonymous Pro</div>
    <div class=longButton onclick="selectFont('AnonymousProBold')">Anonymous Pro Bold</div>
    <div class=longButton onclick="selectFont('SourceCodePro')">Source Code Pro</div>
    <div class=longButton onclick="selectFont('InputMonoLucida')">Input Mono L</div>
    <div class=longButton onclick="selectFont('InputMono')">Input Mono</div>
    <div class=longButton onclick="selectFont('Courier')">Courier</div>
    <div class=longButton onclick="selectFont('IosevkaLucida')">Iosevka L</div>
    <div class=longButton onclick="selectFont('IosevkaLucidaMedium')">Iosevka L Medium</div>
    <div class=longButton onclick="selectFont('IosevkaLucidaSemiBold')">Iosevka L SemiBold</div>
    <div class=longButton onclick="selectFont('IosevkaLucidaThin')">Iosevka L Thin</div>
    <div class=longButton onclick="selectFont('SFMono')">SF Mono</div>
    <div class=longButton onclick="selectFont('RobotoMono')">Roboto Mono</div>
    <div class=longButton onclick="selectFont('CourierThin')">Courier Thin</div>
    <div class=longButton onclick="selectFont('SFMonoThin')">SF Thin</div>
    <div class=longButton onclick="selectFont('IosevkaThin')">Iosevka Thin</div>
    <div class=longButton onclick="selectFont('Iosevka')">Iosevka</div>
    <div class=longButton onclick="selectFont('IosevkaSlab')">Iosevka S</div>
    <div class=longButton onclick="selectFont('XanhMono')">Xanh</div>
    <div class=longButton onclick="selectFont('Inconsolata')">Inconsolata</div>
    <div class=longButton onclick="selectFont('InconsolataThin')">Inconsolata Thin</div>
    <div class=longButton onclick="selectFont('Courier New')">Courier New</div>
    <div class=longButton onclick="selectFont('NanumGothicCoding')">Nanum GC</div>
    <div class=longButton onclick="selectFont('GillSans')">Gill Sans</div>
    <div class=longButton onclick="selectFont('AmericanTypewriter')">American T</div>
</div>
<div class=toolbar>
    <div class=longButton onclick="fontScale = 0.4; updateFontScale()">0.4</div>
    <div class=longButton onclick="fontScale = 0.5; updateFontScale()">0.5</div>
    <div class=longButton onclick="fontScale = 0.6; updateFontScale()">0.6</div>
    <div class=longButton onclick="fontScale = 0.7; updateFontScale()">0.7</div>
    <div class=longButton onclick="fontScale = 0.8; updateFontScale()">0.8</div>
    <div class=longButton onclick="fontScale = 0.9; updateFontScale()">0.9</div>
    <div class=longButton onclick="fontScale = 1.0; updateFontScale()">1.0</div>
    <div class=longButton onclick="fontScale = 1.1; updateFontScale()">1.1</div>
    <div class=longButton onclick="fontScale = 1.15; updateFontScale()">1.15</div>
    <div class=longButton onclick="fontScale = 1.2; updateFontScale()">1.2</div>
    <div class=longButton onclick="fontScale = 1.3; updateFontScale()">1.3</div>
    <div class=longButton onclick="fontScale = 1.4; updateFontScale()">1.4</div>
    <div class=longButton onclick="fontScale = 1.5; updateFontScale()">1.5</div>
    <div class=longButton onclick="fontScale = 1.6; updateFontScale()">1.6</div>
    <div class=longButton onclick="fontScale = 1.7; updateFontScale()">1.7</div>
    <div class=longButton onclick="fontScale = 2; updateFontScale()">2</div>
    <div class=longButton onclick="fontScale = 3; updateFontScale()">3</div>
    <div class=longButton onclick="fontScale = 4; updateFontScale()">4</div>
    <div class=longButton onclick="fontScale = 5; updateFontScale()">5</div>
</div>
<label for=allowPollingCheckbox>
    <input onchange="allowPolling = allowPollingCheckbox.checked" type=checkbox name=allowPollingCheckbox id=allowPollingCheckbox checked />
    allow polling
</label>
<label for=useUnicodeCheckbox>
    <input onchange="useUnicode = useUnicodeCheckbox.checked" type=checkbox name=useUnicodeCheckbox id=useUnicodeCheckbox checked />
    use unicode
</label>
<label for=agressiveRenderCheckbox>
    <input onchange="agressiveRender = agressiveRenderCheckbox.checked" type=checkbox name=agressiveRenderCheckbox id=agressiveRenderCheckbox />
    agressive render
</label>
<label for=saveDiffsCheckbox>
    <input onchange="saveDiffs = saveDiffsCheckbox.checked" type=checkbox name=saveDiffsCheckbox id=saveDiffsCheckbox checked />
    save diffs
</label>
<label for=showFilesFlatFirstCheckbox>
    <input onchange="showFilesFlatFirst = showFilesFlatFirstCheckbox.checked" type=checkbox name=showFilesFlatFirstCheckbox id=showFilesFlatFirstCheckbox checked />
    flat file list
</label>
<label for=bluetoothKeyboardCheckbox>
    <input onchange="bluetoothKeyboard = bluetoothKeyboardCheckbox.checked" type=checkbox name=bluetoothKeyboardCheckbox id=bluetoothKeyboardCheckbox />
    bluetooth keyboard
</label>
<br>
<label for=serverViewCheckbox>
    <input onchange="serverViewFeature = serverViewCheckbox.checked" type=checkbox name=serverViewCheckbox id=serverViewCheckbox />
    Screen Share
</label>
<br>
<label for=lockXCheckbox>
    <input onchange="lockX = lockXCheckbox.checked" type=checkbox name=lockXCheckbox id=lockXCheckbox />
    Lock X
</label>
<br>
<label for=reorderFilesCheckbox>
    <input onchange="reorderFiles = reorderFilesCheckbox.checked" type=checkbox name=reorderFilesCheckbox id=reorderFilesCheckbox />
    Auto-Reorder Files
</label>
<!--
<iframe width="100%" height=400 src="/te/screenshare"></iframe>
-->

<!-- These textareas are for if you are not on https and can't use osCopu and osPaste functions -->
<textarea class=dark id=pasteEl
style="width:100%; height:100px;"
onfocus="this.setSelectionRange(0, this.value.length)"
oninput=importPaste()
>when you add text here it will be copied</textarea>

<textarea class=dark id=copyEl
contenteditable
onfocus="this.setSelectionRange(0, this.value.length)"
style="width:100%; height:100px;"
    placeholder="when you copy something, it will show up here"
></textarea>
<input placeholder="slot 1" id=slot1Input onchange='localStorage.setItem("slot1", this.value); slot1Button.innerText = this.value;'/>
<input placeholder="slot 2" id=slot2Input onchange='localStorage.setItem("slot2", this.value); slot2Button.innerText = this.value;' />
<input placeholder="slot 3" id=slot3Input onchange='localStorage.setItem("slot3", this.value); slot3Button.innerText = this.value;' />
<form onsubmit=uploadFile(event)>
    Upload files:<br>
    <input id=filesToUpload type=file multiple>
    <input type=Submit value=Upload>
</form>
<a href=/>
<script>
document.write(`
<a href="`+proxyPath+`/tepublic/imageedit.html">Image Edit</a>
<a href="`+proxyPath+`/tepublic2/">Public 2</a>
<a href="`+proxyPath+`/screenshare">screenshare</a>
`)
</script>
<div id=bottomPadding style="height: 100px;"></div>
<div id=colorGetterEl style="width: 100px; height: 100px;"></div>
</div>

</div> <!-- end wrapper -->
<script>
// it's important that this go in it's own script tag
window.onerror = function(message, url, lineNumber, columnNumber, error) {
    alert(lineNumber + ": " + message)
}
</script>
<script>

slot1Input.value = localStorage.getItem("slot1")
slot1Button.innerText = localStorage.getItem("slot1") || "slot 1"
slot2Input.value = localStorage.getItem("slot2")
slot2Button.innerText = localStorage.getItem("slot2") || "slot 2"
slot3Input.value = localStorage.getItem("slot3")
slot3Button.innerText = localStorage.getItem("slot3") || "slot 3"
var t = c.getContext("2d")

var preventRender = true
// var saveDiffs = false
var saveDiffs = true
var totalViewBytesSent = 0
var totalViewRequests = 0
var saveEveryMS = 3000
var lastWord = ""
var lastCleared = ""
var fontScale = 1.2
var useUnicode = true
var emojiWidth = 2
var compactRender = false
var agressiveRender = false

var toolbars = document.querySelectorAll(".fullWidth")
for (var i=0; i<toolbars.length; i++) {
    var toolbar = toolbars[i]
    toolbar.style.width = innerWidth + "px"
}
var highlightText = "" // deprecated
var highlightMatchesSingleRegExp
var highlightMatches = []

var wordAtCursor = ""
var wordAtCursorRegexp = null


var fonts = {
    // "Monospace": {
    //     fontHeightPre: 36,
    //     fontWidthPre: 18,
    //     fontSize: 30,
    //     fontName: "monospace",
    // },
    // "Droid Sans Mono": {
    //     fontHeightPre: 36,
    //     fontWidthPre: 18,
    //     fontSize: 30,
    //     fontName: "Droid Sans Mono",
    // },
    "Courier": {
        fontHeightPre: 36,
        // fontWidthPre: 18,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "Courier",
    },
    "CourierThin": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "Courier",
    },
    "Courier New": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "Courier New",
    },
    "Menlo": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "Menlo",
    },
    "AmericanTypewriter": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "AmericanTypewriter",
    },
    "GillSans": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "GillSans",
    },
    "SFMono": {
        // I think this actually only works because we default to ui-monospace
        // SFMono seems to not be known
        fontHeightPre: 36,
        fontWidthPre: 17,
        fontSize: 30,
        // fontName: "ui-monospace",
        fontName: "SFMono",
    },
    "SFMonoThin": {
        // I think this actually only works because we default to ui-monospace
        // SFMono seems to not be known
        fontHeightPre: 36,
        fontWidthPre: 15,
        fontSize: 30,
        fontName: "SFMono",
    },
    "SourceCodePro": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "SourceCodePro",
        // url: "https://fonts.gstatic.com/s/sourcecodepro/v14/HI_QiYsKILxRpg3hIP6sJ7fM7PqlONvUlMIFxGC8.woff2"
        url: "https://fonts.gstatic.com/s/sourcecodepro/v14/HI_SiYsKILxRpg3hIP6sJ7fM7PqlPevWnsUnxg.woff2"
    },
    "InputMonoLucida": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "InputMonoLucida",
        url: proxyPath + "/tepublic/input_mono/input_mono_lucida.ttf"
    },
    "InputMono": {
        // fontHeightPre: 36,
        fontHeightPre: 40,
        fontWidthPre: 18.5,
        fontSize: 30,
        fontName: "InputMono",
        url: proxyPath + "/tepublic/input_mono/input_mono.ttf"
    },
    "AnonymousPro": {
        fontHeightPre: 36,
        fontWidthPre: 17,
        fontSize: 30,
        fontName: "AnonymousPro",
        url: "https://fonts.gstatic.com/s/anonymouspro/v14/rP2Bp2a15UIB7Un-bOeISG3pHls29QP-4Ks.woff2"
    },
    "AnonymousProBold": {
        fontHeightPre: 36,
        fontWidthPre: 17,
        fontSize: 30,
        fontName: "AnonymousProBold",
        url: "https://fonts.gstatic.com/s/anonymouspro/v14/rP2cp2a15UIB7Un-bOeISG3pFuAT4C7c7YGx0Ks.woff2"
    },
    "VictorMono": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "VictorMono",
        url: proxyPath + "/tepublic/victor_mono/victor_mono.ttf"
    },
    "VictorMonoMedium": {
        fontHeightPre: 36,
        // fontWidthPre: 17,
        fontWidthPre: 17.5,
        fontSize: 30,
        fontName: "VictorMonoMedium",
        url: proxyPath + "/tepublic/victor_mono/victor_mono_medium.ttf"
    },
    "VictorMonoSemiBold": {
        fontHeightPre: 36,
        // fontWidthPre: 17,
        fontWidthPre: 17.5,
        fontSize: 30,
        fontName: "VictorMonoSemiBold",
        url: proxyPath + "/tepublic/victor_mono/victor_mono_semibold.ttf"
    },
    "RobotoMono": {
        fontHeightPre: 36,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "RobotoMono",
        url: "https://fonts.gstatic.com/s/robotomono/v13/L0xuDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vq_ROW4AJ68SA.woff2"
    },
    "NanumGothicCoding": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "NanumGothicCoding",
        url: "https://fonts.gstatic.com/s/nanumgothiccoding/v14/8QIVdjzHisX_8vv59_xMxtPFW4IXROwsy6ExUM1WtMRe4NStuSM4eXtk7e0M06IfTaI.119.woff2"
    },
    "IosevkaLucida": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucida",
        // TODO: fix url/path etc
        // url: "http://tel.drewles.com:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
        //url: "http://192.168.0.21:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
        url: proxyPath + "/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
    },
    "IosevkaLucidaMedium": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucidaMedium",
        url: proxyPath + "/tepublic/iosevka_lucida/iosevka-fixed-ss13-medium.ttf"
    },
    "IosevkaLucidaSemiBold": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucidaSemiBold",
        url: proxyPath + "/tepublic/iosevka_lucida/iosevka-fixed-ss13-semibold.ttf"
    },
    "IosevkaLucidaThin": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucidaThin",
        url: proxyPath + "/tepublic/iosevka_lucida/iosevka-fixed-ss13-thin.ttf"
    },
    "IosevkaThin": {
        fontHeightPre: 36,
        // fontWidthPre: 13.5,
        fontWidthPre: 14,
        fontSize: 30,
        fontName: "IosevkaThin",
        url: "http://192.168.0.21:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
    },
    "Iosevka": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "Iosevka",
        url: "http://tel.drewles.com:8000/tepublic/iosevka/iosevka-fixed-regular.ttf"
    },
    "IosevkaSlab": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaSlab",
        url: "http://tel.drewles.com:8000/tepublic/iosevka_slab/iosevka-fixed-slab-regular.ttf"
    },

    "Inconsolata": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "Inconsolata",
        url: "https://fonts.gstatic.com/s/inconsolata/v21/QlddNThLqRwH-OJ1UHjlKENVzlm-WkL3GZQmAwPyya15IDhunA.woff2"
    },
    // https://usefulangle.com/post/74/javascript-dynamic-font-loading
    "InconsolataThin": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "InconsolataThin",
        descriptors: {
            // because inconsolata has this special property
            // feature not working?
            stretch: "70%",
        },
        url: "https://fonts.gstatic.com/s/inconsolata/v21/QlddNThLqRwH-OJ1UHjlKENVzlm-WkL3GZQmAwPyya15IDhunA.woff2"
    },
    "XanhMono": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "XanhMono",
        url: "https://fonts.gstatic.com/s/xanhmono/v4/R70YjykVmvKCep-vWhSonwqRfTHxTw.woff2"
    },
    "Fake": {
        fontHeightPre: 36,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucida",
        // TODO: fix url/path etc
        url: "http://192.168.0.21:8000/tepublic/notreal.ttf"
    },
}

// this gets changes later down.
// Just need to set some variables I guess
currentFont = fonts["Courier"]
setFontVars()

// currentFont = fonts["SFMono"]
// https://medium.com/@caulfieldOwen/programming-fonts-a-visual-guide-567fc210d2c6
// https://vfoley.xyz/lesser-known-coding-fonts/
// https://www.programmingfonts.org/#iosevka

var showFilesFlatFirst = true
// var bluetoothKeyboard = false
var bluetoothKeyboard = false

var lastFile = fx
// not using indexes so we can move files around without worrying about the indexes
// It means we'll have to use files.indexOf in various places
    // var currentFileIndex = 0
    // var lastFileIndex = 0

var reorderFiles = false

var lockX = false
var fontColor = "white"
var lightFontColor = "rgba(255, 255, 255, 0.5)"
var veryLightFontColor = "rgba(255, 255, 255, 0.1)"
var isDark = true
var workspaceName = ""
var cursorX=0
var cursorY=0
// 4 chars for line number and 1 for space
var marginLeft = 6
// var marginLeft = 50
// Note that the width and height need to match
// the width and height of the canvas tag attribute.

var canvasWidth
var canvasHeightFull
var canvasHeightKeyboard
var navTouchSize
var device = "iphone12mini"
var canvasHeightShell
var canvasHeightTerminal
var canvasHeightIframe
var canvasHeightKeyboardTerminal
var maxLines
var maxCols
var canvasHeight
function doSizing() {
    canvasWidth=innerWidth * 3
    // TODO: make these configurable in UI
    canvasHeightFull=1710 - (36*3*1) // extra button row now
    // I turned off "Predictive" to get more vertical space
    // canvasHeightKeyboard=1200 
    canvasHeightKeyboard=1060 
    navTouchSize = 40
    device = "iphone12mini"

    // landscape mode
    if (innerWidth > innerHeight) {
        canvasHeightFull = 575 - (36*3*1) 
        canvasHeightKeyboard = 400 
        navTouchSize = 60
    }


    // This condition for the 2021 iPad mini
    if (screen.width == 744 && screen.height == 1133) {
        device = "ipad6"
        canvasHeightFull = 2750 - (36*3*1)
        canvasHeightKeyboard = 2200 
        navTouchSize = 60
        // alert(innerWidth + ", " + innerHeight)
        // warning if the page is zoomed the numbers will be off
        // if ipad is in landscape mode at 100% zoom, saved to homescreen
        // innerWidth is 1133
        // innerHeight is 720

        // if ipad is in landscape mode at 100% zoom, not saved to homescreen, with compact browsing mode
        // innerWidth is 1133
        // innerHeight is 665

        // Simple detection for landscape
        if (innerWidth > innerHeight) {
            canvasHeightFull = 1600 - (36*3*1)
            canvasHeightKeyboard = 800
            navTouchSize = 100
        }
    }
    c.style.width = innerWidth + "px"
    c.width = canvasWidth
    c.height = canvasHeightFull
    // var canvasHeightKeyboardTerminal=canvasHeightKeyboard-(36*3*1)
    // TODO: clean this special case up. changed so files always show. bit now it needs 2 rows
    // ok now back to 1 row
    canvasHeightKeyboardTerminal=canvasHeightKeyboard-(36*3*2)
    // canvasHeightKeyboardTerminal=canvasHeightKeyboard-(36*3*1)

    // 34 button height plus 1px*2 margin
    // 2 rows of new buttons for shell
    // var canvasHeightShell = canvasHeightFull - ((36*3) * 2)
    // var canvasHeightTerminal = canvasHeightFull - ((36*3) * 1)
    // var canvasHeightIframe = canvasHeightFull + ((36*3) * 2)

    // experiment with keeping height
    canvasHeightShell = canvasHeightFull
    canvasHeightTerminal = canvasHeightFull
    canvasHeightIframe = canvasHeightFull

    setCanvasHeight(canvasHeightFull)
    setCanvasWidth(canvasWidth)
}
doSizing()

function deleteBelow() {
    if (fx.fileMode == "terminal") {
        clearLog()
    } else {
        setLines(fx.lines.slice(0, fx.cursorLineIndex))
    }
    docChanged()
    render()
}

window.onorientationchange = function(event) {
    doSizing()
    render()
    // seems that we need to double check in a few milliseconds
    setTimeout(function(){
        doSizing()
        render()
    }, 500)
};



var touchScaleY = 2 // was 3 for a while, then 2 for a while
var touchScaleX = 2 // was 3 for a while, then 2 for a while
// #snappingCursor 3
// var touchScaleX = 1 // 1 now because of snapping

var lastAction = "move" // move or type
var lastSearchDirForSameTerm = "" // up or down or ""
var lastSearchMatchLength = 0
var hasMovedSinceNewLine = false
var inEdit = false
var copyBuffer = []
var copyBuffer2 = []
var cutBuffer = []
var selectMode = "line"
var selectAction
var cursorType = "move"
// cursorType can be
// * move
// * select

var theStatus = {}

// note: fileMode can be
// * file
// * shell (like a terminal lite)
// * fileList
// * directory
// * terminal
var knownContrastingColors = {}
// if last keyDown is a backspace
var wasWasDelete = false
var wasDelete = false
var moveHomeEndTimeout
var moveHomeEndTimeoutMillis = 300
var moveHomeEndDirection
var selectTimeout
var selectTimeoutMillis = 400
var moveListenerCount = 0
var endListenerCount = 0
var startListenerCount = 0
var autoSave = false
var lastPageYOffset = 0
var originalCanvasHeightFull = canvasHeightFull
var scrollTimeout
var useRegexSearch = true
// TODO: as you add or delete lines
// go thru these locations and update them
// selectFont("IosevkaLucida")
// selectFont("Courier")

// Using menlo while in poor intetnet situation to save space
selectFont("Menlo")

var hasDoneOverflowYAction = false
var alternateTap = true // the false doesn't even fully work anymore
// it was the tap to cut flow. we can maybe bring that back even with alternate tap
function osCopyText() {
    navigator.clipboard.writeText(copyBuffer.join("\n")).then(function() {
    }, function() {
        alert("not copied")
    })
}
function osPasteText() {
    navigator.clipboard.readText().then(function(text) {
        copyBuffer = text.split("\n")
    }, function(e) {
        alert("not copied: " + e)
    })
}
function doRefresh() {
    saveWorkspace().then(function() {
        location.reload()
    })
}

function getAbsoluteURL(baseURL, newURL) {
    baseURLParsed = new URL(baseURL)
    // TODO add ? and #
    if (newURL.startsWith("https://") || newURL.startsWith("http://")) {
        return newURL
    } else if (newURL.startsWith("//")) {
        return baseURLParsed.protocol + newURL
    } else if (newURL.startsWith("/")) {
        return baseURLParsed.origin + newURL
    } else {
        var pathPart = baseURLParsed.pathname.split("/").slice(0, -1).join("/")
        var finalURL = baseURLParsed.origin + pathPart + "/" + newURL
        return finalURL
    }
}
var iframeScale = .75
function addIframe(url, id, name, cwd) {
    // var f = makeFile(url, 0, "")
    var f = makeFile(url, 0, "")
    f.fileMode = "iframe"

    if (id) {
        f.ID = id
    }
    if (cwd) {
        f.shellCWD = cwd
    }
    if (name) {
        f.name = name
    }
    f.iframeCursorX = 0
    f.iframeCursorY = 0
    var iframeWrapper = document.createElement("div")
    var iframe = document.createElement("iframe")
    iframe.src = url
    // iframe.sandbox = "allow-same-origin allow-scripts allow-popups allow-forms"
    // iframe.setAttribute("sandbox", "allow-same-origin allow-scripts allow-popups allow-forms")
    iframe.currentElement = document.createElement("div")
    iframe.onload = function() {
        iframe.contentWindow.document.body.style.transform = "scale("+iframeScale+")"
        iframe.contentWindow.document.body.style.transformOrigin = "top left"


        // iframe.style.width = (1200 * .75) + "px"
        // iframe.style.height = (1000 * .75)+"px"
        // iframe.style.transform = "scale(.75)"
        // iframe.style.transformOrigin = "top left"
        // iframe.style.width = (1200 / .75) + "px"
        // iframe.style.height = (1000 / .75)+"px"


        f.fullPath = iframe.src
        saveWorkspace()
        var openFunction = function(url) {
            // TODO add ? and #
            // if (url.startsWith("https://") || url.startsWith("http://")) {
            //     parent.addIframe(url)
            // } else if (url.startsWith("//")) {
            //     parent.addIframe(iframe.contentWindow.location.protocol + url)
            // } else if (url.startsWith("/")) {
            //     parent.addIframe(iframe.contentWindow.location.origin + url)
            // } else {
            //     var pathPart = iframe.contentWindow.location.pathname.split("/").slice(0, -1).join("/")
            //     var finalURL = iframe.contentWindow.location.origin + pathPart + "/" + url
            //     parent.addIframe(finalURL)
            // }
            var finalURL = getAbsoluteURL(iframe.contentWindow.location, url)
            parent.addIframe(finalURL)
        }

        iframe.contentWindow.open = openFunction
        var handleClick = function(e) {
            e.preventDefault()
            openFunction(e.currentTarget.getAttribute("data-te-href"))
            return false
        }

        var oldSubmit = iframe.contentWindow.HTMLFormElement.prototype.submit
        iframe.contentWindow.HTMLFormElement.prototype.submit = function() {
            var newIframe = addIframe("about:blank")
            this.removeAttribute("target")
            this.action = getAbsoluteURL(iframe.contentWindow.location, this.action)
            newIframe.iframe.contentWindow.document.body.appendChild(this)
            oldSubmit.call(this)
            this.teModified = true
            return false
        }


        // hacky
        var replaceLinks = function() {
            var aTags = iframe.contentWindow.document.querySelectorAll("a")
            for (let i=0; i<aTags.length; i++) {
                let aTag = aTags[i]
                if (aTag.hasAttribute("target") && !aTag.hasAttribute("onclick") && !aTag.hasAttribute("data-te-href")) { // TODO: better handling
                    let href = aTag.getAttribute("href")
                    // log("link: " + href)
                    aTag.onclick = handleClick
                    aTag.removeAttribute("href")
                    aTag.setAttribute("data-te-href", href)
                    aTag.style.border = "1px solid hotpink"
                }
            }
            // var formTags = iframe.contentWindow.document.querySelectorAll("form")
            // for (let i=0; i<formTags.length; i++) {
            //     let formTag = formTags[i]
            //     if (formTag.hasAttribute("target") && !formTag.hasAttribute("onsubmit")) { // TODO: better handling
            //         let action = formTag.getAttribute("action")
            //         formTag.onsubmit = handleSubmit
            //         formTag.removeAttribute("target")
            //         formTag.style.border = "1px solid lime"
            //     }
            // }
        }
        replaceLinks()

        const config = { attributes: false, childList: true, subtree: true };
        const callback = function(mutationsList, observer) {
            // log("changed")
            // TODO: only change the modified ones, also you may need to look at attribute changes
            replaceLinks()
        };
        const observer = new MutationObserver(callback);
        observer.observe(iframe.contentWindow.document.body, config);


    }
    iframe.onerror = function() {
        window.open(iframe.src)
    }
    iframeWrapper.style.position = "absolute"
    // iframeWrapper.style.width = (innerWidth - (navTouchSize*2)) + "px"
    // iframeWrapper.style.left = navTouchSize + "px"

    iframeWrapper.style.width = (innerWidth) + "px"

    iframeWrapper.style.height = (canvasHeightIframe*.7/3) + "px"
    iframeWrapper.style.display = "none"
    iframeWrapper.style.overflow = "scroll"
    iframe.style.border = "none"
    iframe.style.backgroundColor = "white"



    iframe.style.width = "1400px"
    iframe.style.height = "1000px"
    iframeWrapper.appendChild(iframe)
    iframeContainer.appendChild(iframeWrapper)
    f.iframe = iframe
    f.iframeWrapper = iframeWrapper
    addFileToList(f)
    setCurrentFile(f)

    // TODO: in future can we handle the id creation on the client side for less overhead?
    if (!id) {
        fetch(proxyPath + "/myaddfile?fileType=iframe&fullPath="+encodeURIComponent(url), {
            cache: "no-cache"
        }).then(r => {
            if (r.headers.get("X-ID")) {
                f.ID = r.headers.get("X-ID") - 0
            }
        }).catch(e => {
            alert("Error adding iframe " + e)
        })

    }
    return f
}

function showDiff() {
    var start = Date.now()
    var contents = simpleDiffOld3(fx.undo.lastSavedLines, fx.lines, false).join("\n")
    log("diff3: " + (Date.now()-start))
    var f3 = makeFile("__diffOld3", 0, contents)
    f3.fileMode = "file"
    f3.cursorLineIndex = 0
    addFileToList(f3)
    setCurrentFile(f3)

    // For now we don't load in the third party diff algorithm
    // var oldContents = fx.undo.lastSavedLines.join("\n")
    // var newContents = fx.lines.join("\n")
    // var start = Date.now()
    // var contents = Diff.createPatch("foo", oldContents, newContents, "", "", {context:0})
    // log("diffM: " + (Date.now()-start))
    // var f4 = makeFile("__diffMyers", 0, contents)
    // f4.fileMode = "file"
    // f4.cursorLineIndex = 0
    // addFileToList(f4)
    // setCurrentFile(f4)

    setCurrentFile(f3)
    updateCursorXY()
    ensureCursorInScreen()
}

// heuristical
function simpleDiffOld3(aLines, bLines, showSame) {
    var aLastMatched = -1
    var bLastMatched = -1
    var ai = -1
    var bi = -1

    // TODO: you can handle a bit better when it gets to the end for one?
    // NOTE: this is my experimenting with diff. likely not fastest or most
    // efficient. For example I don't get largest common substring.
    // max 1000000 line diff
    // this has large issues, see scratch5
    // one thing we can do to improve is another pass where we optimize this output.
    // or just implement the Myers diff algorithm and compare speed
    var ret = []
    lastMatched = true
    outerLoop:
    for (var i=0; i<1000000; i++) {
        ai += 1
        bi += 1
        if (ai >= aLines.length && bi >= bLines.length) {
            break
        }
        var aLine = aLines[ai]
        for (var b=bLastMatched+1; b<=bi; b++) {
            var bLine = bLines[b]
            if (aLine != bLine) {
                continue
            }
            if (!lastMatched) {
               // use a hash for this?
               var trimmed = (aLine || "").trim()
               if (trimmed == "") {
                   continue
               }
               if (trimmed == "}") {
                   continue
               }
               if (trimmed.startsWith == "/>") {
                   continue
               }
               if (trimmed == "break") {
                   continue
               }
               if (trimmed == "continue") {
                   continue
               }
               if (trimmed == "return") {
                   continue
               }
            }
            lastMatched = true
            if (!showSame && (aLastMatched+1<ai || bLastMatched+1<b)) {
                ret.push("@@ -" + (aLastMatched+2) + " @@")
            }
            for (var a=aLastMatched+1; a<ai; a++) {
                ret.push("-" + aLines[a])
            }
            for (var b2=bLastMatched+1; b2<b; b2++) {
                ret.push("+" + bLines[b2])
            }
            aLastMatched = ai
            bLastMatched = b
            bi = b
            if (showSame) {
                ret.push(" " + aLines[ai])
            }
            continue outerLoop
        }

        var bLine = bLines[bi]
        for (var a=aLastMatched+1; a<=ai-1; a++) {
            var aLine = aLines[a]
            // if (aLine == bLine) {
            if (aLine != bLine) {
                continue
            }
            if (!lastMatched) {
               // use a hash for this?
               var trimmed = (aLine || "").trim()
               if (trimmed == "") {
                   continue
               }
               if (trimmed == "}") {
                   continue
               }
               if (trimmed.startsWith == "/>") {
                   continue
               }
               if (trimmed == "break") {
                   continue
               }
               if (trimmed == "continue") {
                   continue
               }
               if (trimmed == "return") {
                   continue
               }
            }
            lastMatched = true
            if (!showSame && (aLastMatched+1<a || bLastMatched+1<bi)) {
                ret.push("@@ -" + (aLastMatched+2) + " @@")
            }
            for (var a2=aLastMatched+1; a2<a; a2++) {
                ret.push("-" + aLines[a2])
            }
            for (var b=bLastMatched+1; b<bi; b++) {
                ret.push("+" + bLines[b])
            }
            if (showSame) {
                ret.push(" " + bLines[bi])
            }
            aLastMatched = a
            bLastMatched = bi
            ai = a
            continue outerLoop
        }

        lastMatched = false
    }
    if (i == 1000000) {
        alert("likely a bug with diff code")
    }

    // any left over
    if (!showSame && (aLastMatched+1<aLines.length || bLastMatched+1<bLines.length)) {
        ret.push("@@ -" + (aLastMatched+2) + " @@")
    }
    if (aLastMatched + 1 < aLines.length) {
        for (var aR=aLastMatched+1; aR<aLines.length; aR++) {
            ret.push("-" + aLines[aR])
        }
    }
    if (bLastMatched + 1 < bLines.length) {
        for (var bR=bLastMatched+1; bR<bLines.length; bR++) {
            ret.push("+" + bLines[bR])
        }
    }
    return ret
}

function getAtCursor() {
    if (fx.cursorLineIndex >= fx.lines.length) {
        return
    }
    var line = fx.lines[fx.cursorLineIndex]
    var strIndex = u(fx.cursorColIndex)
    for (var i=strIndex; i>=0; i--) {
        // if ((line.charAt(i).trim() == "")) {
        // log(line.charAt(i) + " " + line.charCodeAt(i))
        if (line.charCodeAt(i) <= 32) {
            break
        }
    }
    i += 1
    for (var j=strIndex+1; j<line.length; j++) {
        if (line.charCodeAt(j) <= 32) {
            break
        }
    }
    return line.slice(i, j)
}

function openAtCursor() {
    var path = getAtCursor()
    if (fx.fileMode == "shell") {
        var fileName = trimPrefix(fx.shellCWD, rootLocation) + "/" + path
    } else if (fx.fileMode == "terminal") {
        // TODO: how do we know what the cwd is?
        // isn't there a way to get the cwd of a running process?
    } else if (path.startsWith("/")) {
        var fileName = path
    } else {
        var parts = fx.fullPath.split("/")
        var basePath = parts.slice(0, -1).join("/")
        var fileName = basePath + "/" + path
    }
    log("opening file from cursor")
    addFile(fileName)
}

function urlAtCursor() {
    var url = getAtCursor()
    open(url)
}

function addSpace() {
    if (fx.cursorLineIndex >= fx.lines.length) {
        return
    }
    var line = fx.lines[fx.cursorLineIndex]
    updateLine(-1, line.slice(0, u(fx.cursorColIndex)) + " " + line.slice(u(fx.cursorColIndex)))
    fx.cursorColIndex += 1
    updateCursorXY()
    docChanged()
    render()
}

function backspace() {
    if (fx.cursorLineIndex >= fx.lines.length) {
        return
    }
    var line = fx.lines[fx.cursorLineIndex]
    if (fx.cursorColIndex == 0) {

        return
    }
    // fx.lines[fx.cursorLineIndex] = line.slice(0, u(fx.cursorColIndex) - 1) + line.slice(u(fx.cursorColIndex))
    updateLine(fx.cursorLineIndex, line.slice(0, u(fx.cursorColIndex) - 1) + line.slice(u(fx.cursorColIndex)))
    fx.cursorColIndex = expandTabIndex(line, u(fx.cursorColIndex - 1))
    docChanged()
    updateCursorXY()
    render()
}
function selectFont(fontName) {
    currentFont = fonts[fontName] || fonts["Courier"]
    if (currentFont.url) {
        var font
        if (currentFont.descriptors) {
            font = new FontFace(fontName, "url(" + currentFont.url + ")")
        } else {
            font = new FontFace(fontName, "url(" + currentFont.url + ")", currentFont.descriptors)
        }
        font.load().then(function(loaded){
            document.fonts.add(loaded)
            whenFontReady(fontName)
        }).catch(function(e){
            alert(e)
        })
    } else {
        // assuming we have this font
        whenFontReady(fontName)
    }
}

function whenFontReady(fontName) {
    editorCommandText.style.fontFamily = fontName
    searchText.style.fontFamily = fontName
    theText.style.fontFamily = fontName
    log("calling updateFontScale")
    updateFontScale()
}

function updateFontScale() {
    if (!fontScale) {
        fontScale = 1
    }
    setFontVars()
    setCanvasHeightAccordingly()
    setCanvasWidth(canvasWidth)
    render()
}
function setFontVars() {
    fontHeight = currentFont.fontHeightPre * fontScale
    fontWidth = currentFont.fontWidthPre * fontScale
    // fontCSS = (currentFont.fontSize * fontScale) + "px '"+currentFont.fontName+"', ui-monospace"
    // fontCSS = (currentFont.fontSize * fontScale) + "px 'Courier', ui-monospace"
    // fontCSS = (currentFont.fontSize * fontScale) + "px ui-monospace"
    // after experimentation, there seems to be a bug in ios 15 where if we use the ui-monospace font
    // which would render SF Mono before, but now
    // causes the page to crash
    fontCSS = (currentFont.fontSize * fontScale) + "px '"+currentFont.fontName+"'"
    fontCSSTiny = (currentFont.fontSize * fontScale/2) + "px '"+currentFont.fontName+"'"
    fontCSSEmoji = (currentFont.fontSize * fontScale * .6 * emojiWidth) + "px '"+currentFont.fontName+"', ui-monospace"
    // extraYEmoji = (currentFont.fontSize * fontScale * .6) / 2 / emojiWidth
    extraYEmoji = 0
}


function importPaste() {
    copyBuffer = pasteEl.value.split("\n")
    selectMode = "line"
}

function toggleDarkMode() {
    isDark = !isDark
    renderDarkMode()
}

var lighModeFontColor = "black"
var darkModeFontColor = "rgba(255, 255, 200, 1)"
var lineNumberColor = "brown"
function renderDarkMode() {
    if (!isDark) {
        darkModeButton.innerText = "dark"
        document.body.classList.remove("dark")
        document.body.classList.add("light")
        updateClassForSelector("input", "dark","light")
        updateClassForSelector("textarea", "dark","light")
        fontColor = lighModeFontColor
        lightFontColor = "rgba(0, 0, 0, 0.5)"
        veryLightFontColor = "rgba(0, 0, 0, 0.1)"
        render()
        renderURL()
        return
    }
    darkModeButton.innerText = "light"
    document.body.classList.remove("light")
    document.body.classList.add("dark")
    updateClassForSelector("input", "light", "dark")
    updateClassForSelector("textarea", "light", "dark")
    // fontColor = "white"
    // fontColor = "rgba(100, 255, 100)"
    // fontColor = "rgba(255, 255, 200)"
    fontColor = darkModeFontColor
    // fontColor = "deeppink"
    // fontColor = "pink"

    lightFontColor = "rgba(255, 255, 255, 0.5)"
    veryLightFontColor = "rgba(255, 255, 255, 0.1)"
    render()
    renderURL()
}
function updateClassForSelector(selector, remove, add) {
    var inputs = document.querySelectorAll(selector)
    for (var i=0; i<inputs.length; i++) {
        var input = inputs[i]
        input.classList.remove(remove)
        input.classList.add(add)
    }
}
function runEditorCommand(e) {
    e.preventDefault()
    // editorCommandText.style.display = "none"
    var parts = editorCommandText.value.split(" ")
    if (parts.length == 0) {
        return false
    }
    var cmd = parts[0]
    var rest = parts.slice(1).join(" ")

    switch (cmd) {
    case "ccol": // change color
        var fromColor = parts[1]
        var toColor = parts[2]
        for (var i=0; i<files.length; i++) {
            var theFile = files[i]
            if (theFile.color == fromColor) {
                theFile.color = toColor
            }
        }
        renderFileDropdown()
        saveWorkspace()
        break
    case "color":
        while (true) { // my hack to break wherever I want
            if (fx.fileMode == "fileList") {
                if (fx.selectedRegions.length>0) {
                    var r = fx.selectedRegions[0]
                    // we subtract 1 because of the initial "-" at the beginning
                    var fileIndexStart = r.startY - 1
                    var fileIndexStop = r.stopY - 1
                    for (var i=fileIndexStart; i<= fileIndexStop; i++) {
                        files[i].color = rest
                    }
                }
            }
            break
        }
        fx.color = rest
        // TODO: you could have a custom function that just sets the color
        render()
        renderFileDropdown()
        saveWorkspace()
        break
    case "group":
        while (true) { // my hack to break wherever I want
            if (fx.fileMode == "fileList") {
                if (fx.selectedRegions.length>0) {
                    var r = fx.selectedRegions[0]
                    // we subtract 1 because of the initial "-" at the beginning
                    var fileIndexStart = r.startY - 1
                    var fileIndexStop = r.stopY - 1
                    for (var i=fileIndexStart; i<= fileIndexStop; i++) {
                        files[i].group = rest
                    }
                }
            }
            break
        }
        fx.group = rest
        render()
        renderFileDropdown()
        saveWorkspace()
        break
    case "name":
        fx.name = rest
        // TODO: could you also call saveName?
        saveWorkspace()
        renderFileDropdown()
        break
    case "so":
        fx.seeOnly = rest
        render()
        break
    case "sox":
        fx.seeOnly = ""
        render()
        break
    // foreground light
    case "fgl":
        lighModeFontColor = rest || "black"
        renderDarkMode()
        break
    // foreground light
    case "fgd":
        darkModeFontColor = rest || "white"
        renderDarkMode()
        break
    // line number color
    case "lnc":
        lineNumberColor = rest || "brown"
        render()
        break
    // background light
    case "bgl":
        var rules = document.styleSheets[0].cssRules
        for (var i=0; i<rules.length; i++) {
            var rule = rules[i]
            if (rule.selectorText == ".light") {
                rule.style.backgroundColor = rest || "#ddf"
            }
        }
        break
    // background dark
    case "bgd":
        var rules = document.styleSheets[0].cssRules
        for (var i=0; i<rules.length; i++) {
            var rule = rules[i]
            if (rule.selectorText == ".dark") {
                rule.style.backgroundColor = rest || '#002'
            }
        }
        break
    case "wname":
        // for now just going by name
        var oldWorkspaceName = workspaceName
        var currentWorkspace = workspacesList.find(function (w) {
            return w.Name == workspaceName
        })
        if (currentWorkspace) {
            currentWorkspace.Name = rest
        }
        workspaceName = rest
        saveWorkspace(oldWorkspaceName)
        renderFileDropdown()
        break
    case "copyurl":
        copyBuffer = [location.href]
        break
    case "reloadall":
        reloadAll()
        break
    case "reload":
        reloadFile()
        break
    case "light":
        toggleDarkMode()
        break
    case "dark":
        toggleDarkMode()
        break
    case "copypath":
        copyString(fx.fullPath + ':' + (fx.cursorLineIndex + 1))
        break
    case "js":
        // see also runScript
        var oldCopyBuffer = copyBuffer
        var f = new Function(code)
        var ret = f()
        ret = ret + ""
        copyBuffer = ret.split("\n")
        paste()
        copyBuffer = oldCopyBuffer
        break
    case "e":
        var resp = eval(rest)
        alert(resp)
        break
    case "script":
    case "s":
        // see also scriptLines
        scriptLinesWithOneLineScript(rest)
        break
    case "r":
        scriptLinesWithOneLineScript(editorCommandText.value)
    case "l":
        scriptLinesWithOneLineScript(editorCommandText.value)
        break
    case "hl":
        searchText.value = getWordAtCursor().word; render();
        break
    case "h":
        if (fx.selectedRegions.length == 0) {
            break
        }
        var r = fx.selectedRegions[0]
        if (!fx.highlightRanges) {
            // TODO: Figure out why this is
            fx.highlightRanges = []
        }
        fx.highlightRanges.push({
            StartY: r.startY,
            StartX: r.startX,
            StopY: r.stopY,
            StopX: r.stopX,
            BackgroundColor: rest || "deeppink"
        })
        saveWorkspace()
        render()
        break
    case "hx":
        highlightRanges = []
        for (var i=0; i<fx.highlightRanges.length; i++) {
            var r = fx.highlightRanges[i]
            log([fx.cursorLineIndex, r])
            if (fx.cursorLineIndex >= r.StartY && fx.cursorLineIndex <= r.StopY) {
                // skip
            } else {
                highlightRanges.push(r)
            }
        }
        fx.highlightRanges = highlightRanges
        saveWorkspace()
        render()
        break
    // case "h":
    //     // if (!rest && fx.selectedRegions.length) {
    //     //     rest = getSelectedLines(fx, false).lines[0]
    //     // }
    //     if (!rest) {
    //         rest = copyBuffer[0]
    //     }
    //     fx.highlightText = rest;
    //     saveWorkspace()
    //     break
    // case "hx":
    //     fx.highlightText = "";
    //     saveWorkspace()
    //     break
    case "fontscale":
        fontScale = rest - 0
        updateFontScale()
        break
    case "rr":
    case "rerun":
        clearLog()
        // up arrow
        sendTerminal("\x1b[A");
        // return
        sendTerminal("\r");
        break
    }
    editorCommandText.blur()
    return false
}
function editEditorCommandText() {
    editorCommandText.style.display = "block"
    editorCommandText.focus()
}
function focusEditorCommandText() {
    window.scrollTo(0, 0)
    editorCommandText.setSelectionRange(0, editorCommandText.value.length)
    editorCommandText.style.display = "block"
    theText.style.display = "none"
    searchText.style.display = "none"
    setCanvasHeightAccordingly()
}
function inputEditorCommandText() {
}
function blurEditorCommandText() {
    // handle the case where when you collapse the keyboard on iPad
    // it triggers a blur event, but it's still the activeElement
    if (document.activeElement == editorCommandText) {
        editorCommandText.blur()
        return
    }
    theText.style.display = "block"
    searchText.style.display = "none"
    editorCommandText.style.display = "none"
    setCanvasHeightAccordingly()
}

function editSearch() {
    searchText.style.display = "block"
    searchText.focus()
}
function focusSearchText() {
    window.scrollTo(0, 0)
    searchText.setSelectionRange(0, searchText.value.length)
    searchText.style.display = "block"
    theText.style.display = "none"
    editorCommandText.style.display = "none"
    setCanvasHeightAccordingly()
}
function inputSearchText() {
    if (fx.fileMode == "directory") {
        findDown(true, true)
    }
    render()
}
function blurSearchText() {
    // handle the case where when you collapse the keyboard on iPad
    // it triggers a blur event, but it's still the activeElement
    if (document.activeElement == searchText) {
        searchText.blur()
        return
    }
    theText.style.display = "block"
    searchText.style.display = "none"
    editorCommandText.style.display = "none"
    setCanvasHeightAccordingly()
}
function closeFile() {
    if (fx.fileMode == "fileList") {
        var fileIndex = files.indexOf(treeFilesShadow[fx.cursorLineIndex])
        if (fileIndex != -1) {
            var fileToClose = files[fileIndex]
            // try to get index again because it could have changed
            var indexToClose = files.indexOf(fileToClose)
            if (indexToClose != -1) {
                var afterTreeSeparator = treeFilesShadow.indexOf("treeSeparator") < fx.cursorLineIndex
                if (afterTreeSeparator) {
                    // after the tree separator we need to move up one because 2 lines are deleted
                    // see showFilesFlatFirst
                    fx.cursorLineIndex -= 1
                    ensureCursorInScreen()
                }
                files.splice(indexToClose, 1)
            }
            fx.lines = getLinesForFileList()
            // TODO?: to the useUnicode stuff here and related places
            // or maybe don't show unicode in file list?
            render()
            renderFileDropdown()
            renderURL()
            closeFileServer(fileToClose).then(() => {
            }).catch(e => alert(e))
        }
        fx.lines = getLinesForFileList()
    } else {
        var myFx = fx // in case it changes
        if (fx.iframeWrapper) {
            fx.iframeWrapper.remove()
        }
        var indexToClose = files.indexOf(myFx)
        if (indexToClose != -1) {
            files.splice(indexToClose, 1)
            // this changes fx
            selectFileIndex(indexToClose-1 < 0 ? 0: indexToClose-1)
        }
        render()
        renderFileDropdown()
        renderURL()
        closeFileServer(myFx).then(() => {
        }).catch(e => alert(e))
    }
}

var shellHelpers = [
    // some common commands to use quickly
    // TODO: make these common commands configurable
    "gofmt -s -w .",
    "golangci-lint run --print-issued-lines=false",
    "git commit -m '' --author='Drew LeSueur <drewalex@gmail.com>'",
    "git checkout master",
    "git pull origin master",
    "git checkout -b ",
    "git log --all --decorate --graph -10",
    "grep -Rin '' --include=*.pm .",
    "grep -Rin '' --include=*.go .",
    "grep -Rin '' --include=*.php .",
    "find . -iname '**'",
    // "diff -y --width=240",
    // "go test ./...",
    // a way to do `git add -p` non-interactively
    // "git --no-pager diff > gitdiff",
    // "open gitdiff",
    // "git apply --cached gitdiff",
    // "go doc -all ''",
    "git stash show -p stash@{0}",
    "clear",
    "git branch",
    "git status",
    "git log -10",
    "git log -p -3",
    "git add -u :/",
    "",
    "",
]

function getDefaultCWD(f) {
    var cwd = getDefaultCWDInner(f)
    if (isGitBash && !cwd.startsWith("/c/")) {
        cwd = "/c/" + cwd
    }
    return cwd
}
function getDefaultCWDInner(f) {
    // TODO: check again the proxyPath stuff here
    // it might be old and not used.
    if (f.shellCWD) {
        return f.shellCWD
    }

    if (f.fileMode == "directory") {
        return rootLocation + trimPrefix(f.fullPath, proxyPath)
    }

    if (f.fileMode == "file") {
        var parts = trimPrefix(f.fullPath, proxyPath).split("/")
        parts = parts.slice(0, parts.length - 1)
        return rootLocation + parts.join("/")
    }
}

function addCmdTab(id=0, cwd="", name="") {
    // I think this /cmd isn't hit on the server
    // I think we need a special endpoint for serving files and not just /
    var file = makeFile(proxyPath + "/cmd", 0, shellHelpers.join("\n"))
    file.fileMode = "shell"
    if (id) {
        file.ID = id
    }
    file.name = name
    if (!cwd) {
        cwd = getDefaultCWD(fx)
    }
    file.shellCWD = cwd
    addFileToList(file)
    setCurrentFile(file)
    fx.cursorLineIndex = fx.lines.length - 1
    updateCursorXY()
    runShellCommand("git branch | grep '*'")
    //theText.focus()
}

// TODO: addTerminalTab and addExistingTerminalTab can probably be consolidated,
// like addCmdTab
function addTerminalTab() {
    // TODO: follow up on the path variable, seems mostly useless for now.
    var file = makeFile(proxyPath + "/terminal", 0, "")
    file.fileMode = "terminal"
    file.shellCWD = getDefaultCWD(fx)
    addFileToList(file)
    setCurrentFile(file)
    fx.cursorLineIndex = fx.lines.length - 1
    updateCursorXY()
    openTerminal()
    //theText.focus()
}
function addExistingTerminalTab(id, name, cwd) {
    var file = makeFile(proxyPath + "/terminal", 0, "")
    file.fileMode = "terminal"
    file.ID = id
    file.shellCWD = cwd
    if (name) {
        file.name = name
    }
    addFileToList(file)
    setCurrentFile(file)
    fx.cursorLineIndex = fx.lines.length - 1
    updateCursorXY()
    if (!isPollingTerminal) {
        pollTerminals()
    }
    //theText.focus()
}
function normalizeFullPath(fullPath) {
    if (fullPath.charAt(0) != "/") {
        fullPath = "/" + fullPath
    }
    // TODO: also apply the .. and .
    var newParts = []
    var parts = fullPath.split("/")
    for (var i=0; i<parts.length; i++) {
        var part = parts[i]
        if (part == ".") {
            continue
        }
        if (part == "..") {
            newParts.pop()
        }
        newParts.push(part)
    }
    newFullPath = newParts.join("/")
    return newFullPath
}

function renderURL() {
    return // with workspaces we don't render url
    if (preventRender) {
        return
    }
    // For now we don't get files with shell mode.
    var filtered = files.filter(f => f.fileMode != "shell")
    var theNewPath = "/" + filtered.map(function(f) {
        if (f.fileMode == "terminal") {
            // TODO: ensure that the terminal is not the first one somewhere?
            // or at least handle it
            // TODO: encodeURIComponent? (or does it already do that?)
            return "__TERMINAL__:" + f.ID
        }
        return f.fullPath.slice(1) + ":" + (f.cursorLineIndex + 1)

    }).join(",")
    theNewPath += "?dark=" + (isDark ? "1" : "0")
    history.replaceState({}, "", theNewPath)
}

function doEval() {
    log("eval button clicked")
    var code = prompt("code")
    var resp =  eval(code)
    alert(resp)
}
function log(v) {
    var d = document.createElement("pre")
    d.style.display = "block"
    d.style.border = "1px solid blue"
    if (typeof v == "object") {
        d.innerText = JSON.stringify(v, "", "    ")
    } else {
        d.innerText = v
    }
    logEl.appendChild(d)
    logEl.scrollTop = logEl.scrollHeight
}
var hasUpdatedSearchTextForReplaceFlow = false
function setLastWord(maybeLastWord) {
    if (maybeLastWord != "") {
        lastWord = maybeLastWord
        if (!hasMovedSinceCut) {
            if (copyBuffer.length && !hasUpdatedSearchTextForReplaceFlow) {
                searchText.value = "\\b" + copyBuffer[0] + "\\b"
                // searchText.value = copyBuffer[0]
                hasUpdatedSearchTextForReplaceFlow = true
            }
            copyBuffer = lastWord.split("\n")
        }
    }
}
function docChanged(preventUndo) {
    fx.version += 1
    if (!inACPlop) { // TODO: check this out because in acPlop you also set lastWord
        setLastWord(getWordAtCursor().word)
    }
    if (!preventUndo) {
        // var start = Date.now()
        saveUndo(preventUndo)
        // log("u1: " + (Date.now() - start))
    }
    renderSaves()
    lastRenderFullScreenForSet = false
}
function saveUndo(preventUndo) {
    // 3 ways of doing undo
    //   1. any time you want an undo point just snapshot the whole file
    //      to a stack of snapshots and just restore the whole file on undo
    //      pro: simple to implement
    //      con: more memory usage.
    //   2. any time you want an undo point just diff the lines from last undo point (lastDocState)
    //.      and add that diff to a stack of diffs
    //       then snapahot to a single variable "lastDocState"
    //.      and just reverse apply the diff on undo.
    //       pro: Less memory, theoretically allows more undos
    //.      con: more cpu usage calcing the diff
    //.      con: more complicated to implement
    //.  3. make setters for any modification of the document (instead of just manual array modification)
    //.     in those setters we'd manually create diffs without diffing the whole document.
    //.     pro: less cpu and less memory all around
    //.     pro: would cause us to wrangle the document changes into simple functions
    //.          and we could reuse some logic for screen share
    //.     con: also complicated to implementwould have to
    //.     con: would have to go through all changes to fx.lines and update code (that actually could be a good thing)
    //.     con: in first 2 it might be easier to not make every single change cause an undo point
    //.          for example we currently don't want every letter typed to be an undo point. we currently undo at the line level
    //.          (see calls to docChanged)
    //.
    var currentContents = fx.lines.join("\n")
    if (currentContents == fx.undo.stack[fx.undo.index]) {
        return
    }
    if (fx.undo.index != fx.undo.stack.length - 1) {
        fx.undo.stack.splice(fx.undo.index + 1, fx.undo.stack.length - fx.undo.index +1)
        fx.undo.yStack.splice(fx.undo.index + 1, fx.undo.yStack.length - fx.undo.index +1)
        fx.undo.xStack.splice(fx.undo.index + 1, fx.undo.xStack.length - fx.undo.index +1)
    }
    fx.undo.index += 1
    fx.undo.stack.push(currentContents)
    fx.undo.yStack.push(fx.cursorLineIndex)
    fx.undo.xStack.push(fx.cursorColIndex)
    if (fx.undo.stack.length > maxUndos) {
        fx.undo.stack.shift()
        fx.undo.yStack.shift()
        fx.undo.xStack.shift()
        fx.undo.index -= 1
    }
}


// uncomment this line if you want to add back emoji, etc support
// var splitter = new GraphemeSplitter()
var segmenter = new Intl.Segmenter('en', {granularity: "grapheme"})
function splitGraphemes(theLine) {
    // return theLine.split("")
    // return splitter.splitGraphemes(theLine)
    var a = []
    var segments = segmenter.segment(theLine)
    for (let {segment, index, isWordLike} of segments) {
      a.push(segment)
    }
    return a
    
    // This also works, strange to me this interface?
    // var si = segmenter.segment(theLine)[Symbol.iterator]()
    // return [...si].map(x => x.segment)
    // https://github.com/tc39/proposal-intl-segmenter
}

// setter for lines
// this should help keep track of changes etc
// for use in undo maybe, and streaming
// in the future you can have more granular changes about what in the line
// is being updated, like a splice?
// maybe tou can do a line diff too.
function updateLineFile(file, index, value) {
    if (index == -1) {
        index = file.cursorLineIndex
    }

    var theLine = value
    if (useUnicode) {
        theLine = new String(value)
        theLine.cachedGraphemes = splitGraphemes(value)
        file.lines[index] = theLine
    } else {
        file.lines[index] = value
    }
    return theLine
}
function updateLine(index, value) {
    return updateLineFile(fx, index, value)
}
var emptyArray = []
function getCachedGraphemes(theLine, index, file, nocache) {
    if (theLine.length == 0) {
         return emptyArray
    }
    if (theLine.cachedGraphemes) {
        return theLine.cachedGraphemes
    }
    var graphemes = splitGraphemes(theLine)
    if (nocache == "nocache") {
        return graphemes
    }
    if (typeof file == "undefined") {
        file = fx
    }
    if (typeof index == "undefined" || index == -1) {
        index = file.cursorLineIndex
    }
    theLine = new String(theLine) // removes tabCache
    theLine.cachedGraphemes = graphemes
    // try {
        if (index < file.lines.length) {
            file.lines[index] = theLine
        }
    // } catch {
    //     var err = new Error()
    //     log(err.stack)
    // }
    return graphemes
}

function setLines(lines) {
    // TODO: calc a whole diff here?
    // because there can be multiple files
    // referencing the same lines,
    // we can't just set the lines on one
    // for when you have to update the whole object
    fx.lines = lines
    for (var i=0; i<files.length; i++) {
        // TODO: maybe you souldn't make terminal and shell have the same path anyway?
        if (fx.fileMode != "terminal" && fx.fileMode != "shell") {
            if (fx != files[i] && files[i].fullPath == fx.fullPath) {
                files[i].lines = fx.lines
            }
        }
    }
}
function repositionUndo(isUndo) {
    setLines(fx.undo.stack[fx.undo.index].split("\n"))
    if (isUndo) {
        fx.cursorColIndex = fx.undo.xStack[fx.undo.index + 1]
        fx.cursorLineIndex = fx.undo.yStack[fx.undo.index + 1]
    } else {
        fx.cursorColIndex = fx.undo.xStack[fx.undo.index]
        fx.cursorLineIndex = fx.undo.yStack[fx.undo.index]
    }
    if (fx.cursorLineIndex < fx.offsetY || fx.cursorLineIndex > fx.offsetY+maxLines) {
        fx.offsetY = max(0, fx.cursorLineIndex - marginLeft)
    }
    if (fx.cursorColIndex < fx.offsetX || fx.cursorColIndex > fx.offsetX+maxCols) {
        fx.offsetX = max(0, fx.cursorColIndex - marginLeft)
    }
    updateCursorXY()
    render()
}

function undo() {
    fx.undo.index = bind(fx.undo.index-1, 0, fx.undo.index)
    repositionUndo(true)
}

function redo() {
    fx.undo.index = bind(fx.undo.index+1, fx.undo.index, fx.undo.stack.length-1)
    repositionUndo(false)
}
function clearLog() {
    if (fx.fileMode == "shell") {
        runShellCommand("clear")
    } else if (fx.fileMode == "terminal") {
        // TODO: should I be using setLines?
        fx.lines = [""]
        fx.cursorLineIndex = 0
        fx.cursorColIndex = 0
        updateCursorXY()
        fx.offsetY = 0
        ensureCursorInScreen()
    }
    logEl.innerHTML = ""
    render()
}
function isNumeric(s) {
    var c = s.charCodeAt(0)
    return (c >= 48 && c <= 57)
}

function getCharClass(a) {
    if (a >= 65 && a <= 90) {
        return "cap"
    }
    if (a >= 97 && a <= 122) {
        return "low"
    }
    if (a >= 48 && a <= 57) {
        return "num"
    }
    return a
}
function findNextCharClass(theLine, index) {
    var currClass = getCharClass(theLine.charCodeAt(index))
    for (var i=index+1; i<theLine.length; i++) {
        var nextClass = getCharClass(theLine.charCodeAt(i))
        if (nextClass != currClass) {
            if ((i == index+1) && currClass == "cap") {
                currClass = nextClass
                continue
            }
            return i
        }
    }
    return theLine.length
}
function findPrevCharClass(theLine, index) {
    var currClass = getCharClass(theLine.charCodeAt(index))
    for (var i=index-1; i>=0; i--) {
        var prevClass = getCharClass(theLine.charCodeAt(i))
        if (prevClass != currClass) {
            if ((i == index-1) && currClass == "cap") {
                currClass = prevClass
                continue
            }
            return i+1
            continue
        }
    }
    return 0
}
function isWordyChar(c) {
    return isWordy(c.charCodeAt(0))
}
// check for A-Za-z0-9_
function isWordy(a) {
    return (
        (a >= 65 && a <= 90) ||  // A-Z
        (a >= 97 && a <= 122) || // a-z
        (a >= 48 && a <= 57) ||  // 0-9
        (a == 95)            ||    // _

        // note: I kind of don't like how we depend on fx in this func, hmm
        ((fx.fileMode == "shell" || fx.fileMode == "terminal") && a == 46) || // .
        ((fx.fileMode == "shell" || fx.fileMode == "terminal") && a == 45) // -
    )
}
function isRegularWord(theLine) {
    // a little regex could replace this :)
    for (var cI=0; cI<theLine.length; cI++) {
       if (!isWordy(theLine.charCodeAt(cI))) {
         return false
       }
    }
    return true
}
function getWordAtCursor() {
    return getWordAt(fx.lines[fx.cursorLineIndex], u(fx.cursorColIndex))
}
function getWordAt(line, x) {
    if (!line) return {start: x, end: x, word: ""}
    for (var startIndex=x-1; startIndex>=0; startIndex--) {
        if (!isWordy(line.charCodeAt(startIndex))) {
            startIndex += 1
            break
        }
    }
    if (startIndex < 0) startIndex = 0
    for (var endIndex=x; endIndex < line.length; endIndex++) {
        if (!isWordy(line.charCodeAt(endIndex))) {
            break
        }
    }
    //if (startIndex < endIndex) {
        return {start: startIndex, end: endIndex, word: line.substring(startIndex, endIndex)}
    //}
    return {start: x, end: x, word: ""}
}
function getWordBeforeCursor() {
    return getWordBefore(fx.lines[fx.cursorLineIndex], u(fx.cursorColIndex))
}
function getWordBefore(line, x) {
    if (!line) return {start: x, end: x, word: ""}
    for (var startIndex=x-1; startIndex>=0; startIndex--) {
        if (!isWordy(line.charCodeAt(startIndex))) {
            startIndex += 1
            break
        }
    }
    if (startIndex < 0) startIndex = 0
    var endIndex = x
    //if (startIndex < endIndex) {
        return {start: startIndex, end: endIndex, word: line.substring(startIndex, endIndex)}
    //}
    return {start: x, end: x, word: ""}
}
function findDownForm(e) {
    e.preventDefault()
    if (fx.fileMode == "directory" && document.activeElement == searchText) {
        clickItemInDirectory()
        searchText.select()
        return
    }
    findDown()
    return false
}

function nextHighlightRange() {
    // find the closest highlightRange that is after
    var hrs = fx.highlightRanges || []
    var closestYAfter = fx.lines.length - 1
    for (var i=0; i<hrs.length; i++) {
        var hr = hrs[i]
        if (hr.StartY > fx.cursorLineIndex && hr.StartY < closestYAfter) {
            closestYAfter = hr.StartY
        }
    }
    // now are there any marker comments between us and where we want to be? if so, stop there
    for (var i=fx.cursorLineIndex+1; i<closestYAfter; i++) {
        var line = fx.lines[i]
        if (line.endsWith(" marker")) {
            closestYAfter = i
            break
        }
    }
    fx.cursorLineIndex = closestYAfter
    ensureCursorInScreen()
}
function prevHighlightRange() {
    // find the closest highlightRange that is before
    var hrs = fx.highlightRanges || []
    var closestYBefore = 0
    for (var i=0; i<hrs.length; i++) {
        var hr = hrs[i]
        if (hr.StartY < fx.cursorLineIndex && hr.StartY > closestYBefore) {
            closestYBefore = hr.StartY
        }
    }
    // now are there any marker comments between us and where we want to be? if so, stop there
    for (var i=fx.cursorLineIndex-1; i>closestYBefore; i--) {
        var line = fx.lines[i]
        if (line.endsWith(" marker")) {
            closestYBefore = i
            break
        }
    }
    fx.cursorLineIndex = closestYBefore
    ensureCursorInScreen()
}

function nextHighlightText() {
    if (!highlightMatchesSingleRegExp) {
        return
    }
    log(highlightMatchesSingleRegExp.toString())
    var prevSearchText = searchText.value
    // searchText.value = fx.highlightText
    searchText.value = highlightMatchesSingleRegExp.toString().slice(1, -2)
    findDown()
    searchText.value = prevSearchText
}
function prevHighlightText() {
    if (!highlightMatchesSingleRegExp) {
        return
    }
    log(highlightMatchesSingleRegExp.toString())
    var prevSearchText = searchText.value
    // searchText.value = fx.highlightText
    searchText.value = highlightMatchesSingleRegExp.toString().slice(1, -2)
    findUp()
    searchText.value = prevSearchText
}

function findDown(searchDir, wrap, startTop) {
    lastAction = "move"
    shouldAutocompleteLine = false
    hasMovedSinceNewLine = true
    acWord = null
    if (searchText.value.slice(0, 1) == ":" && (searchText.value.slice(1) - 0) == searchText.value.slice(1)) {
        fx.cursorLineIndex = searchText.value.slice(1) - 1
        ensureCursorInScreen()
        return
    }

    var startY = fx.cursorLineIndex
    if (startTop) {
       startY = 0
    }
    if (document.activeElement != searchText) {
        if (fx.selectedRegions.length) {
            searchText.value = getSelectedLines(fx, false).lines[0]
        } else if (searchText.value == "") {
            searchText.value = getWordAtCursor().word
        }
        if (searchText.value == "") {
            // nextHighlightRange()
            // return
            // navForward()
            nextHighlightText()
            return
            // searchText.value = " mar"+"ker"
        }
    }
    for (var i=startY; i<fx.lines.length; i++) {
        var lineToSearch = fx.lines[i]
        var originalLineToSearch = lineToSearch
        if (!startTop && i == fx.cursorLineIndex) {
            var startX = u(fx.cursorColIndex)
            if (!searchDir && lastSearchDirForSameTerm == "down") {
                startX = u(fx.cursorColIndex + lastSearchMatchLength)
            }
            lastSearchDirForSameTerm = "down"
            lineToSearch = lineToSearch.substr(startX)
        }
        var pos = -1
        if (false && document.activeElement == searchText) {
            pos = lineToSearch.toLowerCase().indexOf(searchText.value.toLowerCase())
            lastSearchMatchLength = searchText.value.length
        } else {
            if (useRegexSearch) {
                var theMatch = lineToSearch.match(cachedSearchRegexp(searchText.value))
                if (theMatch == null) {
                    pos = -1
                } else {
                    pos = theMatch.index
                    lastSearchMatchLength = theMatch[0].length
                }
            } else {
                pos = lineToSearch.indexOf(searchText.value)
                lastSearchMatchLength = searchText.value.length
            }
        }
        if (pos != -1) {
            if (!startTop && i == fx.cursorLineIndex) {
                // compensate for that we sliced the line originally
                pos += startX
            }
            fx.cursorLineIndex = i
            fx.cursorColIndex = expandTabIndex(originalLineToSearch, pos, i, fx)

            updateCursorXY()
            ensureCursorInScreen()

            render()
            return true
        }
    }
    if (wrap) {
        findDown(searchDir, false, true)
        return
    }
    render()
    return false
}

function ensureCursorInScreen(file) {
    if (!file) {
        file = fx
    }
    if (file.cursorLineIndex < file.offsetY) {
        file.offsetY = file.cursorLineIndex
    } else if (file.cursorLineIndex >= file.offsetY+maxLines) {
        file.offsetY = file.cursorLineIndex-maxLines +1
    }

    // TODO: there is something more elegant
    // that you can do here
    if (file.cursorColIndex < file.offsetX) {
        //file.offsetX = file.cursorColIndex
        file.offsetX = file.cursorColIndex - Math.floor(maxCols/2)
    } else if (file.cursorColIndex > file.offsetX+maxCols) {
        file.offsetX = file.cursorColIndex - Math.floor(maxCols/2)
    }
    if (file.offsetX < -marginLeft) {
        file.offsetX = -marginLeft
    }
    updateCursorXY(file)
    render()
}
// Note this won't work for certain chars
function reverse(str) {
    return str.split("").reverse().join("")
}
function findUp() {
    lastAction = "move"
    shouldAutocompleteLine = false
    hasMovedSinceNewLine = true
    acWord = null
    if (searchText.value.slice(0, 1) == ":" && (searchText.value.slice(1) - 0) == searchText.value.slice(1)) {
        fx.cursorLineIndex = searchText.value.slice(1) - 1
        ensureCursorInScreen()
    }
    if (fx.selectedRegions.length) {
        searchText.value = getSelectedLines(fx, false).lines[0]
    }
    if (searchText.value == "") {
        searchText.value = getWordAtCursor().word
        if (searchText.value == "") {
            // prevHighlightRange()
            // return
            // navBack()
            prevHighlightText()
            return
            // searchText.value = " mar"+"ker"
        }
    }
    for (var i=fx.cursorLineIndex; i>=0; i--) {
        var lineToSearch = fx.lines[i]
        if (!lineToSearch) {
            continue
        }
        if (i == fx.cursorLineIndex) {
            lineToSearch = lineToSearch.substr(0, u(fx.cursorColIndex))
        }
        var pos = -1
        if (false && document.activeElement == searchText) {
            pos = reverse(lineToSearch.toLowerCase()).indexOf(reverse(searchText.value.toLowerCase()))
            lastSearchMatchLength = searchText.value
        } else {
            if (useRegexSearch) {
                var theMatches = lineToSearch.matchAll(cachedSearchRegexpGlobal(searchText.value))
                var theMatch  = null
                for (theMatch of theMatches) {
                    // This lets theMatch var be the last one (or none)
                }
                if (theMatch == null) {
                    pos = -1
                } else {
                    pos = theMatch.index
                    lastSearchMatchLength = theMatch[0].length
                }
            } else {
                pos = reverse(lineToSearch).indexOf(reverse(searchText.value))
                lastSearchMatchLength = searchText.value
            }
        }
        if (pos != -1) {
            if (i == fx.cursorLineIndex && !useRegexSearch) {
                pos += (fx.lines[i].length - u(fx.cursorColIndex))
            }
            fx.cursorLineIndex = i
            if (!useRegexSearch) {
                var colIndex = fx.lines[i].length - (pos + searchText.value.length)
                fx.cursorColIndex = expandTabIndex(fx.lines[i], colIndex, i)
            } else {
                // this pos is from the left
                // in the future we could probably make the non regexp more consistent where it loops to the last one. (maybe better than reversing string?)
                fx.cursorColIndex = expandTabIndex(lineToSearch, pos, null, null, "nocache")
            }
            updateCursorXY()
            ensureCursorInScreen()
            render()
            return true
        }
    }
    render()
    return false
}
function clearSearch() {
    searchText.value = ""
    render()
}

function updateCursorXY(file) {
    if (!file) {
        file = fx
    }
    cursorX = (fx.cursorColIndex - fx.offsetX) * fontWidth
    cursorY = (fx.cursorLineIndex - fx.offsetY) * fontHeight
}

var tabWidth = 4
function indent() {
    // seems to be buggy
    // when first line indent is more than
    // last line indent
    if ((fx.lines[fx.cursorLineIndex] || "")[0] == "\t") {
        addPrefix("\t")
        return
    }
    addPrefix(" ".repeat(tabWidth))

}
function dedent() {
    stripPrefixes(["\t", " ".repeat(tabWidth)])
}

function comment(prefix) {
    var theLine
    if (fx.selectedRegions.length > 0) {
        theLine = fx.lines[fx.selectedRegions[0].startY]
    } else {
        theLine = fx.lines[fx.cursorLineIndex]
    }

    if (!prefix) {
        if (
            fx.fullPath.endsWith(".sh") ||
            fx.fullPath.endsWith(".pm") ||
            fx.fullPath.endsWith(".pl") ||
            fx.fullPath.endsWith(".env")
        ) {
            // Special case hack for sql script
            if (fx.lines[fx.lines.length-1] == "EOD") {
                prefix = "--"
            } else {
                prefix = "#"
            }
        } else if (fx.fullPath.endsWith(".ini"))  {
            prefix = ";"
        } else {
            prefix = "//"
        }
    }

    if (theLine.trim().startsWith(prefix)) {
        stripPrefixes([prefix+" ", prefix])
    } else {
        addPrefix(prefix+" ")
    }
}


function addPrefix(prefix) {
    if (fx.selectedRegions.length > 0) {
        var r = fx.selectedRegions[0]
        var firstIndent = ""
        var line = fx.lines[r.startY]
        var firstNonSpace = 0
        for (var i=0; i<line.length; i++) {
            var chr = line.charAt(i)
            if (chr != " " && chr != "\t") {
                firstNonSpace = i
                break
            }
        }
        for (var y=r.startY; y<=r.stopY; y++) {
            // fx.lines[y] = fx.lines[y].slice(0, firstNonSpace) + prefix + fx.lines[y].slice(firstNonSpace)
            updateLine(y, fx.lines[y].slice(0, firstNonSpace) + prefix + fx.lines[y].slice(firstNonSpace))
        }
    } else {
        var line = fx.lines[fx.cursorLineIndex]
        var firstNonSpace = 0
        for (var i=0; i<line.length; i++) {
            var chr = line.charAt(i)
            if (chr != " " && chr != "\t") {
                firstNonSpace = i
                break
            }
        }
        // fx.lines[fx.cursorLineIndex] = line.slice(0, firstNonSpace) + prefix + line.slice(firstNonSpace)
        updateLine(fx.cursorLineIndex, line.slice(0, firstNonSpace) + prefix + line.slice(firstNonSpace))
    }
    docChanged()
    render()
}

function stripPrefixes(prefixes) {
    if (fx.selectedRegions.length > 0) {
        var r = fx.selectedRegions[0]
        for (var y=r.startY; y<=r.stopY; y++) {
            // fx.lines[y] = stripPrefixesInner(fx.lines[y], prefixes)
            updateLine(y, stripPrefixesInner(fx.lines[y], prefixes))

        }
    } else {
        var line = fx.lines[fx.cursorLineIndex]
        // fx.lines[fx.cursorLineIndex] = stripPrefixesInner(line, prefixes)
        updateLine(fx.cursorLineIndex, stripPrefixesInner(line, prefixes))
    }
    docChanged()
    render()
}

function isWhiteSpace(str) {
    for (var i=0; i<str.length; i++) {
        var chr = str.charAt(i)
        if (chr != " " && chr != "\t") {
            return false
        }
    }
    return true
}
function stripPrefixesInner(line, prefixes) {
    for (var i=0; i<prefixes.length; i++) {
        var prefix = prefixes[i]
        var prefixPos = line.indexOf(prefix)
        if (prefixPos != -1) {
            if (isWhiteSpace(line.slice(0, prefixPos))) {
                line = line.slice(0, prefixPos) + line.slice(prefixPos + prefix.length)
                break
            }
        }
    }
    return line
}

function copyString(s) {
    copyBuffer = s.split("\n")
    copyEl.value = s
}
function copy() {
    // wrapping in for loop to simulate goto
    for (var s=0; s<1; s++) {
        if (fx.selectedRegions.length>0) {
            var r = fx.selectedRegions[0]
            if (r.startY == r.stopY) {
                copyBuffer = [fx.lines[r.startY].slice(u(r.startX), u(r.stopX))]
                fx.selectedRegions = []
                render()
                break
            }
            copyBuffer = [
                unExpandSlice(fx.lines[r.startY], r.startX, -1, r.startY),
                ...fx.lines.slice(r.startY + 1, r.stopY),
                unExpandSlice(fx.lines[r.stopY], 0, r.stopX, r.stopY)
            ]
            fx.selectedRegions = []
            render()
            break
        }
        selectMode = "line"
        copyBuffer = [fx.lines[fx.cursorLineIndex]]
    }

    var copyBufferString = copyBuffer.join("\n")
    copyEl.value = copyBufferString

    // I think this is not working because it's on a touchmove event?
    // And not a simple on like onclick
    // navigator.clipboard.writeText(copyBufferString).then(function() {
    //    alert("copied")
    // }, function(e) {
    //    alert("not copied: " + e)
    // })


    // copyEl.setSelectionRange(0, copyEl.value.length)
    // var range = document.createRange()
    // range.selectNodeContents(copyEl)
    // var sel = window.getSelection()
    // sel.removeAllRanges()
    // sel.addRange(range)
    // document.execCommand("copy")
}

function runScriptAndPasteButtonPress() {
    if (fx.fileMode == "terminal") {
        sendTerminal(copyBuffer.join("\r"))
        return
    }
    runScript()
}

function runScript() {
    var oldCopyBuffer = copyBuffer
    // going to try to default to single line. In most cases it's what we want?
    var theScriptLines
    if (fx.selectedRegions.length) {
        theScriptLines = getSelectedLines(fx).lines
    } else if ((fx.lines[fx.cursorLineIndex] || "").trim() == "") {
        // gets full page if nothing is selected
        theScriptLines = getSelectedLines(fx).lines
    } else {
        theScriptLines = [fx.lines[fx.cursorLineIndex]]
    }

    // add return to the last non-empty line
    for (var i=theScriptLines.length-1; i>=0; i--) {
        if (theScriptLines[i].trim() != "") {
            theScriptLines[i] = "return " + theScriptLines[i]
            break
        }
    }
    var code = theScriptLines.join("\n")
    var f = new Function(code)
    var ret = f()
    ret = ret + ""
    copyBuffer = ret.split("\n")
    paste()
    copyBuffer = oldCopyBuffer
}

function diffFiles() {
    // second-most-recent file
    var aLines = getSelectedLines(lastFile).lines
    var bLines = getSelectedLines(fx).lines

    var start = Date.now()
    var contents = simpleDiffOld3(aLines, bLines, false).join("\n")
    log("diff3: " + (Date.now()-start))
    var f3 = makeFile("__diffOld3", 0, contents)
    f3.fileMode = "file"
    f3.cursorLineIndex = 0
    addFileToList(f3)

    // var oldContents = aLines.join("\n")
    // var newContents = bLines.join("\n")
    // var start = Date.now()
    // var contents = Diff.createPatch("foo", oldContents, newContents, "", "", {context:0})
    // // var contents = Diff.createPatch("foo", "aaaaa", "bbbbbb", "", "")
    // log("diffM: " + (Date.now()-start))
    // var f4 = makeFile("__diffMyers", 0, contents)
    // f4.fileMode = "file"
    // f4.cursorLineIndex = 0
    // addFileToList(f4)
    // setCurrentFile(f4)

    setCurrentFile(f3)
    updateCursorXY()
    ensureCursorInScreen()
}

// this is a little hacky by changing and restoring state.
function getSelectedLines(f, shouldDeleteSelected) {
    // save old
    // in scriptLines we also have "oldPreventRender" business going on. doesn't 'harm' anything but a bit ugly.
    var oldPreventRender = preventRender
    var oldCopyBuffer = copyBuffer
    var oldFx = fx

    // mutate
    // Setting the global fx because functions like del() and copy depend on it
    // We could instrad have extra functions that allow you to pass in
    // the file, like updateLine bs updateLineFile
    fx = f
    preventRender = true
    var isWholeFile = false
    // run and snag
    if (fx.selectedRegions.length) {
        // now copyBuffer has the lines we want to tweak
        if (shouldDeleteSelected) {
            // TODO: make it so this delete doesn't update the undo stack
            // or change use so there is no option to delete here
            del()
        } else {
            copy()
        }
    } else {
        // if nothing is selected, let's deal with all the lines
        // note that we don't yet support shouldDeleteSelected here.
        copyBuffer = fx.lines.slice() // slice here acts as a copy. Do we need a copy? doing it to be safe
        isWholeFile = true
    }
    theLines = copyBuffer

    // restore
    copyBuffer = oldCopyBuffer
    preventRender = oldPreventRender
    fx = oldFx

    return {
        lines: theLines,
        isWholeFile: isWholeFile,
    }
}
function scriptLinesWithOneLineScript(oneLineScript) {
    var oldPreventRender = preventRender
    preventRender = true

    var _t = getSelectedLines(fx, true)
    var linesToProcess = _t.lines
    var isWholeFile = _t.isWholeFile
    var s = oneLineScript
    if (s.slice(0, 2) == "r ") {
        var parts = s.split(" ")
        s = `x.replaceAll("${parts[1]}", "${parts[2]}")`
    } else if (s.slice(0, 2) == "l ") {
        // l w w x n r - $a $b $c $d
        var parts = s.split(" - ")
        // s = `ll(x,"${parts[0].slice(2)}", ${parts.slice(1).join(" - ")}")`
        s = `ll(x,"${parts[0].slice(2)}", ` + "`" + parts.slice(1).join(" - ") + "`" + `)`
        log("the script is: " + s)
    }
    var theScriptLines = [s]
    // This next part mostly copy-pasted from scriptLines function
    if (theScriptLines.length) {
        // add return to the last non-empty line
        for (var i=theScriptLines.length-1; i>=0; i--) {
            if (theScriptLines[i].trim() != "") {
                theScriptLines[i] = "return " + theScriptLines[i]
                break
            }
        }
        var funcBody = theScriptLines.join("\n")
        var f = function(x) {
            return x
        }
        try {
            line = f(line)
            f = new Function("x", "i", funcBody)
        } catch (e) {
            alert(e)
        }
        var retLines = []
        for (var i=0; i<linesToProcess.length; i++) {
            var line = linesToProcess[i]
            try {
                line = f(line, i)
            } catch (e) {
                alert(e)
            }
            retLines.push(line)
        }
    }
    if (isWholeFile) {
        setLines(retLines)
        docChanged()
    } else {
        pasteLines(retLines, false, false)
    }

    preventRender = oldPreventRender
    render()
}
function scriptLines() {
    var oldPreventRender = preventRender
    preventRender = true

    // second-most-recent file
    var _t = getSelectedLines(lastFile, true)
    var linesToProcess = _t.lines
    var isWholeFile = _t.isWholeFile

    var theScriptLines = getSelectedLines(fx, false).lines

    if (theScriptLines.length) {
        // add return to the last non-empty line
        for (var i=theScriptLines.length-1; i>=0; i--) {
            if (theScriptLines[i].trim() != "") {
                theScriptLines[i] = "return " + theScriptLines[i]
                break
            }
        }
        var funcBody = theScriptLines.join("\n")
        var f = function(x) {
            return x
        }
        try {
            line = f(line)
            f = new Function("x", funcBody)
        } catch (e) {
            alert(e)
        }
        var retLines = []
        for (var i=0; i<linesToProcess.length; i++) {
            var line = linesToProcess[i]
            try {
                line = f(line)
            } catch (e) {
                alert(e)
            }
            retLines.push(line)
        }
    }
    setCurrentFile(lastFile) // second-most-recent file
    if (isWholeFile) {
        setLines(retLines)
        docChanged()
    } else {
        pasteLines(retLines, false, false)
    }

    preventRender = oldPreventRender
    render()
}



function regexer(r) {
    return function(c, line, index) {
       return r.test(c)
    }
}
function notRegexer(r) {
    return function(c, line, index) {
       return (line.length == index) || !r.test(c)
    }
}
function ll(line, script, replacement) {
    var cmds = script.split(" ")
    var index = 0
    var startSelect = 0
    var vars = {"$": "$"}
    var varsArray = []
    var cmd
    var c
    var matchIndex = 0
    matchVars = "abcdefghijklmnoqrs"
    var findCurrentOrNext = function(capture, rs, re, process) {
        var start = -1

        // need to go past the end, this <=
        for (index = index; index <= line.length; index++) {
            if (start == -1) {
                // you could do fewer checks if you manage more state
                if (rs(line[index], line, index) && (index == 0 || !rs(line[index-1], line, index))) {
                    start = index
                }
            } else {
                if (re(line[index], line, index)) {
                    // you could have a processor func
                    if (!capture) {
                        break
                    }
                    var v = line.slice(start, index)
                    if (process) {
                       v = process(v)
                    }
                    vars[matchVars[matchIndex]] = v
                    varsArray.push(v)
                    matchIndex++
                    break
                }
            }
        }
    }
    for (var i=0; i<cmds.length; i++) {
        cmd = cmds[i]
        switch (cmd) {
        case "w":
            findCurrentOrNext(true, regexer(/[\w]/), notRegexer(/[\w]/))
            break
        case "x":
            findCurrentOrNext(false, regexer(/[\w]/), notRegexer(/[\w]/))
            break
        case "n":
            findCurrentOrNext(true, regexer(/[0-9\.\-]/), notRegexer(/[0-9\.\-]/), function(x) {
                return x - 0
            })
            break
        case "0":
            findCurrentOrNext(false, regexer(/[0-9\.\-]/), notRegexer(/[0-9\.\-]/))
            break
        case "r":
            findCurrentOrNext(true, regexer(/[\w]/), function(c, line, index) {
              if (index == line.length) {
                  return true
              }
              return false
            })
            break
        // you could use closures to things like capture strings with escaping?
        }
    }
    if (typeof replacement ==  "function") {
        return replacement.apply(null, varsArray)
    } else {
        return replacement.replace(/\$[a-z\$]/g, function(match) {
            return vars[match[1]]
        })
    }

}
/*
r = ll(
    `-34.2 number %% 400.123 # forever young `,
    "n w n r",
    "$b is $a and $c === $d"
)
r

r = ll("1/2/300", "n 0 n", (a,b) => {
   return a + b
})
r
301
NaN
303

number is -34.2 and 400.123 === forever young
$b is $a and $c === $d
number is -34.2 and 400.123 === forever young
*/


function setCanvasHeight(h) {
    canvasHeight = h

    // these 2 lines are new
    c.height = canvasHeight
    c.style.height = (canvasHeight/3)+"px"

    maxLines = Math.floor(canvasHeight / fontHeight)
}
function setCanvasHeightAccordingly() {
    var heightReduction = 0
    if (inDebugView) {
        var statusElHeight = 200
        statusEl.style.height = statusElHeight + "px"
        logEl.style.height = statusElHeight + "px"
        heightReduction = statusElHeight * 3
    }
    if (document.activeElement == theText || document.activeElement == searchText) {
        if (fx.fileMode == "terminal") {
            setCanvasHeight(canvasHeightKeyboardTerminal - heightReduction)
        } else {
            setCanvasHeight(canvasHeightKeyboard - heightReduction)
        }
    } else {
       if (fx && fx.fileMode == "shell") {
           setCanvasHeight(canvasHeightShell - heightReduction)
           // fileRow.style.display = "none" // red marker
       } else if (fx && fx.fileMode == "terminal") {
           setCanvasHeight(canvasHeightTerminal - heightReduction)
           // fileRow.style.display = "none" // red marker
       } else if (fx && fx.fileMode == "iframe") {
           setCanvasHeight(canvasHeightIframe - heightReduction)
           // fileRow.style.display = "flex" // red marker
       } else {
           setCanvasHeight(canvasHeightFull - heightReduction)
           // fileRow.style.display = "flex" // red marker
       }
    }
    
    // hack here to ignore whatever we set it before and set it to be canvasHeightFull if we have a bluetooth keybaord
    if (bluetoothKeyboard) {
        setCanvasHeight(canvasHeightFull - heightReduction)
    }
    render()
}
function setCanvasWidth(w) {
    canvasWidth = w
    maxCols = Math.floor(canvasWidth / fontWidth)
}

function insertText(theLines, yOffset, xOffset) {
    selectMode = "line"
    if (xOffset == -1) {
       xOffset = theLines[yOffset].length
    }
    var oldCopyBuffer = copyBuffer
    copyBuffer = theLines
    paste()
    fx.selectedRegions = []
    fx.cursorLineIndex = fx.cursorLineIndex + yOffset + 1
    var theLine = fx.lines[fx.cursorLineIndex]
    fx.cursorColIndex = expandTabIndex(theLine, xOffset)
    ensureCursorInScreen()
    render()
    copyBuffer = oldCopyBuffer
}
function readySameCommitAsBefore() {
    runQuickShellCommand("git log -1", function(err, result) {
        if (err) {
            return
        }
        // commit 7567b8aed34738da36b23d67b3053f3b6a30e13e
        // Author: Drew LeSueur <drewalex@gmail.com>
        // Date:   Mon Oct 4 19:24:54 2021 -0700
        //
        //     remove navBack and navForward features, wasnt using them

        if (result.indexOf("\r") != -1) {
            alert("you got cr!")
        }
        var lines = result.split("\n")
        if (lines.length < 5) {
            alert("could not get previous commit")
            return
        }
        var author = lines[1].substr("Author:".length).trim()
        var message = lines[4].trim()
        insertText(["git commit -m '"+bashEscapeSingleQuote(message)+"' --author '"+bashEscapeSingleQuote(author)+"'"], 0, 15)

    })
}

function bashEscapeSingleQuote(str) {
    return str.replaceAll("'", "'\\''")
}

function paste(unselect, pasteBefore, fromTap, unselectIfCharOneWord) {
    pasteLines(copyBuffer, unselect, pasteBefore, fromTap, unselectIfCharOneWord)
}
var pasteDebug = false
var p = []

function pasteLines(localCopyBuffer, unselect, pasteBefore, fromTap, unselectIfCharOneWord) {
    if (pasteDebug) {
        p.unshift(new Error().stack)
    }
    if (fx.iframe) {
        return
    }
    if (fromTap && !hasMovedSinceCut && globalOldCopyBuffer.length) {
        localCopyBuffer = globalOldCopyBuffer
    }
    if (localCopyBuffer.length == 0) {
        return
    }
    if (selectMode == "line") {
        var theOffset = 1
        var theOffset2 = 0
        if (pasteBefore) {
            theOffset = 0
            theOffset2 = -1
        }
        fx.lines.splice(fx.cursorLineIndex + theOffset, 0, ...localCopyBuffer)
        adjustHighlightRanges(fx.cursorLineIndex + theOffset, localCopyBuffer.length)
        var stopY = fx.cursorLineIndex + localCopyBuffer.length + theOffset2
        var lastLine = fx.lines[stopY] || ""
        if (!unselect) {
            fx.selectedRegions = [{
                startY: fx.cursorLineIndex + theOffset,
                // remember stopY is inclusive, stopX no
                stopY: stopY,
                startX: 0,
                stopX: expandTabIndex(lastLine, lastLine.length, stopY),
            }]
        }
    } else if (selectMode == "char") {
        if (localCopyBuffer.length == 1) {
            // fx.lines[fx.cursorLineIndex] = fx.lines[fx.cursorLineIndex].slice(0, u(fx.cursorColIndex)) +
            // localCopyBuffer[0] +
            // fx.lines[fx.cursorLineIndex].slice(u(fx.cursorColIndex))
            updateLine(fx.cursorLineIndex, fx.lines[fx.cursorLineIndex].slice(0, u(fx.cursorColIndex)) +
                localCopyBuffer[0] +
                fx.lines[fx.cursorLineIndex].slice(u(fx.cursorColIndex))
            )

            // #alternateTap
            var theLine = fx.lines[fx.cursorLineIndex] || ""
            var stopX = expandTabIndex(theLine, u(fx.cursorColIndex) + localCopyBuffer[0].length)
            // regex to test for non-wordy characters
            var isOneWord = !/\W/.test(localCopyBuffer[0].trim())
            if (alternateTap && !unselect && (!isOneWord || !unselectIfCharOneWord)) {
                var sr = {
                    startY: fx.cursorLineIndex,
                    startX: fx.cursorColIndex,
                    stopX: stopX,
                    stopY: fx.cursorLineIndex,
                }
                fx.selectedRegions = [sr]
            }
            fx.cursorColIndex = stopX // usually we want the cursor at the end
            updateCursorXY()
        } else {
            var line = fx.lines[fx.cursorLineIndex]
            // fx.lines[fx.cursorLineIndex] = line.slice(0, u(fx.cursorColIndex)) +
            //     localCopyBuffer[0]
            updateLine(fx.cursorLineIndex, line.slice(0, u(fx.cursorColIndex)) +
                localCopyBuffer[0]
            )
            // localCopyBuffer[localCopyBuffer.length-1] += line.slice(u(fx.cursorColIndex))
            // fx.lines.splice(fx.cursorLineIndex+1, 0, ...localCopyBuffer.slice(1))
            lastLine = localCopyBuffer[localCopyBuffer.length-1] + line.slice(u(fx.cursorColIndex))
            fx.lines.splice(fx.cursorLineIndex+1, 0, ...localCopyBuffer.slice(1, -1), lastLine)
            adjustHighlightRanges(fx.cursorLineIndex+1, localCopyBuffer.length-1)

            // #alternateTap
            if (alternateTap && !unselect) {
                var lastCopyBufferLine = localCopyBuffer[localCopyBuffer.length - 1]
                var sr = {
                    startY: fx.cursorLineIndex,
                    startX: fx.cursorColIndex,
                    stopX: expandTabIndex(lastCopyBufferLine, lastCopyBufferLine.length, null, null, "nocache"),
                    stopY: fx.cursorLineIndex + localCopyBuffer.length - 1,
                }
                fx.selectedRegions = [sr]
            }
        }
    }
    docChanged()
    render()
}

var splicedFiles = []

var globalOldCopyBuffer = []
var hasMovedSinceCut = true

function del(preventCopy, preventDeleteWholeLine) {
    var oldCopyBuffer = copyBuffer
    delinternal(preventCopy, preventDeleteWholeLine)
    
    // to allow cut paste, cut paste, cut paste of same word
    if (copyBuffer.join("\n") != oldCopyBuffer.join("\n")) {
        globalOldCopyBuffer = oldCopyBuffer
    }
}
function delinternal(preventCopy, preventDeleteWholeLine) {
    hasMovedSinceCut = false
    hasUpdatedSearchTextForReplaceFlow = false

    if (fx.selectedRegions.length>0) {
        var r = fx.selectedRegions[0]

        // kind of a hacky way to allow moving around
        // of files in the file list
        // we use <= instead of just < because of the initial "-" at the beginning of the file list
        if (fx.fileMode == "fileList" && r.startY <= files.length && r.stopY <= files.length) {
            // we subtract 1 because of the initial "-" at the beginning
            var cutFileIndexStart = r.startY - 1
            var cutFileIndexStop = r.stopY - 1

            splicedFiles = files.splice(cutFileIndexStart, (cutFileIndexStop - cutFileIndexStart)+1)
            setLines(getLinesForFileList())
            fx.selectedRegions = []
            docChanged()
            render()
            return
        }

        if (r.startY == r.stopY) {
            if (!preventDeleteWholeLine && r.startX == 0 && unExpandTabIndex(fx.lines[r.startY], r.stopX, r.startY) == fx.lines[r.startY].length) {
                selectMode = "line"
                if (!preventCopy) {
                    copyBuffer = [fx.lines[r.startY]]
                    // cutBuffer = [fx.lines[r.startY]]
                }
                fx.lines.splice(r.startY, 1)
                adjustHighlightRanges(r.startY, -1)
                fx.selectedRegions = []
                if (r.startY > 0) {
                    // subtract 1 so we can paste right afer
                    fx.cursorLineIndex = r.startY - 1
                    updateCursorXY()
                }
                docChanged()
                render()
                return
            } else {
                // I don't remember adding this. Is this right?
                // selectMode = "char"
                if (!preventCopy) {
                    copyBuffer = [unExpandSlice(fx.lines[r.startY], r.startX, r.stopX, r.startY)]
                    // cutBuffer = [unExpandSlice(fx.lines[r.startY], r.startX, r.stopX)]
                }
                // fx.lines[r.startY] = unExpandSlice(fx.lines[r.startY], 0, r.startX) +
                //     unExpandSlice(fx.lines[r.startY], r.stopX)
                updateLine(r.startY, unExpandSlice(fx.lines[r.startY], 0, r.startX, r.startY) +
                    unExpandSlice(fx.lines[r.startY], r.stopX, -1, r.startY)
                )
                fx.selectedRegions = []
                fx.cursorLineIndex = r.startY
                fx.cursorColIndex = r.startX
                updateCursorXY()
                fx.selectedRegions = []
                docChanged()
                render()
                if (document.activeElement == theText) {
                    //theText.setSelectionRange(r.startX, r.startX)
                    setSelectionRangeForText(r.startX, r.startX)
                }
                return
            }
        }
        var fullLines = r.startX == 0 && unExpandTabIndex(fx.lines[r.stopY], r.stopX, r.stopY) == fx.lines[r.stopY].length
        if (!preventCopy) {
            // cutBuffer = [
            copyBuffer = [
                unExpandSlice(fx.lines[r.startY], r.startX, -1, r.startY),
                ...fx.lines.slice(r.startY + 1, r.stopY),
                unExpandSlice(fx.lines[r.stopY], 0, r.stopX, r.stopY)
            ]
        }
        // fx.lines[r.startY] = unExpandSlice(fx.lines[r.startY], 0,  r.startX) +
        //     unExpandSlice(fx.lines[r.stopY], r.stopX)
        updateLine(r.startY, unExpandSlice(fx.lines[r.startY], 0,  r.startX, r.startY) +
            unExpandSlice(fx.lines[r.stopY], r.stopX, -1, r.stopY)
        )
        fx.lines.splice(r.startY + 1, r.stopY-r.startY)
        adjustHighlightRanges(r.startY+1, -(r.stopY-r.startY))
        if (!preventDeleteWholeLine) {
            if (fx.lines[r.startY] == "") {
                fx.lines.splice(r.startY, 1)
                adjustHighlightRanges(r.startY, -1)
            }
        }
        fx.cursorLineIndex = r.startY
        fx.cursorColIndex = r.startX

        // if full lines then move cursor up once to paste
        if (fullLines) {
            fx.cursorColIndex = -marginLeft
            if (fx.cursorLineIndex > 0) {
                fx.cursorLineIndex -= 1
            }
        }
        updateCursorXY()
        fx.selectedRegions = []
        docChanged()
        render()
        if (document.activeElement == theText) {
            //theText.setSelectionRange(r.startX, r.startX)
            setSelectionRangeForText(r.startX, r.startX)
        }
        return
    }
    selectMode = "line"
    if (!preventCopy) {
        // cutBuffer = [fx.lines[fx.cursorLineIndex]]
        copyBuffer = [fx.lines[fx.cursorLineIndex]]
    }
    fx.lines.splice(fx.cursorLineIndex, 1)
    adjustHighlightRanges(fx.cursorLineIndex, -1)
    docChanged()
    render()
}
function getIndent(line) {
    var theIndent = ""
    for (var i=0; i<line.length; i++) {
        var theChar = line.charAt(i)
        if (theChar == " " || theChar == "\t") {
            theIndent += theChar
        } else {
            return theIndent
        }
    }
    return theIndent
}

function adjustHighlightRanges(index, linesAddedCount, theFile) {
    // splice adds before

    if (!theFile) {
        theFile = fx
    }
    if (!theFile) {
        return
    }
    if (!theFile.highlightRanges) {
        return
    }

    for (var fileI=0; fileI<files.length; fileI++) {
        var file = files[fileI]
        if (file.lines != theFile.lines) { // same lines, same file
            continue
        }

        // TODO: fugure out why it's null (default Go value maybe)
        if (!file.highlightRanges) {
            file.highlightRanges = []
        }
        for (var i=0; i<file.highlightRanges.length; i++) {
            var r = file.highlightRanges[i]
            // This single condition works well enough for now
            if (true || linesAddedCount >= 0) {
                if (index <= r.StartY) {
                    r.StartY += linesAddedCount
                    r.StopY += linesAddedCount
                } else if (index <= r.StopY) {
                    r.StopY += linesAddedCount
                } else if (index > r.stopY) {
                    // nothing
                }
            } else {
               // this is buggy needs plenty of fixes
               // what about undo???
               // var stopIndex = index - linesAddedCount
               // if (index <= r.StartY && stopIndex <= r.StartY) {
               // } else if (index <= r.StartY && stopIndex <= r.StopY) {
               //     var hlLinesRemoved = stopIndex - r.StartY
               //     r.StartY += hlLinesRemoved
               //     r.StopY += hlLinesRemoved
               // } else if (index > r.StartY && stopIndex <= r.StopY) {
               //     r.StopY += linesAddedCount
               // } else if (index <= r.Stopy && stopIndex > r.StopY) {
               //     var hlLinesRemoved = stopIndex - r.Stopy
               //     r.StopY += hlLinesRemoved
               // }
            }
        }
    }
}


function insertLine(closeCurly, oMode) {
    if (fx.fileMode == "iframe") {
        // TODO: figure out this flow, sometimes happens when I click a for button on iframe.
        // likely click causes this and we should change it to not get here on iframe
        // but maybe it happens after a form is posted and opens a new "tab", even when not target=_blank
        return
    }
    if (fx.fileMode == "directory") {
        clickItemInDirectory()
        return
    }
    lastAction = "type"
    hasMovedSinceNewLine = false
    acWord = null
    var theLine = fx.lines[fx.cursorLineIndex]
    var theIndent = getIndent(theLine)
    var prevChar = theLine[u(fx.cursorColIndex - 1)]
    var nextChar = theLine[u(fx.cursorColIndex)]
    var strIndex = theText.selectionStart

    // if they are at the beginning, or there is an auto-closer before us
    // then we don't want oMode
    // otherwise oMode is like typing o in vim
    // if (oMode && strIndex != 0 && !(prevChar in closingMap)) {
    if (oMode && !wasWasDelete && strIndex != 0 && (!prevChar || isWordy(prevChar.charCodeAt(0))) && (!nextChar || isWordy(nextChar.charCodeAt(0)))) {
        // this is where we don't split the line at the cursor, but just insert a new line
        // setting strIndex to theLine.length does that
        // the wasWasDelete is so you can hit backspace and then return
        strIndex = theLine.length
        // get the smaller indent
        var theNextIndent = getIndent(fx.lines[fx.cursorLineIndex + 1] || "")
        theIndent = max(theIndent, theNextIndent)
    }
    fx.lines.splice(fx.cursorLineIndex + 1, 0, theIndent + theLine.substr(strIndex))
    adjustHighlightRanges(fx.cursorLineIndex + 1, 1)
    if (closeCurly && (prevChar in closingMap) && (nextChar == closingMap[prevChar])) {
        theIndent += "    "
        fx.lines.splice(fx.cursorLineIndex + 1, 0, theIndent)
        adjustHighlightRanges(fx.cursorLineIndex + 1, 1)
    }
    // fx.lines[fx.cursorLineIndex] = theLine.substr(0, strIndex)
    updateLine(fx.cursorLineIndex, theLine.substr(0, strIndex))
    fx.cursorLineIndex += 1
    fx.cursorColIndex = expandTabIndex(fx.lines[fx.cursorLineIndex], theIndent.length)
    updateCursorXY()
    ensureCursorInScreen()
    docChanged()
    render()
    renderTheText(fx.lines[fx.cursorLineIndex])
}
function uploadFile(e) {
    e.preventDefault()
    let formData = new FormData();
    if (fx.fileMode == "directory") {
        formData.append("thedirectory", fx.fullPath.split("/").join("/"));
    } else {
        formData.append("thedirectory", fx.fullPath.split("/").slice(0, -1).join("/"));
    }
    for (var i=0; i<filesToUpload.files.length; i++) {
        formData.append("thefiles", filesToUpload.files[i]);
    }
    fetch(proxyPath + '/myuploadfiles', {
        method: "POST", body: formData
    }).then(() => {
        alert("done uploading")
    }).catch(e => {
        alert("error uploading files:" + e)
    })
    return false
}
function newLine(e, shouldFocus) {
    var theLine = fx.lines[fx.cursorLineIndex]
    e && e.preventDefault()
    if (fx.fileMode == "shell") {
        runShellCommand(theLine)
        return false
    } else if (fx.fileMode == "terminal") {
        // this is handled somewhere else
        // see handleKeydown
    }
    // insertLine(true)
    insertLine(true, true) // this one just makes a new line
    if (shouldFocus) {
        theText.focus()
        //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
        setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
    }
    return false
}

function runQuickShellCommand(cmdString, cb) {
    fetch(proxyPath + "/myquickshell?cwd="+encodeURIComponent(getDefaultCWD(fx))+"&cmd="+encodeURIComponent(cmdString), {
        cache: "no-cache"
    }).then(r => {
        return r.text()
    }).then(r => {
        log("quick shell output: " + r)
        cb(null, r)
    })
}
function runShellCommand(line) {
    // outer loop to simulate goto
    if (fx.fileMode != "shell") {
        return
    }
    var oldCopyBuffer = copyBuffer
    for (var s=0; s<1; s++) {
        // ""supposebly" in non interactive mode this will get into some weird loop and use all the memory
        var trimmedLine = line.trim() 
        if (trimmedLine.startsWith("git") && trimmedLine.match(/\s-p\b/)) {
            copyBuffer = ["run this in terminal (xterm button), not non-interactive shell", ""]
            paste(true)
            fx.cursorLineIndex = fx.lines.length - 1
            updateCursorXY()
            ensureCursorInScreen()
            copyBuffer = oldCopyBuffer
            break
        }
        if (line == "clear") {
            // clear everything but the last 2 lines
            // TODO: should we be using set lines here?
            fx.lines = fx.lines.slice(-4)
            if (fx.lines.length == 0) {
                fx.lines = [""]
            }
            fx.cursorLineIndex = 0
            fx.cursorColIndex = 0
            updateCursorXY()
            fx.offsetY = 0
            // render()
            // return
            line = "p"
        }

        if (line.startsWith("open ")) {
            var fileToLoad = line.split(" ")[1]
            copyBuffer = [""]
            paste(true)
            fx.cursorLineIndex += 1
            fx.cursorColIndex = 0
            ensureCursorInScreen()
            // TODO: get rid of rootLocation stuff. I am pretty sure it's not used at least on front end
            addFile(trimPrefix(fx.shellCWD, rootLocation) + "/" + fileToLoad)
            break
        }

        if (line == "p") {
            // TODO: should we be restoring the old copyBuffer here?
            copyBuffer = shellHelpers.concat([
                // Adding the cwd here because it's helpful
                fx.shellCWD
                    .split("/")
                    .reverse()
                    .join(" < ")
            ])
            paste(true)
            fx.cursorLineIndex = fx.lines.length - 2

            fx.cursorColIndex = 0
            updateCursorXY()
            ensureCursorInScreen()
            break
        }

        let myFx = fx
        fetch(proxyPath + "/myshell?id="+fx.ID+"&cwd="+encodeURIComponent(fx.shellCWD)+"&cmd="+encodeURIComponent(line), {
            cache: "no-cache"
        }).then(r => {
            if (r.headers.get("X-ID")) {
                myFx.ID = r.headers.get("X-ID") - 0
            }
            return r.text()
        }).then(r => {
            var oldFx = fx
            fx = myFx
            copyBuffer = r.split("\n")
            copyBuffer.unshift("") // leading newline
            // second to last item is cwd
            myFx.shellCWD = copyBuffer[copyBuffer.length - 2]
            // let's restyle the pwd after we grab it

            // TODO: maybe come up with something more elegant than this paste dance
            copyBuffer[copyBuffer.length - 2] = myFx.shellCWD
                .split("/")
                .reverse()
                .join(" < ")
            copyBuffer.push(line) // add the line so it's easy to run again.
            copyBuffer.push("")
            myFx.cursorColIndex = 0
            myFx.cursorLineIndex += copyBuffer.length
            myFx.cursorLineIndex = myFx.lines.length - 1
            selectMode = "line"
            paste(true)
            myFx.cursorLineIndex = myFx.lines.length - 1
            updateCursorXY()
            ensureCursorInScreen()
            copyBuffer = oldCopyBuffer
            fx = oldFx
        }).catch(e => {
            alert("There was an error running the command: " + e)
        })
    }
    copyBuffer = oldCopyBuffer
}
function saveName(name) {
    fetch(proxyPath + "/myname?id="+fx.ID+"&name=" + encodeURIComponent(name), {cache: "no-cache"})
    .then(r => r.json())
    .then(r => {})
    .catch(r => {})
    fx.name = name
    renderURL()
    renderFileDropdown()
}

var allowPolling = true
var isPollingTerminal = false
function pollTerminals() {
    if (!allowPolling) {
        // so we can manually disable polling
        return false
    }
    isPollingTerminal = true
    if (!files.some(f => f.fileMode == "terminal")) {
        isPollingTerminal = false
        return
    }
    // log("Polling!")
    fetch(proxyPath + "/myterminalpoll", {
        cache: "no-cache"
    }).then(r => {
        return r.json()
    }).then(r => {
        // map of terminals and their payload and maybe meta info
        // log("result: " + JSON.stringify(r, "", "    "))
        for (var id in r) {
            var termInfo = r[id]
            var file = files.find(f => f.ID == id)
            var lineLengthBeforeChange = file.lines.length
            if (!file) {
                // TODO: this can happen if we get the response for
                // the poll before we even have the ID
                // we could store these values temporarily?
                // but for now we'll ignore them.
                continue
            }
            var oldCopyBuffer = copyBuffer
            // btoa("hello")
            // atob("aGVsbG8=")
            // #todoterminal: add xterm parsing here!
            var strToProcess = atob(termInfo.Base64)
            // simple parsing for now
            // log("term"+JSON.stringify(strToProcess))

            // TODO: what if the chunk we get ends on a control character.
            // Maybe we need to preserve the parseState to the file object.
            var parseState = "literal"
            var controlValues = [""]
            var lineBuffer = []
            for (var i = 0; i < strToProcess.length; i++) {
                // not calling docChanged because we don't care for terminals
                // doing this very dumb now... more optimizations later
                var theChr = strToProcess[i]
                switch (parseState) {
                    case "literal":
                        if (strToProcess[i] == "\n") {
                            updateLineFile(file, file.lines.length-1, file.lines[file.lines.length-1] + lineBuffer.join(""))
                            lineBuffer = []
                            file.lines.push("")
                        // for  now commenting out \r, later do I need to code the difference between newline and carriage return?
                        } else if (strToProcess[i] == "\r") {
                            // file.lines.push("")
                            // do nothing for now
                        } else if (strToProcess[i] == "\b") {
                            // copied from another part of this code // == 8
                            var theLine = file.lines[file.cursorLineIndex]
                            if (theLine.length == 0) {
                                file.lines.splice(file.cursorLineIndex, 1)
                                adjustHighlightRanges(file.cursorLineIndex, -1, file)
                                file.cursorLineIndex -= 1
                                var prevLine = file.lines[file.cursorLineIndex]
                                // file.lines[file.cursorLineIndex] = file.lines[file.cursorLineIndex] + theLine
                                updateLineFile(file, file.cursorLineIndex, file.lines[file.cursorLineIndex] + theLine)
                                // TODO: process the index here!!!
                                file.cursorColIndex = prevLine.length
                                setSelectionRangeForText(prevLine.length, prevLine.length)
                            } else {
                                // file.lines[file.lines.length-1] = theLine.slice(0, -1)
                                updateLineFile(file, file.lines.length-1, theLine.slice(0, -1))
                            }
                        } else if (strToProcess[i] == "\x1b") { // escape
                            parseState = "ESC"
                        } else if (strToProcess[i] == "\x07") { // bell
                            // do nothing
                        // } else if (strToProcess[i] == "\t") { // tab
                        } else {
                            // file.lines[file.lines.length-1] += strToProcess[i]
                            // updateLineFile(file, file.lines.length-1, file.lines[file.lines.length-1] + strToProcess[i])
                            // Todo: look at how the \b works with lineBuffer. May be more optimal to do it that way.
                            lineBuffer.push(strToProcess[i])
                        }
                        break;
                    case "ESC":
                        switch (theChr) {
                            case "[":
                                controlValues = [""]
                                parseState = "CSI"
                                break;
                            default:
                                parseState = "literal" // for now

                        }
                        break;
                    case "CSI":
                        switch (theChr) {
                            case "0":
                                controlValues[controlValues.length-1] += theChr
                                break;
                            case "1":
                                controlValues[controlValues.length-1] += theChr
                                break;
                            case "2":
                                controlValues[controlValues.length-1] += theChr
                                break;
                            case "3":
                                controlValues[controlValues.length-1] += theChr
                                break;
                            case "4":
                                controlValues[controlValues.length-1] += theChr
                                break;
                            case "5":
                                controlValues[controlValues.length-1] += theChr
                                break;
                            case "6":
                                controlValues[controlValues.length-1] += theChr
                                break;
                            case "7":
                                controlValues[controlValues.length-1] += theChr
                                break;
                            case "8":
                                controlValues[controlValues.length-1] += theChr
                                break;
                            case "9":
                                controlValues[controlValues.length-1] += theChr
                                break;
                            case ";":
                                controlValues.push("")
                                break;
                            case "K":
                                // TODO: clear parts of line according to rules
                                parseState = "literal"
                                break;
                            default:
                                // TODO: some action based the character here
                                // add textual representation for debugging purposes
                                // uncomment to debug
                                // file.lines[file.lines.length - 1] += " <ESC[" + controlValues.join(";") + theChr + "> "
                                // updateLineFile(file, file.lines.length - 1, file.lines[file.lines.length - 1] + " <ESC[" + controlValues.join(";") + theChr + "> ")

                                parseState = "literal" // for now

                        }
                        break;
                }
            }
            if (lineBuffer.length) {
                updateLineFile(file, file.lines.length-1, file.lines[file.lines.length-1] + lineBuffer.join(""))
            }

            // don't move the cursor if they are looking up higher in the file
            if (file.cursorLineIndex >= (lineLengthBeforeChange - 1)) {
                file.cursorLineIndex = file.lines.length - 1
                var theLine = file.lines[file.lines.length-1]
                if (theLine != "") {
                    file.cursorColIndex = expandTabIndex(theLine, theLine.length, file.lines.length-1, file)
                } else {
                    theLine = file.lines[file.lines.length-2] || ""
                    file.cursorColIndex = expandTabIndex(theLine, theLine.length, file.lines.length-2, file)
                }
                ensureCursorInScreen(file)
            }
        }
        render()
        setTimeout(pollTerminals, 1)
    }).catch(e => {
        // todo: does an error in the prev block also go here
        // if so we need to make sure we don't double poll
        // as a double check, in the polling code if there id a request
        // in-flight, don't poll again.
        // alert("polling error: " + e)
        setTimeout(pollTerminals, 1)
    })
}
var sendingTerminal = false
var sendTerminalBuffer = ""
function sendTerminal(payload) {
    if (sendingTerminal) {
        sendTerminalBuffer += payload
        return
    }
    // big TODO (#todoterminal)...  serialize, consider debounce.
    // make sure we only have one of these going at a time
    // also, binary payload?
    sendingTemrinal = true
    log("sending with id: " + fx.ID)
    fetch(proxyPath + "/myterminalsend?id=" + fx.ID + "&payload=" + encodeURIComponent(payload), {
        cache: "no-cache"
    // }).then(r => {
    //     return r.json()
    }).then(r => {
        sendingTemrinal = false
        if (sendTerminalBuffer.length) {
            var tmp = sendTerminalBuffer
            sendTerminalBuffer = ""
            sendTerminal(tmp)
        }
    }).catch(e => {
        sendingTemrinal = false
        if (sendTerminalBuffer.length) {
            var tmp = sendTerminalBuffer
            sendTerminalBuffer = ""
            sendTerminal(tmp)
        }
        alert("There was an error sending terminal: " + e)
    })
}
function openTerminal() {
    if (fx.fileMode != "terminal") {
        return
    }
    if (!isPollingTerminal) {
        pollTerminals()
    }
    var myFx = fx // in case the scope changes
    fetch(proxyPath + "/myterminalopen?cwd="+encodeURIComponent(fx.shellCWD), {
        cache: "no-cache"
    }).then(r => {
        return r.json()
    }).then(r => {
        myFx.ID = r.ID
    }).catch(e => {
        alert("There was an error running the command: " + e)
    })
}
function closeFileServer(theFile) {
    if (!theFile) {
        theFile = fx
    }
    return fetch(proxyPath + "/myclose?id=" + theFile.ID, {
        cache: "no-cache"
    // }).then(r => {
    //     return r.json()
    })
}
function stopServer() {
   fetch(proxyPath + "/stop", {
        cache: "no-cache",
        method: "POST",
        headers: {},
        body: "",
   }).then(r => {
   }).catch(e => {
   })
}

function trimPrefix(str, prefix) {
    if (str.startsWith(prefix)) {
        return str.slice(prefix.length)
    }
    return str
}

function setSelectionRangeForText(start, end) {
    var adjustedStart = u(start)
    var adjustedEnd
    if (start == end) {
        adjustedEnd = adjustedStart
    } else {
        adjustedEnd = u(end)
    }
    theText.setSelectionRange(adjustedStart, adjustedEnd)
}

function unExpandSlice(theLine, start, end, index, file) {
    theLine = theLine || ""
    var adjustedStart = unExpandTabIndex(theLine, start, index, file)
    if (typeof end == "undefined" || end == -1) {
        return theLine.slice(adjustedStart)
    }
    var adjustedEnd = unExpandTabIndex(theLine, end, index, file)
    return theLine.slice(adjustedStart, adjustedEnd)
}

var globalTabStop = 4
function toggleTabStop() {
    switch (globalTabStop) {
        case 2:
            globalTabStop = 4
            break;
        case 4:
            globalTabStop = 8
            break;
        case 8:
            globalTabStop = 16
            break;
        case 16:
            globalTabStop = 32
            break;
        case 32:
            globalTabStop = 2
            break;
    }
    toggleTabStopButton.innerText = globalTabStop + " tabs"
    render()
}
var shouldSeeTabs = false
function toggleSeeTabs() {
    shouldSeeTabs = !shouldSeeTabs
    render()
}

var eqCount = 0
function eq(a, b, message) {
    eqCount++
    if (a != b) {
        alert("unequal at number " + eqCount + ".\ngot: " + b + "\nwant: " + a + "\nmessage: " + message )
        window.close()
    }
}

var emojiRegex = /\p{Extended_Pictographic}/u;
function containsEmoji(line) {
    return emojiRegex.test(line)
}
function isEmoji(grapheme) {
    // over simplified attempt to Make it faster, but not 100% accurate
    if (grapheme.length > 1) {
        return true
    }
    
    return containsEmoji(grapheme)
}
function unExpandTabIndexNoCache(theLine, start) {
    return unExpandTabIndex(theLine, start, null, null, "nocache")
}
// go from graphical index to string index, at graphical index
function unExpandTabIndex(theLine, start, index, file, nocache) {
    // small todo: why is this called every touchend when not in edit mode?
    // prob a good reason, I just don't know
    // log("ueti " + Date.now())
    var tabStop = globalTabStop

    if (useUnicode) {
        var actualStringIndex = 0
        var expandedIndex = 0
        var newActualStringIndex = 0
        var newExpandedIndex = 0
        var expandedLine = getCachedGraphemes(theLine, index, file, nocache)
        var i = 0
        while (true) {
            if (i >= expandedLine.length) {
                break
            }
            if (i === 100000) {
                alert("loop err 1")
                break
            }
            // ab••••••y
            var grapheme = expandedLine[i]
            if (grapheme == "\t") {
                // newExpandedIndex = expandedIndex + (tabStop - ((expandedIndex) % tabStop)) + 1
                newExpandedIndex = expandedIndex + (tabStop - ((expandedIndex) % tabStop))
                newActualStringIndex = actualStringIndex + 1
            } else {
                if (isEmoji(grapheme)) {
                    newExpandedIndex = expandedIndex + emojiWidth
                } else {
                    newExpandedIndex = expandedIndex + 1
                }
                newActualStringIndex = actualStringIndex + grapheme.length
            }
            if (newExpandedIndex > start) {
                return actualStringIndex
            }
            expandedIndex = newExpandedIndex
            actualStringIndex = newActualStringIndex
            i++
        }

        return newActualStringIndex
    }

    var lastTabPos = -1
    var netSpacesAdded = 0
    var expandedLineLength = 0
    while (true) {
        tabPos = theLine.indexOf("\t", lastTabPos + 1)
        if (tabPos == -1) {
            expandedLineLength += theLine.length - (lastTabPos + 1)
            break
        }
        expandedLineLength += tabPos - (lastTabPos + 1)
        if (expandedLineLength > start) {
            break
        }
        var numberOfSpaces = tabStop - (expandedLineLength % tabStop)
        if ((expandedLineLength + numberOfSpaces) > start) {
            netSpacesAdded += (start - expandedLineLength)
            break
        }
        expandedLineLength += numberOfSpaces

        netSpacesAdded += numberOfSpaces - 1 // subtract 1 because of the actual tab
        lastTabPos = tabPos
    }
    var adjustedStart = start - netSpacesAdded
    return adjustedStart
}
function u(start) {
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    return unExpandTabIndex(theLine, start)
}

function expandTabIndexNoCache(theLine, start) {
    return expandTabIndex(theLine, start, null, null, "nocache")
}
// go from string index to graphical index, at string index
function expandTabIndex(theLine, start, index, file, nocache) {
    // todo: This is called every scroll, even if you don't go to another letter.
    // log("eti " + Date.now())
    theLine = theLine || ""
    var origLine = theLine
    if (!theLine.substring) {
        log("bad line")
        log(theLine)
        var err = new Error()
        log(err.stack)
    }

    if (start == -1) {
        start = theLine.length
    } else {
        theLine = theLine.slice(0, start)
    }
    var tabStop = globalTabStop

    if (useUnicode) {
        var actualStringIndex = 0
        var expandedIndex = 0
        var newActualStringIndex = 0
        var newExpandedIndex = 0
        var expandedLine = getCachedGraphemes(origLine, index, file, nocache)
        var expandedLineLength = 0
        if (start == origLine.length) {
            expandedLineLength = expandedLine.length
        } else {
            if (start == 0) {
                expandedLineLength = 0
            } else {
                var actualLength = 0
                for (var j=0; j<expandedLine.length;j++) {
                    expandedLineLength += 1
                    actualLength += expandedLine[j].length
                    if (actualLength == start) {
                        break
                    }
                }
            }
        }
        var i = 0
        while (true) {
            if (i >= expandedLineLength) {
                break
            }
            if (i === 100000) {
                alert("loop err 2")
                break
            }
            // ab••y
            var grapheme = expandedLine[i]
            if (grapheme == "\t") {
                newExpandedIndex = expandedIndex + (tabStop - ((expandedIndex) % tabStop))
                newActualStringIndex = actualStringIndex + 1
            } else {
                if (isEmoji(grapheme)) {
                    newExpandedIndex = expandedIndex + emojiWidth
                } else {
                    newExpandedIndex = expandedIndex + 1
                }
                newActualStringIndex = actualStringIndex + grapheme.length
            }
            expandedIndex = newExpandedIndex
            actualStringIndex = newActualStringIndex
            i++
        }
        return expandedIndex
    }



    var expandedLineLength = 0
    var lastTabPos = -1
    var netSpacesAdded = 0
    while (true) {
        tabPos = theLine.indexOf("\t", lastTabPos + 1)
        if (tabPos == -1) {
            expandedLineLength += theLine.length - (lastTabPos + 1)
            break
        }
        expandedLineLength += tabPos - (lastTabPos + 1)
        var numberOfSpaces = tabStop - (expandedLineLength % tabStop)
        expandedLineLength += numberOfSpaces

        netSpacesAdded += numberOfSpaces - 1 // subtract 1 because of the actual tab
        lastTabPos = tabPos
    }
    var adjustedStart = start + netSpacesAdded
    // log({start, adjustedStart, theLine})
    // var e = new Error()
    // log(e.stack)
    return adjustedStart
}
function handleFocusAfter() {
    if (searchText.value) {
        findDown()
    } else {
        // if (fx.cursorLineIndex == fx.lines.Length - 1) return
        // fx.cursorLineIndex += 1
        // instead of going one line down, let's alt tab
        setCurrentFile(lastFile);
    }
    setCanvasHeightAccordingly()
    ensureCursorInScreen()
    updateCursorXY()
    render()
    theText.focus()
    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
}

function handleFocusBefore() {
    // if you have something to search, make it search.
    if (searchText.value) {
        findUp()
    } else {
        // if (fx.cursorLineIndex == 0) return
        // fx.cursorLineIndex -= 1
        // instead of going one line down, let's clear the search
        clearSearch()
    }
    setCanvasHeightAccordingly()
    ensureCursorInScreen()
    updateCursorXY()
    render()
    theText.focus()
    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
}

function handleFocusIn() {
    setCanvasHeightAccordingly()
    ensureCursorInScreen()
    // lastAction = "type"
    acWord = null
    render()
    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
}

function handleBlur() {
    //topPadding.style.height = "100px"
    //window.scrollTo(0, 0)
    //setTimeout(() => {window.scrollTo(0,100)}, 100)

    // handle the case where when you collapse the keyboard on iPad
    // it triggers a blur event, but it's still the activeElement
    if (document.activeElement == theText) {
        theText.blur()
        return
    }

    if (dirtyInput) {
        saveUndo()
        dirtyInput = false
        // auto saving...
        // different that the timed autosave feature
        // this saves when you blur the text input
        if (fx.fileMode == "file") {
            // save()
        }
    }
    setCanvasHeightAccordingly()
    render()
    window.scrollTo(0, lastPageYOffset)
    renderTheText("")
}
function handleSearchFocusBefore() {
    theText.style.display = "none"
    editorCommandText.style.display = "none"
    searchText.style.display = "block"
    searchText.focus()
    setCanvasHeightAccordingly()
    findUp()
    searchText.setSelectionRange(searchText.value.length, searchText.value.length)
}
function handleSearchFocusAfter() {
    theText.style.display = "none"
    editorCommandText.style.display = "none"
    searchText.style.display = "block"
    searchText.focus()
    setCanvasHeightAccordingly()
    findDown()
    searchText.setSelectionRange(searchText.value.length, searchText.value.length)
}

// pressing the save button disables autosave
function saveWrapper() {
    log("clicked save")
    if (fx.fileMode == "shell") {
        // the save button turns into run when it's a "shell" file
        if (fx.selectedRegions.length) {
            copy()
            runShellCommand(copyBuffer.join("\n"))
        } else {
            runShellCommand(fx.lines[fx.cursorLineIndex] || "")
        }
        return
    } else if (fx.fileMode == "terminal") {
        sendTerminal("\r")
        return
    }
    autoSave = false
    save()
}
function save() {
    // using a single for loop to
    // simulate a goto
    // breaks will make sure the 'cleanup' step gets called
    for (var s=0; s<1; s++) {
        if (fx.fileMode != "file") break
        if (fx.savedVersion == fx.version) {
            break
        }
        fx.savingVersion = fx.version
        var toSave = fx.lines.join("\n")
        var toSaveHash = md5(toSave)
        var fetchPromise
        if (saveDiffs) {
            var theDiff = simpleDiffOld3(fx.undo.lastSavedLines, fx.lines, false).join("\n")
            if (theDiff == "") {
                fx.savedVersion = fx.savingVersion
                fx.savingVersion = -1
                render()
                renderFileDropdown()
                renderSaves()
                return
            }
            fetchPromise = fetch(proxyPath + "/saveload?fullpath=" + encodeURIComponent(fx.fullPath), {
                method: "POST",
                cache: "no-cache",
                headers: { "Content-Type": "application/x-www-form-urlencoded"},
                body: "oldmd5="+fx.undo.lastSavedHash+"&newmd5="+toSaveHash+"&diff=" + encodeURIComponent(theDiff)
            })
        } else {
            fetchPromise = fetch(proxyPath + "/saveload?f=" + encodeURIComponent(fx.fullPath), {
                method: "POST",
                cache: "no-cache",
                headers: { "Content-Type": "application/x-www-form-urlencoded"},
                body: "content=" + encodeURIComponent(toSave)
            })
        }
        var myFx = fx
        fetchPromise.then(r => r.json())
        .then(v => {
            if (v.saved) {
                myFx.savedVersion = myFx.savingVersion
                myFx.savingVersion = -1
                myFx.undo.lastSavedLines = toSave.split("\n")
                myFx.undo.lastSavedHash = toSaveHash
            } else {
                alert("issue saving: " + v.error)
                saveDiffs = false
            }
            render()
            renderFileDropdown()
            renderSaves()
        })
        .catch(e => alert(e))
        render()
    }

    if (autoSave) {
        setTimeout(save, saveEveryMS)
    }

    renderFileDropdown()
    renderSaves()
}
if (autoSave) {
    setTimeout(save, saveEveryMS)
}

var ctrlDown = false
var keyMaping = {
    "Enter": "\r", // need to include \n too?
    "Shift": "", // we'd just send upercase letters
    "CapsLock": "",
    "Backspace": "\b",
    "Tab": "\t",
    "Escape": "\x1b",
    "ArrowUp": "\x1b[A",
    "ArrowDown": "\x1b[B",
    "ArrowLeft": "\x1b[D",
    "ArrowRight": "\x1b[C",
}
function handleKeydown(e) {
    // TODO: this is where you could wrap or unwrap quotes, etc
    if (fx.fileMode == "terminal") {
        var mapped = e.key
        if (ctrlDown) {
            // todo add more conditions
            var v = e.key.toUpperCase().charCodeAt(0)-64
            if (v < 0) {
                return
            }
            mapped = String.fromCharCode(v)
        } else {
            // For keyboard
            if (e.key == "Control") {
                ctrlDown = true
                return
            }
            mapped = keyMaping[e.key]
            if (typeof mapped == "undefined") {
                mapped = e.key
            }
        }

        if (mapped === "") {
            return
        }
        sendTerminal(mapped)

        ctrlDown = false
        e.stopPropagation()
        e.preventDefault()
        return false
    }

    wasWasDelete = wasDelete
    wasDelete = e.keyCode == 8
    // 8 means backspace
    if (e.keyCode == 8 && theText.selectionStart == 0 && fx.cursorLineIndex != 0) {
        e.preventDefault()
        var theLine = fx.lines[fx.cursorLineIndex]

        fx.lines.splice(fx.cursorLineIndex, 1)
        adjustHighlightRanges(fx.cursorLineIndex, -1)

        fx.cursorLineIndex -= 1
        var prevLine = fx.lines[fx.cursorLineIndex]
        // fx.lines[fx.cursorLineIndex] = fx.lines[fx.cursorLineIndex] + theLine
        updateLine(fx.cursorLineIndex, fx.lines[fx.cursorLineIndex] + theLine)
        // TODO: process the index here!!!
        fx.cursorColIndex = prevLine.length
        updateCursorXY()
        docChanged()
        render()
        //theText.setSelectionRange(prevLine.length, prevLine.length)
        setSelectionRangeForText(prevLine.length, prevLine.length)
        return true // could be false too?
    }

    if (document.activeElement == theText && fx.selectedRegions.length) {
        e.preventDefault()
        var closer = closingMap[e.key]
        if (!closer) {
            return false
        }
        if (fx.selectedRegions[0].startY != fx.selectedRegions[0].stopY) {
            // for now only deal with singe line
            return false
        }
        var selectedRegion = JSON.parse(JSON.stringify(fx.selectedRegions[0]))
        // for now only deal with singe line
        var oldCopyBuffer = copyBuffer

        del(false, true)
        var part = copyBuffer[0]
        if (!part) {
            return false
        }
        if (part.slice(0, 1) == e.key && part.slice(-1) == closer) {
            copyBuffer = [part.slice(1,-1)]
            selectedRegion.stopX -= 2
        } else {
            copyBuffer = [e.key + part + closer]
            selectedRegion.stopX += 2
        }
        paste()
        fx.selectedRegions = [selectedRegion]
        copyBuffer = oldCopyBuffer
        docChanged()
        render()
        return false
    }
    return true
}

var closingMap = {
    "[": "]",
    "(": ")",
    "{": "}",
    "<": ">",
    "'": "'",
    "`": "`",
    '"': '"',
}
var dirtyInput = false
function saveLine() {
    dirtyInput = true
    lastAction = "type"
    acWord = null
    // useUnicode you could fix this part up?
    var lastTyped = theText.value[theText.selectionStart - 1]
    var secondLastTyped = theText.value[theText.selectionStart - 2] || ""
    var nextChar = theText.value[theText.selectionStart] || ""
    // fx.cursorColIndex = theText.selectionStart
    var theLine = updateLine(-1, theText.value)
    // fx.cursorColIndex = expandTabIndex(theText.value, theText.selectionStart)
    fx.cursorColIndex = expandTabIndex(theLine, theText.selectionStart)


    // Note: handle newline portion too.

    // doing for to be able to break
    for (var s=0; s<1; s++) {
        if (
            !wasDelete &&
            lastTyped in closingMap
        ) {
            var mainClosers = "({["
            var mainClosersEnd = ")}]"
            // first some common checks
            if (lastTyped == "'" && secondLastTyped != " " && secondLastTyped != "" && secondLastTyped != "," && mainClosersEnd.indexOf(nextChar) == -1) {
                break
            }

            if (lastTyped == "<" && theText.value.substring(0, theText.selectionStart - 1).trim() != "") {
                break
            }
            if (mainClosers.indexOf(lastTyped) != -1 && nextChar != "" && nextChar != " " && nextChar != "," && mainClosersEnd.indexOf(nextChar) == -1) {
                break
            }
            // renderTheText sets theText.value
            // theText.value =
            renderTheText(
                theText.value.slice(0, theText.selectionStart) +
                closingMap[lastTyped] +
                theText.value.slice(theText.selectionStart)
            )
            updateLine(-1, theText.value)
            //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
            setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
        }
    }
    // we used to do equivalent updateLine once here but now potentially do it twice with the closers
    cursorX = (fx.cursorColIndex - fx.offsetX) * fontWidth
    cursorY = (fx.cursorLineIndex - fx.offsetY) * fontHeight
    docChanged(true)

    // you need to tell the render to not update the text area
    // weird bugs will happen without this
    inEdit = true
    ensureCursorInScreen()
    render()
    inEdit = false
}
function bind(v, min, max) {
    if (v < min) v = min
    if (v > max) v = max
    return v
}

function r(x) {
    return Math.round(x)
}
function rW(x) {
    return Math.round(x/fontWidth)
}
function rH(y) {
    return Math.round(y/fontHeight)
}
var fillStyleMap = {
    black: 0,
    white: 1,
    brown: 2,
    yellow: 3,
    orange: 4,
    blue: 5,
    // TODO: add updated highlight line here this one is old
    "rgba(0, 255, 255, 0.15)": 6,
    "rgba(0, 0, 0, 0.5)": 7,
    "rgba(255, 255, 255, 0.5)": 8,
}
function fillStyleIndex(f) {
  if (!(f in fillStyleMap)) {
      return f
  }
  return fillStyleMap[f]
}





var mockCanvasContext = {
    commands: [],
    lastFillStyle: "black",
    fillStyle: "black",
    lastFont: "",
    font: "",
    lastTextBaseline: "",
    textBaseline: "",
    lastY: -9999,
    lastX: -9999,
    lastWasString: false,
    lastWasStringIndex: -1,
    checkFillStyle: function() {
      if (this.lastFillStyle != this.fillStyle) {
          this.lastFillStyle = this.fillStyle
          var fsi = fillStyleIndex(this.fillStyle)
          if (fsi <= 2) {
              this.commands.push(fsi + 7)
          } else {
              this.commands.push([2, fsi])
          }
      }

    },
    beginPath: function() {
        this.commands.push(10)
    },
    arc: function(x, y, startAngle, endAngle, counterClockwise) {
        this.commands.push([11, x, y, startAngle, endAngle, counterClockwise])
    },
    fill: function() {
        this.checkFillStyle()
        this.commands.push(12)
    },
    fillRect: function(x, y, w, h) {
      if (this.fillStyle == "rgba(255, 0, 0, 0.5)") {
          // hack for not rendering red ghost cursor
          return
      }
      this.checkFillStyle()
      this.commands.push([1, r(x), r(y), r(w), r(h)])
    },
    fillText: function(str, x, y) {
      if (this.lastFillStyle != this.fillStyle)  {
          this.lastWasString = false
          this.lastFillStyle = this.fillStyle
          var fsi = fillStyleIndex(this.fillStyle)
          if (fsi <= 2) {
              this.commands.push(fsi + 7)
          } else {
              this.commands.push([2, fsi])
          }
      }
      if (this.lastFont != this.font) {
          this.lastWasString = false
          this.lastFont = this.font
          this.commands.push([3, this.font])
      }
      if (this.lastTextBaseline != this.textBaseline) {
          this.lastWasString = false
          this.lastTextBaseline = this.textBaseline
          this.commands.push([4, this.textBaseline])
      }
      if (rH(y) == this.lastY) {
          if (this.lastWasString) {
              if ((rW(x) - this.lastX) == 1) {
                // you really only care about isNumeric for the first one after?
                // so you could do one more optimization.
                if (!isNumeric(str)) {
                    this.commands[this.lastWasStringIndex] += (str)
                } else {
                    this.commands[this.lastWasStringIndex] += (" " + str)
                }
              } else {
                this.commands[this.lastWasStringIndex] += (" " + str + rW(x))
              }
              this.lastX = rW(x)
              return
          }
          this.commands.push(str + rW(x))
          this.lastWasString = true
          this.lastWasStringIndex = this.commands.length - 1
          // this.commands.push([str + r(x)])
          // this.commands.push([str, r(x)])
          // this.commands.push([0, str, r(x)])
      } else {
          this.lastWasString = false
          // this.commands.push([str+r(x), r(y)])
          this.commands.push([str, rW(x), rH(y)])
          // this.commands.push([0, str, r(x), r(y)])
          this.lastY = rH(y)
      }
      this.lastX = rW(x)
    },
}
// var serverViewFeature = true
var serverViewFeature = false
var sendingViewToServer = false
var shouldSendViewToServer = false
var lastViewBodyToSend = ""
// var ws = new WebSocket("wss://" + location.host + "/myws/wsrender")
function sendViewToServer() {
   // ideas for server render
   // 1. call render with a mocked canvas context and store all the commands to send to server
   //    the viewer will just long poll to get the latest view and render
   //    use some sort of compression, but each screen is basically the whole current frame
   //    pro: super simple to implement
   //    con: sending the whole screen every change is heavy.
   // 2. like option 1 but have 3 layers -
   //      current line,
   //     everything but the current line,
   //     the cursor position
   // 3. a light version like #1, but don't worry about snapshotting
   //    the canvas commands, just render straight text of the screen
   //    and cursor position. it won't highlight the search word though.
   //    render it in an actual text area
   //    (hmm maybe you could make the search word blink client side)
   //    pro: super simple to implement
   // 4. save diffs any time document changes and keep a local state of the document
   //    on the screenshare client. See comments around undo.
   //    we could do a diff of the while document every change...
   //    but probably better would be the "setter functions" that make the diffs as you go
   //    (still because we are using an os level input box, we may have to diff the current line.)
   //    pro: likely much more fluid rendering
   //    con: much more complicated?
   //    con: having to not miss any messages on the client.
   //    con: how to handle when screenshare clients refresh page?
   //         would server have to keep track of document state?
   //         ah, maybe every few saves the server has to resnapshot the whole document?
   //         then diffs would be from most recent server snapshot
   //         there's a lot I haven't thought through with this option.
   // 5. like option 3 but just send the diff of the simple rendered screen.
   //    the server will keep the last n number of full screens.
   //    when the client asks for the latest screen (including the version number they are seeing)
   //    the server will do a diff of what they have and what they need.
   //    if the version that the client has is too old, it gets the full text again.
   //    pro: still only dealing with current screen
   //    con: not as fluid as a more advanced solution
   // I am starting to like option 5
   // 6. thinking more about 4.
   if (sendingViewToServer) {
       shouldSendViewToServer = true
       return
   }
   var viewBodyToSend = JSON.stringify(mockCanvasContext.commands)
   if (viewBodyToSend == lastViewBodyToSend) {
       // this optimization might not be as big as I thought
       return
   }

   totalViewBytesSent += viewBodyToSend.length
   totalViewRequests += 1
   // try {
   //     ws.send(viewBodyToSend)
   // // you could wait to make sure you server got it before sending again.
   // } catch (e) {
   //      log(e)
   // }
   // return

   lastViewBodyToSend = viewBodyToSend
   sendingViewToServer = true
   fetch(proxyPath + "/render", {
        cache: "no-cache",
        method: "POST",
        headers: {
          'Content-Type': 'application/json',
          'X-File': fx.fullPath, // I want to believe
          'X-Search': searchText.value,
          // 'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: viewBodyToSend,
   }).then(r => {
       sendingViewToServer = false
       if (shouldSendViewToServer) {
           shouldSendViewToServer = false
           sendViewToServer()
       }
   }).catch(e => {
       sendingViewToServer = false
       alert("error rendering to server: " + e)
       if (shouldSendViewToServer) {
           shouldSendViewToServer = false
           sendViewToServer()
       }
   })

}
var renderURLTimeout
var waitingRender = false
var lastRender = 0
// var maxFrameRate = 16
var maxFrameRate = 0
var waitingServerRender = false
var lastServerRender = 0
var maxServerFrameRate = 100
var lastRenderFx = null
var lastRenderOffsetX = -9999
var lastRenderOffsetY = -9999
var lastRenderCursorLineIndex = -9999

// TODO: potentially deprecate this
var lastRenderFullScreenForSet = false

function render() {
    if (preventRender) {
        return
    }

    // Now that file names contain line numbers
    // let's render the url nore frequently
    clearTimeout(renderURLTimeout)
    renderURLTimeout = setTimeout(function () {
        renderURL()
    }, 1000)

    var timeSinceRender = Date.now() - lastRender
    if (timeSinceRender < maxFrameRate) {
        if (!waitingRender) {
            waitingRender = true
            var localInEdit = inEdit
            setTimeout(function () {
                waitingRender = false
                // doing this inEdit dance was important at least for
                // starting to implement emojis
                // I think it prevents setting the selectionRange to an incorrect index
                // when the unExpandTabIndex didn't fully support emojis
                // resulting in typing 2 red hearts turning into a black heart and a red heart
                var oldInEdit = inEdit
                inEdit = localInEdit
                render()
                inEdit = oldInEdit
            }, maxFrameRate - timeSinceRender)
        }
        return
    }
    lastRender = Date.now()


    var start = Date.now()
    var shouldSetIt = false
    if (fx == lastRenderFx && lastRenderOffsetY == fx.offsetY && lastRenderOffsetX == fx.offsetX) {
        if (lastRenderFullScreenForSet) {
            minY = min(fx.cursorLineIndex, lastRenderCursorLineIndex) - fx.offsetY - 1
            maxY = max(fx.cursorLineIndex, lastRenderCursorLineIndex) - fx.offsetY + 2
            t.clearRect(0, minY * fontHeight, c.width, (maxY - minY) * fontHeight)
        } else {
            c.width = c.width // one way to clear
            shouldSetIt = true
        }
    } else {
        c.width = c.width // one way to clear
        lastRenderFullScreenForSet = false
    }
    renderInternal()
    if (shouldSetIt) {
        // lastRenderFullScreenForSet = true
    }
    if (false && inDebugView) {
        s.innerHTML =
            lastWord + " " +
            fx.version + "/" + fx.savedVersion +
            "/" + fx.savingVersion +
            " p:" + cursorX + "," + cursorY +
            " c:" + fx.cursorColIndex + "," + fx.cursorLineIndex +
            " " + (r ? `s:${r.startX},${r.startY}:${r.stopX},${r.stopY}` : "s:--") +
            " " + selectMode
            // theStatus.fileTree = fileTree
        theStatus.lastWord = lastWord
        theStatus.lastCleared = lastCleared
        theStatus.totalViewRequests = totalViewRequests
        theStatus.totalViewBytesSent = totalViewBytesSent
        // theStatus.overflowX = overflowX
        // theStatus.overflowY = overflowY
        // theStatus.hasDoneOverflowYAction = hasDoneOverflowYAction
        theStatus.CB = JSON.stringify(copyBuffer)
        theStatus.oldCB = JSON.stringify(globalOldCopyBuffer)
        if (fx.iframe) {
            theStatus.iframeCursorX = fx.iframeCursorX
            theStatus.iframeCursorY = fx.iframeCursorY
            theStatus.iframeWLeft = fx.iframeWrapper.scrollLeft
            theStatus.iframeWTop = fx.iframeWrapper.scrollTop
            if (fx.currentElement) {
                theStatus.element = fx.currentElement.toString()
                theStatus.tagName = fx.currentElement.tagName
                theStatus.id = fx.currentElement.id
            } else {
                theStatus.element = ""
                theStatus.tagName = ""
                theStatus.id = ""
            }
        }
        // theStatus.acWord = acWord
        statusEl.innerText = JSON.stringify(theStatus, null, "    ")
    }
    // this is commented out because of iphone 12 mini slowness
    // see renderSaves()
    // if (fx.fileMode == "file")   {
    //     if (fx.savingVersion != -1) {
    //         saveButton.style.backgroundColor = "gray"
    //         saveButton.innerText = "saving"
    //     } else if (fx.version == fx.savedVersion) {
    //         saveButton.style.backgroundColor = ""
    //         saveButton.innerText = "saved"
    //     } else {
    //         saveButton.style.backgroundColor = "red"
    //         saveButton.innerText = "save"
    //     }
    // } else if (fx.fileMode == "shell") {
    //     // TODO: consider not setting this every render
    //     saveButton.innerText = "run"
    // } else if (fx.fileMode == "terminal") {
    //     // TODO: consider not setting this every render
    //     saveButton.innerText = "run"
    // }

    if (!inEdit) {
        // TODO: an idea is to not do this in the render step at all
        // but do it whenever we change cursorLineIndex or cursorColIndex
        // maybe use a setter for that to manage it better
        // this may be more efficient too.

        if (fx.selectedRegions.length) {
            if (agressiveRender || (touchCount == 0)) {
                // we comment this out because on iPad the "lines selected" part can make it in to the actual text of the document
                // renderTheText((fx.selectedRegions[0].stopY - fx.selectedRegions[0].startY + 1) + " lines selected")
            }
        } else {
            // TODO: this if statement only needed on iphone 12 mini!!! ???
            // TODO: check other iphone 12s
            // theText.value = cursorLine
	    	if (agressiveRender || (touchCount == 0 && document.activeElement == theText)) {
                renderTheText(cursorLine)
            }
        }

        // I don't think we need to do this part
        // theTextBefore.value = fx.lines[fx.cursorLineIndex - 1] || ""
        // theTextAfter.value = fx.lines[fx.cursorLineIndex + 1] || ""


        // set the selection range back to what it was
        // if it needs to be changed, some functions will change it
        // after the call to render.
        // TODO: have a state variable for what it should be.
        // if this is not here then after tap to erase we loose cursor pos
        // we can maybe come up with a way around it
        // Note this also happens somewhere in onMove
        // TODO: does it need to happen in both places?
    	if (agressiveRender || (touchCount == 0 && document.activeElement == theText)) {
            if (document.activeElement == theText) {
                setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
            }
        }
    }



    if (serverViewFeature) {
        // this render bock was recently moved into the serverViewFeature conditional
        var timeSinceServerRender = Date.now() - lastServerRender
        if (timeSinceServerRender < maxServerFrameRate) {
            if (!waitingServerRender) {
                waitingServerRender = true
                var localInEdit = inEdit
                setTimeout(function () {
                    waitingServerRender = false
                    // TODO: isolate this so it only async does the server part!
                    // it is going to possibly update things on the main text box
                    var oldInEdit = inEdit
                    inEdit = localInEdit
                    render()
                    inEdit = oldInEdit
                }, maxServerFrameRate - timeSinceServerRender)
            }
            return
        }
        lastServerRender = Date.now()

        // server rendering
        var oldOffsetX = fx.offsetX
        var oldMaxCols = maxCols
        var oldMaxLines = maxLines
        var oldT = t // canvas rendering context
        fx.offsetX = -marginLeft
        if (maxCols < 250) {
            maxCols = 250
        }
        if (maxLines < 32) {
            maxLines = 32
        }

        var oldCanvasHeight = canvasHeight
        // setCanvasHeight(canvasHeightFull)
        maxLines = Math.floor(canvasHeightFull / fontHeight)

        var section = Math.floor((fx.cursorColIndex + marginLeft) / maxCols)
        fx.offsetX = (section * maxCols) - marginLeft

        t = mockCanvasContext
        mockCanvasContext.lastFillStyle = "black",
        mockCanvasContext.fillStyle = "black",
        mockCanvasContext.lastFont = "",
        mockCanvasContext.font = "",
        mockCanvasContext.lastTextBaseline = "",
        mockCanvasContext.textBaseline = "",
        mockCanvasContext.commands = [[5, fontWidth.toFixed(2)-0, fontHeight.toFixed(2)-0, maxCols, maxLines, isDark ? 1 : 0]]

        // var start = Date.now()
        renderInternal()

        fx.offsetX = oldOffsetX
        maxCols = oldMaxCols
        maxLines = oldMaxLines
        t = oldT
        // setCanvasHeight(oldCanvasHeight)
        canvasHeight = oldCanvasHeight
        sendViewToServer()
    }

    lastRenderFx = fx
    lastRenderOffsetY = fx.offsetY
    lastRenderOffsetX = fx.offsetX
    lastRenderCursorLineIndex = fx.cursorLineIndex
}

// this is a workaround for iphone 12 mini issue where dom is slow
// and we can't blindly update it in the render loop
// TODO: you can make shell and terminal faster too.
var renderedSaveRed = false
function renderSaves() {
    if (!fx) {
        return
    }
    if (fx.fileMode == "file")   {
        if (fx.savingVersion != -1) {
            saveButton.style.backgroundColor = "gray"
            saveButton.innerText = "saving"
            renpderedSaveRed = false
        } else if (fx.version == fx.savedVersion) {
            saveButton.style.backgroundColor = ""
            saveButton.innerText = "saved"
            renderedSaveRed = false
        } else if (!renderedSaveRed) {
            saveButton.style.backgroundColor = "red"
            saveButton.innerText = "save"
            renderedSaveRed = true
        }
    } else if (fx.fileMode == "shell") {
        // TODO: consider not setting this every render
        saveButton.innerText = "run"
    } else if (fx.fileMode == "terminal") {
        // TODO: consider not setting this every render
        saveButton.innerText = "run"
    }
}

var theTextValue = ""
function renderTheText(v) {
    // TODO: why when i uncomment the if
    // and i type and hit enter it duplicates the line?
    // if (v != theTextValue) {
        theText.value = v
        theTextValue = v
    // }
}
function toggleCompactRender() {
    compactRender = !compactRender
    globalTabStop = compactRender ? 2 : 4
    render()
}

var noCompactPrevWords = {
    "function": true,
    "func": true,
    "class": true,
    "type": true,
    "var": true,
}
var compactReplace = {
    "if": "if",
    "for": "for",
    "foreach": "frch",
    "function": "fn",
    "func": "fn",
    "range": "rg",
}
function compactWord(word, theLine, startSpacesLength, index, prevWord) {
    if (fx.cursorLineIndex == index && fx.cursorColIndex >= 0) {
        return word
    }
    if (noCompactPrevWords[prevWord]) {
      return word
    }
    if ((theLine.trimStart().length + startSpacesLength + marginLeft) <= maxCols) {
        return word
    }
    var replacement = compactReplace[word]
    if (replacement) {
      return replacement
    }

    if (word - 0 == word) {
        return word
    }

    return word.slice(0,1)
}
function compactSpace(spaces, index) {
    return spaces

    if (fx.cursorLineIndex == index && fx.cursorColIndex >= 0) {
        return spaces
    }
    var numbSpaces = 2*Math.floor(spaces.length / 4)
    var leftover = spaces.length % 4
    return " ".repeat(numbSpaces+leftover)
}
function compactLine(theLine, index) {
    var ret = {
        compactedLine: "",
        fgColors: [],
        bgBoxes: []
    }
    // if (theLine.length + marginLeft <= maxCols) {
    //     ret.compactedLine = theLine
    //     return ret
    // }


    var currentToken = ""
    var state="start"
    var startSpaces = ""
    var prevWord = ""
    for (var i = 0; i < theLine.length; i++) {
        var chr = theLine[i]
        if (state == "start") {
            if (chr == " ") {
                currentToken = chr
                state = "startSpace"
            } else if (isWordyChar(chr)) {
                currentToken = chr
                state = "inWord"
            } else {
                state = "endThing"
                ret.compactedLine += chr
            }
        } else if (state == "startSpace") {
            if (chr == " ") {
                currentToken += chr
            } else if (isWordyChar(chr)) {
                startSpaces = compactSpace(currentToken, index)
                ret.compactedLine += startSpaces
                currentToken = chr
                state = "inWord"
            } else {
                startSpaces = compactSpace(currentToken, index)
                ret.compactedLine += startSpaces
                state = "endThing"
                ret.compactedLine += chr
            }
        } else if (state == "inWord") {
            if (isWordyChar(chr)) {
                currentToken += chr
            } else {
                ret.compactedLine += compactWord(currentToken, theLine, startSpaces.length, index, prevWord)
                prevWord = currentToken
                ret.compactedLine += chr
                state = "endThing"
            }
        } else if (state == "endThing") {
            if (isWordyChar(chr)) {
                state = "inWord"
                currentToken = chr
            } else {
                ret.compactedLine += chr
            }
        }
    }
    if (state == "inWord") {
        ret.compactedLine += compactWord(currentToken, theLine, startSpaces.length, index, prevWord)
        prevWord = currentToken
    }
    return ret
}

var notSpace = /[^\s]/
function skipLeadingSace(line, startX, offsetX, y, file) {
    var adjustedStart = unExpandTabIndex(line, startX, y, file)
    var newStartX = startX
    var match = line.match(notSpace)
    if (match) {
        var letterStart = match.index
        // log({letterStart: letterStart})
        if (adjustedStart < letterStart) {
            newStartX = expandTabIndex(line, letterStart, y)
        }
    }
    return [newStartX-offsetX, newStartX-startX]
}

var renderDuration = 0
var renderCount = 0
var rendersInLastSecond = 0
function renderInternal() {
    // todo, how performant is this?
    // better to do this on initial load and then docChanged or something?
    marginLeft = Math.ceil(Math.log(fx.lines.length)/Math.log(10)) + 1
    var startRenderTime = Date.now()

    if (fx.iframe) {
        iframeCursor.style.top = (fx.iframeCursorY-5) + "px"
        // iframeCursor.style.left = ((navTouchSize) +fx.iframeCursorX-5) + "px"
        iframeCursor.style.left = (fx.iframeCursorX-5) + "px"
        return
    }

    // the selected areas
    for (var i=0; i<fx.selectedRegions.length;i++) {
        // todo: normalize region start and stop
        // todo: draw the cursors after the selected regions
        var r = fx.selectedRegions[i]
        t.fillStyle = "magenta"
        for (var y=r.startY-fx.offsetY; y<=r.stopY-fx.offsetY; y++) {
            var line = fx.lines[y + fx.offsetY] || ""
            if (r.startY == r.stopY) {
                t.fillRect((r.startX-fx.offsetX)*fontWidth, y*fontHeight, (r.stopX-r.startX)*fontWidth, fontHeight)
            } else if (y==r.startY-fx.offsetY) {
                t.fillRect((r.startX-fx.offsetX)*fontWidth, y*fontHeight, (expandTabIndex(line, line.length, y + fx.offsetY)-r.startX)*fontWidth, fontHeight)
            } else if (y==r.stopY-fx.offsetY) {
                t.fillRect((0-fx.offsetX)*fontWidth, y*fontHeight, r.stopX*fontWidth, fontHeight)
            } else {
                t.fillRect((0-fx.offsetX)*fontWidth  , y*fontHeight, expandTabIndex(line, line.length, y + fx.offsetY)*fontWidth, fontHeight)
            }
        }
    }

    // the highlighted areas
    var underlineOffset = (fontHeight) - (1/6/2 * fontHeight)
    var underlineHeight = fontHeight/6

    if (fx.highlightRanges) {
        for (var i=0; i<fx.highlightRanges.length;i++) {
            // TODO: don't highlight leading whitespa e
            // TODO: look into caching emd result of boxes

            // var r = fx.highlightRanges[i]
            // t.fillStyle = r.BackgroundColor
            // for (var y=r.StartY-fx.offsetY; y<=r.StopY-fx.offsetY; y++) {
            //     var line = fx.lines[y + fx.offsetY] || ""
            //     if (r.StartY == r.StopY) {
            //         t.fillRect((r.StartX-fx.offsetX)*fontWidth, y*fontHeight + underlineOffset, (r.StopX-r.StartX)*fontWidth, underlineHeight)
            //     } else if (y==r.StartY-fx.offsetY) {
            //         t.fillRect((r.StartX-fx.offsetX)*fontWidth, y*fontHeight + underlineOffset, (expandTabIndex(line, line.length, y + fx.offsetY)-r.StartX)*fontWidth, underlineHeight)
            //     } else if (y==r.StopY-fx.offsetY) {
            //         t.fillRect((0-fx.offsetX)*fontWidth, y*fontHeight + underlineOffset, r.StopX*fontWidth, underlineHeight)
            //     } else {
            //         t.fillRect((0-fx.offsetX)*fontWidth, y*fontHeight + underlineOffset, expandTabIndex(line, line.length, y + fx.offsetY)*fontWidth, underlineHeight)
            //     }
            // }

            // TODO, we could look into expanding tab indexes in one flow? instead of 2 individually?
            var r = fx.highlightRanges[i]
            t.fillStyle = r.BackgroundColor
            for (var y=r.StartY-fx.offsetY; y<=r.StopY-fx.offsetY; y++) {
                // You could even get more granular
                if (r.StopY < fx.offsetY) {
                    break
                }
                if (r.StartY > (fx.offsetY+maxLines)) {
                    break
                }
                var line = fx.lines[y + fx.offsetY] || ""
                if (r.StartY == r.StopY) {
                    var [newStartX, adjustment] = skipLeadingSace(line, r.StartX, fx.offsetX, y + fx.offsetY, fx)
                    t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (r.StopX-r.StartX-adjustment)*fontWidth, underlineHeight)
                } else if (y==r.StartY-fx.offsetY) {
                    var [newStartX, adjustment] = skipLeadingSace(line, r.StartX, fx.offsetX, y + fx.offsetY, fx)
                    t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (expandTabIndex(line, line.length, y + fx.offsetY)-r.StartX-adjustment)*fontWidth, underlineHeight)
                } else if (y==r.StopY-fx.offsetY) {
                    var [newStartX, adjustment] = skipLeadingSace(line, 0, fx.offsetX, y + fx.offsetY, fx)
                    t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (r.StopX-adjustment)*fontWidth, underlineHeight)
                } else {
                    var [newStartX, adjustment] = skipLeadingSace(line, 0, fx.offsetX, y + fx.offsetY, fx)
                    t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (expandTabIndex(line, line.length, y + fx.offsetY)-adjustment)*fontWidth, underlineHeight)
                }
            }
        }
    }

    // draw line where your cursor is for help with finding
    var highlightLine = true
    if (highlightLine) {
        // t.fillStyle = "rgba(0, 255, 255, 0.15)"
        // more apparent highlight line
        if (isDark) {
            // temp experiment with darker line
            // t.fillStyle = "rgba(0, 128, 128, 0.55)"
            t.fillStyle = "rgba(128, 128, 128, 0.55)"
        } else {
            t.fillStyle = "rgba(0, 255, 255, 0.55)"
        }
        // go twice as wide as you need, for server rendering purposes
        t.fillRect(0, (fx.cursorLineIndex - fx.offsetY) * fontHeight, c.width*2, fontHeight)
    }


    // render autocomplete word
    // the false is to see what it's like not rendering the "acWord"
    // Because it looks like selected text, I confuse the flow with
    // actual selected text
    if (!alternateTap && acWord) {
        t.fillStyle = "orange"
        for (var y=acWord.startY-fx.offsetY; y<=acWord.stopY-fx.offsetY; y++) {
            var line = fx.lines[y + fx.offsetY] || ""
            if (acWord.startY == acWord.stopY) {
                t.fillRect((acWord.startX-fx.offsetX)*fontWidth, y*fontHeight, (acWord.stopX-acWord.startX)*fontWidth, fontHeight)
            } else if (y==acWord.startY-fx.offsetY) {
                t.fillRect((acWord.startX-fx.offsetX)*fontWidth, y*fontHeight, (expandTabIndex(line, line.length, y + fx.offsetY)-acWord.startX)*fontWidth, fontHeight)
            } else if (y==acWord.stopY-fx.offsetY) {
                t.fillRect((0-fx.offsetX)*fontWidth, y*fontHeight, acWord.stopX*fontWidth, fontHeight)
            } else {
                t.fillRect((0-fx.offsetX)*fontWidth  , y*fontHeight, expandTabIndex(line, line.length, y + fx.offsetY)*fontWidth, fontHeight)
            }
        }
    }

    t.font = fontCSS
    t.textBaseline = "top"
    var r = fx.selectedRegions[0]
    // TODO: this element is hitten
    // consider removing it.


    // row highlight, what is this? remove it
    // t.fillStyle = "rgba(0, 128, 128, 0.5)"
    // t.fillRect(0, yPos, canvasWidth, fontHeight)
    // t.fillStyle = cursorType == "move" ? "cyan" : "yellow"

    // Note, we tried doing an extra loop for line numbers first so we change colors less
    //but didn't seem like it improved things
    var minY = 0
    var maxY = maxLines
    if (lastRenderFullScreenForSet && fx == lastRenderFx && lastRenderOffsetY == fx.offsetY && lastRenderOffsetX == fx.offsetX) {
        minY = min(fx.cursorLineIndex, lastRenderCursorLineIndex) - fx.offsetY - 1
        maxY = max(fx.cursorLineIndex, lastRenderCursorLineIndex) - fx.offsetY + 2
    }

    // colors on file
    if (fx.fileMode == "fileList") {
        for (var y=minY; y < maxY; y++) {
            var theLine = fx.lines[y + fx.offsetY] || ""
            var theFileForColor = treeFilesShadow[y + fx.offsetY]
            if (theFileForColor && theFileForColor.color) {
                t.fillStyle = theFileForColor.color
                var startBoxIndex = expandTabIndex(theLine, -1, y + fx.offsetY) - fx.offsetX
                // t.fillText(chr, x*fontWidth, y*fontHeight)
                // t.fillRect(startBoxIndex*fontWidth, y*fontHeight + (fontHeight/4), 2*fontWidth, fontHeight/2)
                t.beginPath()
                t.arc(startBoxIndex*fontWidth + (fontHeight/2), y*fontHeight + (fontHeight/2), fontHeight/3, 0, 2*Math.PI, false)
                t.fill()
            }
        }
    }
    
    // t.fillText(chr, x*fontWidth, y*fontHeight)
    for (var y=minY; y < maxY; y++) {
        // show the end of the document
        // if (y + fx.offsetY >= fx.lines.length) {
        //   t.fillStyle = "#222"
        //   t.fillRect(0, y*fontHeight, canvasWidth, fontHeight)
        // }

        // highlight search
        var theLine = fx.lines[y + fx.offsetY] || ""
        var highlightStartSearch = 0
        var matchLength = 0
        if (theLine && searchText.value.length) {
            // max 20 highlights per line
            for (var _i=0; _i<20; _i++) {
                if (fx.fileMode == "directory") {
                    var pos = theLine.toLowerCase().indexOf(searchText.value.toLowerCase(), highlightStartSearch)
                    if (pos == -1) {
                        break
                    }
                    matchLength = searchText.value.length
                    highlightStartSearch = pos + matchLength
                } else {
                    if (useRegexSearch) {
                        var theMatch = theLine.substr(highlightStartSearch).match(cachedSearchRegexp(searchText.value))
                        if (theMatch == null) {
                            break
                        }
                        matchLength = theMatch[0].length
                        pos = highlightStartSearch + theMatch.index
                        highlightStartSearch = pos + matchLength
                    } else {
                        var pos = theLine.indexOf(searchText.value, highlightStartSearch)
                        if (pos == -1) {
                            break
                        }
                        matchLength = searchText.value.length
                        highlightStartSearch = pos + matchLength
                    }
                }
                // lime
                if (isDark) {
                    // t.fillStyle = "blue"
                    t.fillStyle = "rgba(0,0,255,0.7)"
                } else {
                    // t.fillStyle = "yellow"
                    t.fillStyle = "rgba(255,255,0,0.7)"
                }

                // TODO: expanding the same line, we could come up with optimization for that
                var startHighlightPos = expandTabIndex(theLine, pos, y + fx.offsetY)
                var startFillHighlight = (startHighlightPos - fx.offsetX) * fontWidth
                var highlightLength = (expandTabIndex(theLine, pos+matchLength, y + fx.offsetY)-startHighlightPos) * fontWidth
                t.fillRect(
                    startFillHighlight,
                    y * fontHeight,
                    highlightLength,
                    fontHeight
                )
            }
        }
        
        if (theLine && wordAtCursorRegexp) {
            // TODO: regular search can benefit from this matchAll business
            // TODO: you can cache the line and the end result of the matches!
            var matches = theLine.matchAll(wordAtCursorRegexp)
            for (const match of matches) {
                // first non null index - 1 (first index is total match)
                var _regI
                var _regLen
                for (_regI=1; _regI < match.length; _regI++) {
                    var captureItem = match[_regI]
                    if (captureItem) {
                        _regLen = captureItem.length
                        break
                    }
                }
                _regI -= 1 // because first item is full match then capture groups


                // TODO: expanding the same line, we could come up with optimization for that
                var startHighlightPos = expandTabIndex(theLine, match.index, y + fx.offsetY)
                var startFillHighlight = (startHighlightPos - fx.offsetX) * fontWidth
                var highlightLengthChars = (expandTabIndex(theLine, match.index+_regLen, y + fx.offsetY)-startHighlightPos)
                var highlightLength = highlightLengthChars * fontWidth
                // this is copied from highlightmatches but there is only one
                if (_regI >= 1) {
                    continue 
                }
                t.fillStyle = "gray"
                t.fillRect(
                    startFillHighlight,
                    // (y * fontHeight) + (5/6 * fontHeight),
                    (y * fontHeight) + (fontHeight) - (1/6/2 * fontHeight),
                    highlightLength,
                    fontHeight/6
                )
            }
        }

        if (theLine && highlightMatchesSingleRegExp) {
            // TODO: regular search can benefit from this matchAll business
            // TODO: you can cache the line and the end result of the matches!
            var matches = theLine.matchAll(highlightMatchesSingleRegExp)
            for (const match of matches) {
                // first non null index - 1 (first index is total match)
                var _regI
                var _regLen
                for (_regI=1; _regI < match.length; _regI++) {
                    var captureItem = match[_regI]
                    if (captureItem) {
                        _regLen = captureItem.length
                        break
                    }
                }
                _regI -= 1 // because first item is full match then capture groups


                // TODO: expanding the same line, we could come up with optimization for that
                var startHighlightPos = expandTabIndex(theLine, match.index, y + fx.offsetY)
                var startFillHighlight = (startHighlightPos - fx.offsetX) * fontWidth
                var highlightLengthChars = (expandTabIndex(theLine, match.index+_regLen, y + fx.offsetY)-startHighlightPos)
                var highlightLength = highlightLengthChars * fontWidth

                if (_regI >= highlightMatches.length) {
                    continue 
                }
                t.fillStyle = highlightMatches[_regI].BackgroundColor
                // t.fillRect(
                //     startFillHighlight,
                //     y * fontHeight,
                //     highlightLength,
                //     fontHeight
                // )
                t.fillRect(
                    startFillHighlight,
                    // (y * fontHeight) + (5/6 * fontHeight),
                    (y * fontHeight) + (fontHeight) - (1/6/2 * fontHeight),
                    highlightLength,
                    fontHeight/6
                )
            }
        }
        

        // Trailing whitespace
        var highlightStartSearch = 0
        var matchLength = 0
        if (fx.fileMode == "file" && theLine) {
            for (var _i=0; _i<1; _i++) { // Loop so we can break
                var theMatch = theLine.match(trailingWhitespaceRegexp)
                if (theMatch == null) {
                    break
                }
                matchLength = theMatch[0].length
                pos = highlightStartSearch + theMatch.index
                // lime
                if (theMatch[0] == "\r") {
                    t.fillStyle = "rgba(255,0,0,.05)"
                } else if (isDark) {
                    // t.fillStyle = "salmon"
                    t.fillStyle = "rgb(255, 140, 105, 0.25)"
                } else {
                    // t.fillStyle = "salmon"
                    t.fillStyle = "rgb(255, 140, 105, 0.25)"
                }

                var startHighlightPos = expandTabIndex(theLine, pos, y + fx.offsetY)
                var startFillHighlight = (startHighlightPos - fx.offsetX) * fontWidth
                var highlightLengthChars = (expandTabIndex(theLine, pos+matchLength, y + fx.offsetY)-startHighlightPos)
                var highlightLength = highlightLengthChars * fontWidth
                if ((y + fx.offsetY == fx.cursorLineIndex) && (startHighlightPos + highlightLengthChars == fx.cursorColIndex)) {
                    // Don't annoy with warning when they are typing
                } else {
                    t.fillRect(
                        startFillHighlight,
                        y * fontHeight,
                        highlightLength,
                        fontHeight
                    )
                }
            }
        }

        if (true) {
            if (y + fx.offsetY < fx.lines.length) {
                var lineNumber = (y+fx.offsetY+1).toString().padStart(marginLeft-1, " ")
                if (fx.offsetX < -1) {
                    // Line numbers

                    if (fx.lines[y + fx.offsetY] != "" && fx.lines[y + fx.offsetY - 1] == fx.lines[y + fx.offsetY]) {
                        // handy feature to see if lines are same
                        t.fillStyle = "lime"
                    } else {
                        t.fillStyle = lineNumberColor
                    }
                    for (var i=0; i<-fx.offsetX-1; i++) {
                        var lineNumberIndex = fx.offsetX + marginLeft + i
                        var lineNoChr = lineNumber.charAt(lineNumberIndex)
                        if (lineNoChr != " ") {
                            t.fillText(lineNoChr, i*fontWidth, y*fontHeight)
                        }
                    }
                }
            }
        }
        // TODO: set variable for line.trim()
        var textFillStyle
        // the actual text
        var commentLine = false
        // TODO: maybe pull some of this out of the loop
        let cachedTrim
        var trim = function() {
            if (typeof cachedTrim != "undefined") {
                return cachedTrim
            }
            cachedTrim = theLine.trim()
            return cachedTrim
        }
        if (fx.fileMode != "terminal") {
            if (theLine.startsWith("+")) {
                textFillStyle = isDark ? "lime" : "green"
            } else if (theLine.startsWith("-")){
                textFillStyle = "red"
            // } else if (trim().startsWith("// mar"+"ker ") || trim().startsWith("# mar"+"ker ")) {
            } else if (trim().endsWith("mar"+"ker")) {
                // do a fill rect of the color that comes after
                // Not using save and restore because my mock canvas doesn't support it
                var oldFillStyle = t.fillStyle
                // var theFillStyle = trimPrefix(theLine.trim(), "// mar"+"ker ").split(" ")[0]
                // var theFillStyle = trimPrefix(trimPrefix(trim(), "// mar"+"ker "), "# mar"+"ker ").split(" ")[0]
                // TODO: faster snagging of the color
                var theParts = trim().split(" ")
                theFillStyle = theParts[theParts.length - 2]
                t.fillStyle = theFillStyle
                // go twice as wide as you need, for server rendering purposes
                // t.fillRect(0, y * fontHeight, c.width*2, fontHeight)

                var [newStartX, adjustment] = skipLeadingSace(theLine, 0, fx.offsetX, y + fx.offsetY, fx) // red marker
                t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (expandTabIndex(theLine, -1, y+fx.offsetY)-adjustment)*fontWidth, underlineHeight) // red marker

                textFillStyle = fontColor
                // if (knownContrastingColors[t.fillStyle]) {
                //     textFillStyle = knownContrastingColors[t.fillStyle]
                // } else {
                //     colorGetterEl.style.backgroundColor = t.fillStyle
                //     // I think the t.fillStyle gets normalized as #RRGGBB, so you could have used that.
                //     var rgbColor = window.getComputedStyle(colorGetterEl).backgroundColor
                //     var grayed = ll(rgbColor, "n n n", function(r, g, b) {
                //         // googled this
                //         return (0.3 * r) + (.59 * g) + (.11 * b)
                //     })
                //     if (grayed < 128) {
                //         textFillStyle = "white"
                //     } else {
                //         textFillStyle = "black"
                //     }
                //     knownContrastingColors[t.fillStyle] = textFillStyle
                // }
                t.fillStyle = oldFillStyle

            } else if (trim().startsWith("//") || trim().startsWith("#")) {
                commentLine = true
                // comments are gray
                textFillStyle = lightFontColor
            } else {
                // feature to gray out lines before where you are scrolled to
                // var spaceCount = getSpaceCount(theLine)
                // if (spaceCount < fx.offsetX && (y + fx.offsetY) != fx.cursorLineIndex) {
                //     t.fillStyle = lightFontColor
                // } else {
                //     t.fillStyle = fontColor
                // }
                textFillStyle = fontColor
            }
        } else {
            textFillStyle = fontColor
        }


        theLine = theLine || ""
        var expandedLine = ""
        var tabStop = globalTabStop
        var afterLastTabPos = 0
        if (compactRender && !commentLine) {
            var lineAndInfo = compactLine(theLine, y + fx.offsetY)
            theNewLine = lineAndInfo.compactedLine

            if (theNewLine != theLine) {
                textFillStyle = isDark ? "lime" : "green"
            }

            theLine = theNewLine
        }

        // expandedLine = [...expandedLine]
        if (useUnicode) {
            // you could render inline here

            if (theLine.tabCache) {
                expandedLine = theLine.tabCache
            } else if (theLine == "") {
                expandedLine = []
            } else {
                expandedLine = getCachedGraphemes(theLine, y + fx.offsetY)
                expandedLine = expandedLine.slice() // copy it
                // log(Date.now().toString().slice(-4) + " expanding")
                var i = 0
                while (true) {
                    i++
                    if (i === 500) {
                        alert("loop err 3")
                        break
                    }
                    var tabPos = expandedLine.indexOf("\t", afterLastTabPos)
                    if (tabPos == -1) {
                        break
                    }
                    var numberOfSpaces = tabStop - ((tabPos) % tabStop) -1
                    // TODO: you can used cached repeated \t array

                    expandedLine.splice(tabPos, 0, ...("\t".repeat(numberOfSpaces).split("")))
                    afterLastTabPos = tabPos + numberOfSpaces + 1
                }
                
                // expanding emojis for double width emojis
                if (emojiWidth != 1 && containsEmoji(theLine)) {
                // if (emojiWidth != 1) {
                    var i = 0
                    var afterLastEmojiPos = 0
                    while (true) {
                        i++
                        if (i === 500) {
                            alert("loop err 4")
                            break
                        }
                        var emojiPos = -1
                        for (var j=afterLastEmojiPos; j<expandedLine.length;j++) {
                            if (isEmoji(expandedLine[j])) {
                                emojiPos = j
                                break
                            }
                        }
                        
                        if (emojiPos == -1) {
                            break
                        }
                    
                        expandedLine.splice(emojiPos+1, 0, ...(" ".repeat(emojiWidth-1).split("")))
                        afterLastEmojiPos = emojiPos + (emojiWidth-1) + 1
                    }
                }
                if ((y + fx.offsetY) < fx.lines.length) {
                    fx.lines[y + fx.offsetY].tabCache = expandedLine
                }

            }
        } else {
            // TODO: you can potentially also cache this part
            while (true) {
                tabPos = theLine.indexOf("\t", afterLastTabPos)
                if (tabPos == -1) {
                    expandedLine += theLine.substr(afterLastTabPos, theLine.length)
                    break
                }
                expandedLine += theLine.substring(afterLastTabPos, tabPos)
                // now add the correct number of spaces, taking into account the tabStop
                var numberOfSpaces = tabStop - (expandedLine.length % tabStop)
                expandedLine += "\t".repeat(numberOfSpaces)
                afterLastTabPos = tabPos + 1
            }
        }

        // one option is to draw the whole line in one go
        // likely more optimal, wouln't have to do the unicode stuff
        // but harder to know wrangle width of the font?
        if (fx.seeOnly && theLine.indexOf(fx.seeOnly) == -1) {
            continue
        }
        var extraY = 0
        for (var x=0; x < maxCols; x++) {
            if ((x+fx.offsetX) >= expandedLine.length) {
                break
            }
            var chr = expandedLine[x+fx.offsetX] || ""
            if (chr == "\t") {
                if (shouldSeeTabs) {
                    t.fillStyle = veryLightFontColor
                    t.fillText("•", x*fontWidth, y*fontHeight)
                }
            } else if (chr != "" && chr != " ") {
                t.fillStyle = textFillStyle

                if (useUnicode) {
                    // if (chr.length > 1) {
                    if (isEmoji(chr)) {
                        t.font = fontCSSEmoji
                        extraY = extraYEmoji
                        // chr = "?"
                    } else {
                        t.font = fontCSS
                        extraY = 0
                    }
                    t.fillText(chr, x*fontWidth, y*fontHeight + extraY)
                } else {
                    t.fillText(chr, x*fontWidth, y*fontHeight)
                }
            }
            if (useUnicode) {
                // revert back
                t.font = fontCSS
            }
        }
        
        // if (expandedLine.length > maxCols) {
        //     t.save()
        //     t.font = fontCSSTiny
        //     t.fillText(theLine.trim(), marginLeft*fontWidth, (y+1)*fontHeight - (0.2*fontHeight))
        //     t.restore()
        // }
    }

    // red ghost cursor
    t.fillStyle = "rgba(255, 0, 0, 0.5)"
    t.fillRect(cursorX, cursorY, 4, fontHeight)

    // cursor
    if (fx.selectedRegions.length) {
        t.fillStyle = "olive"
    } else if (touchCount == 0) {
        t.fillStyle = "orange"
    } else {
        t.fillStyle = "pink"
    }
    var yPos = (fx.cursorLineIndex - fx.offsetY) * fontHeight
    var xPos = (fx.cursorColIndex - fx.offsetX) * fontWidth
    t.fillRect(xPos, yPos, 4, fontHeight)
    cursorLine = fx.lines[fx.cursorLineIndex] || ""

    var duration = Date.now() - startRenderTime
    // TODO: audit render for performance
    // also, we are calling it too much, cut down on number of times we call it

    renderCount += 1
    renderDuration += duration
    rendersInLastSecond += 1
    if (renderCount == 50) {
        // log("render avg: " + Math.round(renderDuration/renderCount))
        renderCount = 0
        renderDuration = 0
    }
}

var trailingWhitespaceRegexp = /\s+$/

false && setInterval(function() {
    if (rendersInLastSecond > 0) {
        log("rendersInLastSecond: " + rendersInLastSecond)
    }
    rendersInLastSecond = 0
}, 1000)

// simple cache for regexp so we don't need to recompile in render loop
// also so I don't have to keep track of whenever searchText.value is set (although maybe consider doing it that way in another pass)
var lastSearchRegexpText = ""
var lastSearchRegexp = null
function cachedSearchRegexp(str) {
    if (str == lastSearchRegexpText) {
        return lastSearchRegexp
    }
    lastSearchRegexpText = str
    try {
        lastSearchRegexp = new RegExp(lastSearchRegexpText)

        // Case insensitive
        lastSearchRegexp = new RegExp(lastSearchRegexpText, 'i')
    } catch (e) {
        lastSearchRegexpText = ""
        lastSearchRegexp = null
    }
    return lastSearchRegexp
}

// just like cachedSearchRegexp but a global regexp for searching backwards
var lastSearchRegexpGlobalText = ""
var lastSearchRegexpGlobal = null
function cachedSearchRegexpGlobal(str) {
    if (str == lastSearchRegexpGlobalText) {
        return lastSearchRegexpGlobal
    }
    lastSearchRegexpGlobalText = str
    try {
        lastSearchRegexpGlobal = new RegExp(lastSearchRegexpGlobalText, 'gi')
    } catch (e) {
        lastSearchRegexpGlobalText = ""
        lastSearchRegexpGlobal = null
    }
    return lastSearchRegexpGlobal
}

function ensureSign(sign, v) {
    if (sign < 0 && v > 0) return -v
    if (sign > 0 && v < 0) return -v
    return v
}

// todo: use min, max in some places where you used bind
function min(a, b) {
    return a < b ? a : b
}

function max(a, b) {
    return a > b ? a : b
}

function moveHomeEndAction() {
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    switch (moveHomeEndDirection) {
       case "up":
           // TODO: jump to markers once you add that feature?
           // make an implicit marker of where you last were?
           // var oldSearchText = searchText.value
           // searchText.value = "// mar"+"ker "
           // var found = findUp()
           // searchText.value = oldSearchText
           // if (!found) {
               fx.cursorLineIndex = 0
           // }
           break;
       case "down":
           // TODO: jump to markers
           // var oldSearchText = searchText.value
           // searchText.value = "// mar"+"ker "
           // var found = findDown()
           // searchText.value = oldSearchText
           // if (!found) {
               fx.cursorLineIndex = fx.lines.length - 1
           // }
           break;
       case "left":
           var theIndent = getIndent(theLine)
           fx.cursorColIndex = expandTabIndex(theLine, theIndent.length)
           break;
       case "right":
           fx.cursorColIndex = expandTabIndex(theLine, theLine.length)
           break;
   }
   if (document.activeElement == theText) {
       //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
       setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
   }
   ensureCursorInScreen()
   render()
}

var overflowX = 0
var overflowY = 0
var iframeOverflowX = 0
var isDragKeyboard = false
var touchCount = 0
var isSelectedFromTopThird = false

function onStart(e) {
    touchCount = e.touches.length
    e.preventDefault()
    // this handles all the touch interactions
    // first define the closuure functions
    isSelectedFromTopThird = false
    // this is global
    if (e.touches.length == 1) {
        selectAction = function(forceLines = false) {
            // return early in case we are already selecting
            if (cursorType == "select") {
                return
            }
            fx.selectedRegions = []
            cursorType = "select"
            var line = fx.lines[fx.cursorLineIndex] || ""
            selectedRegion.startX = bind(forceLines ? 0 : fx.cursorColIndex, 0, expandTabIndex(line, line.length))
            selectedRegion.startY = bind(fx.cursorLineIndex, 0, fx.lines.length-1)
            // Note how the stopY is inclusive
            // But the stopX is exclusive.
            // for some reason seemed natural to do it like that
            // was here
            selectedRegion.stopX = bind(fx.cursorColIndex, 0, expandTabIndex(line, line.length))
            selectedRegion.stopY = bind(fx.cursorLineIndex, 0, fx.lines.length - 1)
            if (fx.cursorColIndex < 0 || forceLines) {
                selectedRegion.stopped = true
                selectMode = "line"
                selectedRegion.stopX = expandTabIndex(line, line.length)
            } else {
                selectMode = "char"
            }
            fx.selectedRegions.push(selectedRegion)
            render()
        }
    }

    var hasDoneOverflowXAction = false
    hasDoneOverflowYAction = false
    var hasNavedBack = false
    var startCursorColIndex = fx.cursorColIndex
    var startCursorLineIndex = fx.cursorLineIndex

    var onMove = function(e) {
        lastAction = "move"
        lastSearchDirForSameTerm = ""
        shouldAutocompleteLine = false
        hasMovedSinceNewLine = true
        hasMovedSinceCut = true
        wasDelete = false // so a previous delete doesn't cause split line when you don't want
        acWord = null
        clearTimeout(selectTimeout)
        if (e.touches.length > 1) {
            return
        }
        if (cursorType != "select") {
            selectTimeout = setTimeout(selectAction, selectTimeoutMillis)
        }
        var diffTouchX = e.touches[0].pageX - startTouchX
        var diffTouchY = e.touches[0].pageY - startTouchY
        //cursorX = bind(startX + diffTouchX*touchScale, 0, canvasWidth)
        //cursorY = bind(startY + diffTouchY*touchScale, 0, canvasHeight)

        moved = true
        if (diffTouchX > 10 || diffTouchY > 10) {
            movedWithBuffer = true
        }
        var diffLastTouchX = e.touches[0].pageX - lastTouchX
        var diffLastTouchY = e.touches[0].pageY - lastTouchY
        var signX = diffLastTouchX < 0 ? -1: 1
        var signY = diffLastTouchY < 0 ? -1 : 1
        thePow = firstMove ? 1 : 2

        // other attempt at #snappingCursor
        // var charBefore = fx.lines[fx.cursorLineIndex][u(fx.cursorColIndex)-1] || ""
        // var charAfter = fx.lines[fx.cursorLineIndex][u(fx.cursorColIndex)]  || ""
        // var oldTouchScaleX = touchScaleX
        // // if (((charBefore != charAfter) && (!isWordy(charBefore.charAt(0))) || !isWordy(charAfter.charAt(0))) || fx.cursorColIndex == 0 || fx.cursorColIndex == expandTabIndex(fx.lines[fx.cursorLineIndex], -1)) {
        // if ((charBefore != charAfter) && (!isWordy(charBefore.charCodeAt(0)) || !isWordy(charAfter.charCodeAt(0))) ) {
        //     // log([charBefore, charAfter, isWordy(charBefore.charCodeAt(0))])
        //     log("yay")
        //     touchScaleX = touchScaleX / 10
        // }
        if (!lockX) {
            var toAddX = ensureSign(signX, Math.round(Math.pow(diffLastTouchX, thePow)*touchScaleX))
            cursorX = cursorX + toAddX
            if (fx.iframe) {
                fx.iframeCursorX += toAddX/3
            }
        }
        // touchScaleX = oldTouchScaleX

        var toAddY = ensureSign(signY, Math.round(Math.pow(diffLastTouchY, thePow)*touchScaleY))
        if (!hasDoneOverflowYAction) {
            cursorY = cursorY + toAddY
        }
        if (fx.iframe) {
            fx.iframeCursorY += toAddY/3
        }
        lastTouchX = e.touches[0].pageX
        lastTouchY = e.touches[0].pageY
        if (fx.iframe) {
            // TODO! cache the clientHeights? like globally even?
            var iframeChangedY = false
            if (fx.iframeCursorY > fx.iframeWrapper.clientHeight) {
                var extendY = fx.iframeCursorY - fx.iframeWrapper.clientHeight
                fx.iframeCursorY = fx.iframeWrapper.clientHeight
                var wantScrollTop = fx.iframeWrapper.scrollTop + extendY
                if (wantScrollTop > fx.iframe.clientHeight*iframeScale - fx.iframeWrapper.clientHeight) {
                    var oldScrollTop = fx.iframeWrapper.scrollTop
                    fx.iframeWrapper.scrollTop = fx.iframe.clientHeight*iframeScale - fx.iframeWrapper.clientHeight
                    // fx.iframe.contentWindow.scrollY += wantScrollTop - (oldScrollTop - fx.iframeWrapper.scrollTop)
                    // var n
                    // subtract one because at the edge it doesn't get an element?
                    var el = fx.iframe.contentWindow.document.elementFromPoint(fx.iframeCursorX + fx.iframeWrapper.scrollLeft, fx.iframeCursorY + fx.iframeWrapper.scrollTop - 1);
                    var nextScrollableElement = getNextScrollableElement(el, fx.iframe.contentWindow.document.body)
                    // log({
                    //     el: seeEl(el, fx.iframe.contentWindow.document.body),
                    //     n: seeEl(nextScrollableElement, fx.iframe.contentWindow.document.body),
                    // })
                    if (nextScrollableElement == fx.iframe.contentWindow.document.body) {
                        fx.iframe.contentWindow.scrollTo(fx.iframe.contentWindow.scrollX, fx.iframe.contentWindow.scrollY + wantScrollTop - (oldScrollTop - fx.iframeWrapper.scrollTop) - oldScrollTop)
                    } else {
                        nextScrollableElement.scrollTop = nextScrollableElement.scrollTop + wantScrollTop - (oldScrollTop - fx.iframeWrapper.scrollTop) - oldScrollTop
                    }
                } else {
                    fx.iframeWrapper.scrollTop = wantScrollTop
                }
                iframeChangedY = true
            } else if (fx.iframeCursorY < 0) {
                var extendY = fx.iframeCursorY
                fx.iframeCursorY = 0
                var wantScrollTop = fx.iframeWrapper.scrollTop + extendY
                if (wantScrollTop < 0) {
                    var oldScrollTop = fx.iframeWrapper.scrollTop
                    fx.iframeWrapper.scrollTop = 0
                    var el = fx.iframe.contentWindow.document.elementFromPoint(fx.iframeCursorX + fx.iframeWrapper.scrollLeft, fx.iframeCursorY + fx.iframeWrapper.scrollTop + 1);
                    var nextScrollableElement = getNextScrollableElementUp(el, fx.iframe.contentWindow.document.body)
                    // log({
                    //     el: seeEl(el, fx.iframe.contentWindow.document.body),
                    //     n: seeEl(nextScrollableElement, fx.iframe.contentWindow.document.body),
                    // })
                    if (nextScrollableElement == fx.iframe.contentWindow.document.body) {
                        fx.iframe.contentWindow.scrollTo(fx.iframe.contentWindow.scrollX, fx.iframe.contentWindow.scrollY + wantScrollTop - (oldScrollTop - 0) - oldScrollTop)
                    } else {
                        nextScrollableElement.scrollTop = nextScrollableElement.scrollTop + wantScrollTop - (oldScrollTop - 0) - oldScrollTop
                    }
                } else {
                    fx.iframeWrapper.scrollTop = wantScrollTop
                }
                iframeChangedY = true
            }

            if (fx.iframeCursorX > fx.iframeWrapper.clientWidth) {
                var extendX = fx.iframeCursorX - fx.iframeWrapper.clientWidth
                fx.iframeCursorX = fx.iframeWrapper.clientWidth
                if (!iframeChangedY) {
                    var wantScrollLeft = fx.iframeWrapper.scrollLeft + extendX
                    if (wantScrollLeft > fx.iframe.clientWidth*iframeScale - fx.iframeWrapper.clientWidth) {
                        var oldScrollLeft = fx.iframeWrapper.scrollLeft
                        fx.iframeWrapper.scrollLeft = fx.iframe.clientWidth*iframeScale - fx.iframeWrapper.clientWidth
                        // nextScrollableElement for x direction not yet implemented
                        var nextScrollableElement = fx.iframe.contentWindow.document.body
                        if (nextScrollableElement == fx.iframe.contentWindow.document.body) {
                            fx.iframe.contentWindow.scrollTo(fx.iframe.contentWindow.scrollX + wantScrollLeft - (oldScrollLeft - fx.iframeWrapper.scrollLeft) - oldScrollLeft, fx.iframe.contentWindow.scrollY)
                        } else {
                            nextScrollableElement.scrollLeft = nextScrollableElement.scrollLeft + wantScrollLeft - (oldScrollLeft - fx.iframeWrapper.scrollLeft) - oldScrollLeft
                        }
                    } else {
                        fx.iframeWrapper.scrollLeft = wantScrollLeft
                    }
                }
            } else if (fx.iframeCursorX < 0) {
                var extendX = fx.iframeCursorX
                fx.iframeCursorX = 0
                if (!iframeChangedY) fx.iframeWrapper.scrollLeft += extendX

                // if (fx.iframeWrapper.scrollLeft < 0) {
                //     iframeOverflowX += -marginLeft - fx.iframeWrapper.scrollLeft
                //     fx.iframeWrapper.scrollLeft = -marginLeft
                // }
                // // TODO: come back to startcursorcolindex
                // if (iframeOverflowX > 75 && !hasNavedBack && startCursorColIndex == -marginLeft) {
                //     hasNavedBack = true
                //     fx.iframe.contentWindow.history.back()
                //     saveWorkspace()
                //     iframeOverflowX = 0
                // }
            }

            // show element?
            // fx.currentElement = fx.iframe.contentWindow.document.elementFromPoint(Math.round(fx.iframeCursorX + fx.iframeWrapper.scrollLeft), Math.round(fx.iframeCursorY + fx.iframeWrapper.scrollTop));
            var el = fx.iframe.contentWindow.document.elementFromPoint((fx.iframeCursorX + fx.iframeWrapper.scrollLeft), (fx.iframeCursorY + fx.iframeWrapper.scrollTop));
            if (el) {
                fx.currentElement = el
            }
        }

        var changedY = false
        //var maxHeight = canvasHeight
        var maxHeight = (maxLines -1 ) * fontHeight
        if (cursorY > maxHeight) {
            var extendY = cursorY - maxHeight
            cursorY = maxHeight
            fx.offsetY += Math.ceil(extendY/fontHeight)
            changedY = true
            // maxOffsetY = max(0, fx.lines.length)
            // var maxOffsetY = max(0, fx.lines.length - maxLines)
            var maxOffsetY = max(0, fx.lines.length - 10)
            if (fx.offsetY > maxOffsetY) {
                overflowY += (fx.offsetY - maxOffsetY)
                fx.offsetY = maxOffsetY
            }
            if (overflowY > 50 && !hasDoneOverflowYAction && startCursorLineIndex >= fx.lines.length-1) {
                clearLog()
                hasDoneOverflowYAction = true
                overflowY = 0
            }
        } else if (cursorY < 0) {
            var extendY = cursorY
            cursorY = 0
            fx.offsetY += Math.floor(extendY/fontHeight)
            changedY = true
            if (fx.offsetY < 0) {
                overflowY += fx.offsetY
                fx.offsetY = 0
            }
            if (overflowY < -50 && !hasDoneOverflowYAction && startCursorLineIndex == 0) {
                log("top action")
                if (fx.fileMode == "shell") {
                    runShellCommand("cd ..")
                } else {
                    reloadFile()
                }
                hasDoneOverflowYAction = true
                overflowY = 0
            }
        }

        // log("startCursorColIndex: " + startCursorColIndex)
        var maxWidth = (maxCols -1) * fontWidth
        //var maxWidth = canvasWidth
        if (cursorX > maxWidth) {
            var extendX = cursorX - maxWidth
            cursorX = maxWidth
            // if (!changedY) fx.offsetX += Math.round(extendX/fontWidth)
            if (!changedY) fx.offsetX += Math.ceil(extendX/fontWidth)
        } else if (cursorX < 0) {
            var extendX = cursorX
            cursorX = 0
            // if (!changedY) fx.offsetX += Math.round(extendX/fontWidth)
            if (!changedY) fx.offsetX += Math.floor(extendX/fontWidth)

            var prevOffsetX = fx.offsetX
            if (fx.offsetX < -marginLeft) {
                // Sign is inconsistent
                overflowX += -marginLeft - fx.offsetX
                fx.offsetX = -marginLeft
            }

            // attempt 1 at swiping left to do an action
            // log("theoffsetx: " + fx.offsetX)
            // if (!hasSwitchedFile && !changedY && startCursorColIndex == -marginLeft && prevOffsetX < -20) {
            //     hasSwitchedFile = true
            //     seeFiles()
            //     // moveFileAllTheWayLeft()
            //     // saveWorkspace()
            // }

            // attempt 2 at swiping left to do an action
            if (overflowX > 75 && !hasDoneOverflowXAction && startCursorColIndex == -marginLeft) {
                hasDoneOverflowXAction = true
                // seeFiles()
                moveFileAllTheWayLeft()
                saveWorkspace()
                overflowX = 0
            }
        }
        var oldCursorLineIndex = fx.cursorLineIndex
        // maybe have a setter for this?
        fx.cursorLineIndex = Math.round(cursorY/fontHeight) + fx.offsetY
        if (oldCursorLineIndex != fx.cursorLineIndex && dirtyInput) {
            saveUndo()
            dirtyInput = false
        }

        // TODO: this so we can get into full line autocomplete mode
        // by scrolling into an empty line and starting to type
        // wondering if this is optimal enough.
        var _line = fx.lines[fx.cursorLineIndex] || ""
        if (_line.trim() == "") {
            hasMovedSinceNewLine = false
        }
        var oldCursorColIndex = fx.cursorColIndex
        fx.cursorColIndex = Math.round(cursorX/fontWidth) + fx.offsetX

        // #snappingCursor try 3
        // this was the best of the 3
        if (false && oldCursorColIndex != fx.cursorColIndex) {
            var theIndex =  u(oldCursorColIndex)
            var theLine = fx.lines[fx.cursorLineIndex] || ""
            // var theChar = theLine.charCodeAt(theIndex)
            if (signX == -1 && theIndex > 0 && theIndex < theLine.length) {
                fx.cursorColIndex = expandTabIndex(theLine, findPrevCharClass(theLine, theIndex-1))
                updateCursorXY()
            } else if (signX == 1 && theIndex > 0 && theIndex < theLine.length) {
                fx.cursorColIndex = expandTabIndex(theLine, findNextCharClass(theLine, theIndex))
                updateCursorXY()
            }
        }

        firstMove = false
        if (cursorType == "select") {
            overflowX = 0
            overflowY = 0
            var line = fx.lines[fx.cursorLineIndex] || ""
            selectedRegion.stopX = bind(fx.cursorColIndex, 0, expandTabIndex(line, line.length))
            selectedRegion.stopY = bind(fx.cursorLineIndex, 0, fx.lines.length-1)
            selectedRegion.stopped = true
            if (fx.cursorColIndex < 0 || selectMode == "line") {
                var _line = fx.lines[fx.cursorLineIndex] || ""
                selectedRegion.stopX = expandTabIndex(_line, _line.length)
            }
        }
        // attempt at #snappingCursor
        // TODO: also look at snapping away whitespace
        // var w = getWordAtCursor()
        // if (w.word != "") {
        //     var theLine = fx.lines[fx.cursorLineIndex] || ""
        //     var wordStartX = expandTabIndex(theLine, w.start)
        //     var wordEndX = expandTabIndex(theLine, w.end)
        //     var percentInWord = (fx.cursorColIndex - wordStartX) / (wordEndX - wordStartX)
        //     log([signX, percentInWord.toFixed(2)])
        //     if (signX == 1 && percentInWord >= .5 && fx.cursorColIndex != wordEndX) { // movedRight
        //         fx.cursorColIndex = wordEndX
        //         updateCursorXY()
        //     } else if (signX == -1 && percentInWord <= .5 && fx.cursorColIndex != wordStartX) { // movedLeft
        //         fx.cursorColIndex = wordStartX
        //         updateCursorXY()
        //     }
        // }


        var w = getWordAtCursor()
        if (w.word) {
            wordAtCursor = w.word
            wordAtCursorRegexp = new RegExp("(\\b" + wordAtCursor + "\\b)", "g")
        } else {
            wordAtCursor = ""
            wordAtCursorRegexp = null
        }
        render()
        // See comment in render asking if we need to do this here too
        // this optimization was for Nokia 1.4,
    	if (agressiveRender || (touchCount == 0 && document.activeElement == theText)) {
            if (document.activeElement == theText) {
                setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
            }
        }

        return false
    }
    var onEnd = function(e) {
        overflowX = 0
        overflowY = 0
        touchCount = e.touches.length
        var touchType = e.changedTouches[0].touchType
        clearTimeout(selectTimeout)
        if (e.touches.length != 0) {
            return
        }

         //         fx.cursorColIndex = wordEndX
        // Testing isDragKeyboard feature red marker
        var sr = fx.selectedRegions[0]
        if (sr) {
            // testing selectMode is char, meaning they didnt select in the margin
            if (sr.startX == sr.stopX && sr.startY == sr.stopY && selectMode == "char") {
                // New mode
                // isDragKeyboard = true
                // fx.selectedRegions = []
                // should we return early here?
                var w = getWordAtCursor()
                if (w.word != "") {
                    var theLine = fx.lines[fx.cursorLineIndex] || ""
                    sr.startY = fx.cursorLineIndex
                    sr.startX = expandTabIndex(theLine, w.start)
                    sr.stopY = fx.cursorLineIndex
                    sr.stopX = expandTabIndex(theLine, w.end)
                } else {
                    fx.selectedRegions = []
                }
            }
        }

        document.body.removeEventListener("touchmove", onMove)
        moveListenerCount = max(moveListenerCount-1, 0)
        document.body.removeEventListener("touchend", onEnd)
        endListenerCount = max(endListenerCount-1, 0)

        // it's not straightforward to do a setTimeout
        // here because iOS Safari doesn't like to focus
        // text elements when not responding to user action
        // maybe there are workarounds.
        var countedAsMoved = moved
        if (touchType == "stylus") {
            countedAsMoved = movedWithBuffer
        }
        
        // TODO: Should we get rid of cursorType variable and just use fx.selectedRegions?
        // did if false here because decided against tap top to aauto
        if (false && !countedAsMoved && cursorType == "select") {
            if (isSelectedFromTopThird) {
                isSelectedFromTopThird = false
                cursorType = "move"
                // #duplicateline
                copy()
                paste()
                fx.selectedRegions = []
                render()
                return
            }
        } else if (!countedAsMoved && cursorType == "move") {
            if (fx.fileMode == "directory") {
                // #filestuff
                // openFile
                clickItemInDirectory()
                return
            }
            // Clicking a file #clickfile #touchfile #tapfile
            if (fx.fileMode == "fileList") {
                if (splicedFiles.length) {
                    files.splice(fx.cursorLineIndex, 0, ...splicedFiles)
                    var prevCursorLineIndex = fx.cursorLineIndex
                    setLines(getLinesForFileList())
                    saveWorkspace()
                    fx.cursorLineIndex = prevCursorLineIndex
                    updateCursorXY()
                    ensureCursorInScreen()
                    splicedFiles = []
                    return
                }
                var file = treeFilesShadow[fx.cursorLineIndex]
                if (file.fileToken == fileToken) {
                    // #filestuff
                    setCurrentFile(file)
                    return
                }
                // here load file that hasn't been loaded
                // in this case "file" var is just a string
                // #filestuff
                // TODO: you could see if there is already one "directory" file here!
                // also TODO: you could not overwrite the lastFile when showing the files view.
                fx = lastFile || files[0]
                addFile(file)
                return
            }


            if (fx.cursorColIndex == -marginLeft) {
                // since we are in the margin, let's force it
                // to paste line-style.
                if (fx.fileMode == "terminal") {
                    sendTerminal(copyBuffer.join("\r"))
                    return
                }
                
                var bbox = c.getBoundingClientRect()
                if ((e.changedTouches[0].pageY - bbox.top) < c.clientHeight/3*2) {
                    comment()
                } else {
                    selectMode = "line"
                    // #tapinmargintopaste
                    paste(false, false, true)
                }
                return
            }
            if (fx.fileMode == "terminal") {
                // #todoterminal send a tab?
                if (document.activeElement == theText) {
                    sendTerminal("\t")
                } else {
                    theText.focus()
                }
                return
            }
            // if (fx.cursorColIndex >= -4 && fx.cursorColIndex <= -1) {
            //     var oldCopyBuffer = copyBuffer
            //     copyBuffer = cutBuffer
            //     paste()
            //     copyBuffer = oldCopyBuffer
            //     return
            // }
            if (fx.cursorColIndex == -4) {
                del()
                return
            }
            if (fx.cursorColIndex == -3) {
                copy()
                paste()
                fx.selectedRegions = []
                return
            }
            if (fx.cursorColIndex == -2) {
                copy()
                return
            }
            if (fx.cursorColIndex == -1) {
                insertLine(true, true)
                return
            }

            // the !hasMovedSinceCut is so we can paste inline without going in to insert mode
            // if (document.activeElement == theText || !hasMovedSinceCut) {
            // when to focus the text // red marker
            // Now you have to tap in middle secrion to edit
            // if (document.activeElement == theText || e.changedTouches[0].pageY > c.clientHeight/3*2) {

            // todo: you could include the getBoundingClientRect().top offset like in other places
            if (document.activeElement == theText || e.changedTouches[0].pageY < c.clientHeight/3*2) { // high section handled on touch start with selecting
                // #alternateTap
                var w = getWordBeforeCursor()
                if (alternateTap && lastAction == "move" || w.word == "") { // red marker
                    var w = getWordAtCursor()
                    log([w, fx.cursorColIndex])
                    //if (w.word == "" || w.start == fx.cursorColIndex) {
                    if (w.word == "") {
                        selectMode = "char"
                        // paste(false, false, true)
                        // #taptopaste
                        paste(false, false, true, true)
                    } else if (w.word != "") {
                        // # taptodelete #taptocut
                        var sr = {}
                        selectMode = "char"
                        var theLine = fx.lines[fx.cursorLineIndex] || ""
                        sr.startY = fx.cursorLineIndex
                        sr.startX = expandTabIndex(theLine, w.start)
                        sr.stopY = fx.cursorLineIndex
                        sr.stopX = expandTabIndex(theLine, w.end)
                        fx.selectedRegions = [sr]
                        del(false, true) // new
                        render()
                    }
                } else {
                    // this condition used to not be there
                    // and we'd acWordToggle every time (alternate paste flow)
                    acWordToggle() // lime marker
                }
            } else {
                if (fx.iframe) {
                    var mouseEventInfo = {
                        view: window,
                        bubbles: true,
                        cancelable: true,
                        screenX: fx.iframeCursorX + fx.iframeWrapper.scrollLeft,
                        screenY: fx.iframeCursorY + fx.iframeWrapper.scrollTop,
                    }
                    var el = fx.iframe.contentWindow.document.elementFromPoint(fx.iframeCursorX + fx.iframeWrapper.scrollLeft, fx.iframeCursorY + fx.iframeWrapper.scrollTop);
                    el.dispatchEvent(new MouseEvent('mouseenter', mouseEventInfo));
                    el.dispatchEvent(new MouseEvent('mouseover', mouseEventInfo));
                    el.dispatchEvent(new MouseEvent('mousedown', mouseEventInfo));
                    el.dispatchEvent(new MouseEvent('mouseup', mouseEventInfo));
                    el.dispatchEvent(new MouseEvent('click', mouseEventInfo));

                    if (el.tagName == "INPUT") {
                        el.focus()
                    } else {
                        sel = fx.iframe.contentWindow.getSelection();
                        setTimeout(function(){
                            range = fx.iframe.contentWindow.document.createRange()
                            range.selectNodeContents(el)
                            sel.removeAllRanges()
                            sel.addRange(range)
                            // fx.iframe.contentWindow.navigator.clipboard.writeText(sel.toString())
                            copyBuffer = sel.toString().split("\n")
                        }, 1);
                    }
                } else {
                    if (fx.cursorLineIndex >= fx.lines.length) {
                        fx.cursorLineIndex = fx.lines.length - 1
                        updateCursorXY()
                        render()
                    }

                    // This part for moving the cursor where you tapped (if you want that feature)
                    // if (false) {
                    if (false) {
                        var bbox = c.getBoundingClientRect()
                        var pointX = startTouchX - bbox.left
                        var pointY = startTouchY - bbox.top
                        fx.cursorColIndex = Math.round(
                            ((pointX * 3)/fontWidth) + fx.offsetX
                        )
                        fx.cursorLineIndex = Math.round(
                            ((pointY * 3)/fontHeight) + fx.offsetY
                        )
                        updateCursorXY()
                    }

                    if (true) {
                        // the handleFocusIn function will do some
                        // processing

                        theText.focus() // aquamarine marker
                    }
                }
            }
        }

        cursorType = "move"
        // #alternateTap
        if (alternateTap && !selectedRegion.stopped) {// this only matters if it is selected I think
            // TODO: what is this feature?
            // for selecting a word?
            // selectWord Fearure (I think we no longer get here)
            // this happens when you hold down for a while and then let go
            // we should deprecate this?
            var w = getWordAtCursor()
            if (w.word != "") {
                var theLine = fx.lines[fx.cursorLineIndex] || ""
                selectedRegion.startY = fx.cursorLineIndex
                selectedRegion.startX = expandTabIndex(theLine, w.start)
                selectedRegion.stopY = fx.cursorLineIndex
                selectedRegion.stopX = expandTabIndex(theLine, w.end)
            } else {
                fx.selectedRegions = []
            }
        }
        render()
    }

    var onMoveWhileSelected = function(e) {
        moved = true
        var diffStartTouchX = e.touches[0].pageX - startTouchX
        var diffStartTouchY = e.touches[0].pageY - startTouchY
        lastTouchX = e.touches[0].pageX
        lastTouchY = e.touches[0].pageY
        if (Math.abs(diffStartTouchX) < 5 && Math.abs(diffStartTouchY) < 5) {
            return
        }
        if (Math.abs(diffStartTouchX) > Math.abs(diffStartTouchY)) {
            if (diffStartTouchX < 0) {
                dedent()
            } else {
                indent()
            }
        } else {
            if (diffStartTouchY < 0) {
                del()
            } else {
                copy()
            }
        }
        // stop handling it once it's handled
        document.body.removeEventListener("touchmove", onMoveWhileSelected)
        moveListenerCount = max(moveListenerCount-1, 0)
    }
    var onEndWhileSelected = function(e) {
        overflowX = 0
        overflowY = 0
        touchCount = e.touches.length
        if (!moved && fx.selectedRegions.length) {
                if (false && selectMode == "line" && (e.changedTouches[0].pageY-c.getBoundingClientRect().top) < c.clientHeight/3*1) {
                // this code got moved to duplicatelinefromtop
                // #duplicateline
                copy()
                paste(true) // true here means unselect
            } else if (selectMode == "line" && (e.changedTouches[0].pageY-c.getBoundingClientRect().top) < c.clientHeight/3*2) {
                comment()
            } else {
                fx.selectedRegions = []
            }
        }
        document.body.removeEventListener("touchmove", onMoveWhileSelected)
        moveListenerCount = max(moveListenerCount-1, 0)
        document.body.removeEventListener("touchend", onEndWhileSelected)
        endListenerCount = max(endListenerCount-1, 0)
        render()
    }

    var onEndForEdges = function(e) {
        overflowX = 0
        overflowY = 0
        touchCount = e.touches.length
        document.body.removeEventListener("touchend", onEndForEdges)
        clearTimeout(moveHomeEndTimeout)
        render()
    }

    var startTouchX = e.touches[0].pageX
    var startTouchY = e.touches[0].pageY
    var startX = cursorX
    var startY = cursorY
    var lastTouchX = startTouchX
    var lastTouchY = startTouchY
    var lastTime = Date.now()
    var firstMove = true
    var moved = false
    var movedLong = false
    var prevCopyBufferForTouch = null
    var movedWithBuffer = false
    var selectedRegion = {}

    // #clickedges #touchedges #tapedges // lime marker
    // scroll right and left and move cursor right and left or up and down
    // TODO: remove some duplication here. especially the bounds checks. Make a setter functions.
    // We divide by 3 because of the whole, points vs pixels
    if (startTouchX > ((canvasWidth/3) - navTouchSize)) {
        var bbox = c.getBoundingClientRect()
        if (startTouchY - bbox.top < (bbox.height/3)) { // this divide by 3 is because of the 3 sections
            moveHomeEndDirection = "down"
            moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
            // log({sm: selectMode})
            // if (fx.highlightText) {
            if (false && highlightMatchesSingleRegExp) {
                nextHighlightText()
            } else if (!fx.selectedRegions.length || selectMode == "char") {
                findDown()
            } else {
                fx.cursorLineIndex += 1
                if (fx.cursorLineIndex >= fx.lines.length) {
                    fx.cursorLineIndex = fx.lines.length - 1
                }
                ensureCursorInScreen()
                if (fx.selectedRegions.length) {
                    fx.selectedRegions[0].stopY += 1
                    if (fx.selectedRegions[0].stopY > fx.lines.length - 1) { // stopY is inclusive I think, stopX isn't
                        fx.selectedRegions[0].stopY = fx.lines.length - 1
                    }
                    var theLine = fx.lines[fx.selectedRegions[0].stopY] || ""
                    fx.selectedRegions[0].stopX = expandTabIndex(theLine, theLine.length, fx.selectedRegions[0].stopY)
                } else if (document.activeElement != theText) {
                    fx.offsetY += 1
                    if (fx.offsetY > fx.lines.length - 10) {
                        fx.offsetY = lines.length - 10
                    }
                }
            }
        // } else if (startTouchY - bbox.top < (bbox.height*2/3)) {
        // } else if (startTouchY - bbox.top > (bbox.height*2/3)) {
        // weird changeup of second and third section depending on if you are editing.Not sure if I like.
        } else if ((document.activeElement != theText && (startTouchY - bbox.top > (bbox.height*2/3))) || (document.activeElement == theText && (startTouchY - bbox.top < (bbox.height*2/3)))) { // lime marker
            var fileIndex = files.indexOf(fx)
            if (fileIndex != -1) {
                fileIndex = fileIndex+1
                if (fileIndex < 0) {
                    fileIndex = -1
                } else if (fileIndex >= files.length) {
                    fileIndex = files.length - 1
                }
            } else {
                fileIndex = 0
            }
            if (fileIndex == -1) {
                seeFiles()
            } else {
                setCurrentFile(files[fileIndex])
            }
        } else if (fx.selectedRegions.length) {
            fx.selectedRegions[0].stopX += 1
            var theLine = fx.lines[fx.selectedRegions[0].stopY] || ""
            var expandedIndex = expandTabIndex(theLine, theLine.length, fx.selectedRegions[0].stopY)
            if (fx.selectedRegions[0].stopX > expandedIndex) {
                fx.selectedRegions[0].stopX = expandedIndex
            }
        } else if (fx.fileMode == "fileList" || fx.fileMode == "directory") {
            fx.cursorLineIndex += 1
            if (fx.cursorLineIndex >= fx.lines.length) {
                fx.cursorLineIndex = fx.lines.length - 1
            }
            ensureCursorInScreen()
        } else {
            if (false && searchText.value) {
                findDown()
            } else {
                moveHomeEndDirection = "right"
                moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
                // the "true ||" essentially comments out the shift screen to the left feature
                // in practice it wasn't that helpful because I did one char at a time
                if (true || document.activeElement == theText) {
                    fx.cursorColIndex += 1
                    if (document.activeElement == theText) {
                        //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
                        setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
                    }
                    ensureCursorInScreen()
                } else {
                    var origOffsetX = fx.offsetX
                    // scroll by tabstop?
                    if (false && fx.offsetX < 0) {
                        fx.offsetX = 0
                    }  else {
                        // var tabStop = 4
                        var tabStop = 1 // we changed this to only move one cursor at a time
                        fx.offsetX = Math.ceil((fx.offsetX + 1) / tabStop) * tabStop
                    }
                    ////fx.offsetX += Math.floor(maxCols/2)
                    // fx.cursorColIndex += fx.offsetX - origOffsetX
                    fx.cursorColIndex += 1
                }
            }
        }
        document.body.addEventListener("touchend", onEndForEdges)
        updateCursorXY()
        render()
        return
    } else if (startTouchX < navTouchSize) {
        var bbox = c.getBoundingClientRect()
        if (startTouchY - bbox.top < (bbox.height/3)) {
            moveHomeEndDirection = "up"
            moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)

            // if (fx.highlightText) {
            if (false && highlightMatchesSingleRegExp) {
                prevHighlightText()
            // } else if (searchText.value !== "" && !fx.selectedRegions.length) {
            } else if (!fx.selectedRegions.length || selectMode == "char") {
                findUp()
            } else {
                fx.cursorLineIndex -= 1
                if (fx.cursorLineIndex < 0) {
                    fx.cursorLineIndex = 0
                }
                ensureCursorInScreen()
                if (fx.selectedRegions.length) {
                    fx.selectedRegions[0].stopY -= 1
                    if (fx.selectedRegions[0].stopY < fx.selectedRegions[0].startY) {
                        fx.selectedRegions[0].stopY = fx.selectedRegions[0].startY
                    }
                    var theLine = fx.lines[fx.selectedRegions[0].stopY] || ""
                    fx.selectedRegions[0].stopX = expandTabIndex(theLine, theLine.length, fx.selectedRegions[0].stopY)
                } else if (document.activeElement != theText) {
                    fx.offsetY -= 1
                    if (fx.offsetY < 0) {
                        fx.offsetY = 0
                    }
                }
            }
        // } else if (startTouchY - bbox.top < (bbox.height*2/3)) {
        // } else if (startTouchY - bbox.top > (bbox.height*2/3)) {
        } else if ((document.activeElement != theText && (startTouchY - bbox.top > (bbox.height*2/3))) || (document.activeElement == theText && (startTouchY - bbox.top < (bbox.height*2/3)))) { // lime marker
            var fileIndex = files.indexOf(fx)
            if (fileIndex != -1) {
                fileIndex = fileIndex-1
                if (fileIndex < 0) {
                    fileIndex = -1
                } else if (fileIndex >= files.length) {
                    fileIndex = files.length - 1
                }
            } else {
                fileIndex = 0
            }
            if (fileIndex == -1) {
                seeFiles()
            } else {
                setCurrentFile(files[fileIndex])
            }
        } else if (fx.selectedRegions.length) {
            fx.selectedRegions[0].stopX -= 1
            if (fx.selectedRegions[0].stopX < 0) {
                fx.selectedRegions[0].stopY = 0
            }
        } else if (fx.fileMode == "fileList" || fx.fileMode == "directory") {
            fx.cursorLineIndex -= 1
            if (fx.cursorLineIndex < 0) {
                fx.cursorLineIndex = 0
            }
            ensureCursorInScreen()
        } else {
            if (false && searchText.value) {
                findUp()
            } else {
                moveHomeEndDirection = "left"
                moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
                // the "true ||" essentially comments out the shift screen to the left feature
                // in practice it wasn't that helpful because I did one char at a time
                if (true || document.activeElement == theText) {
                    fx.cursorColIndex -= 1
                    if (document.activeElement == theText) {
                        //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
                        setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
                    }
                    ensureCursorInScreen()
                } else {
                    var origOffsetX = fx.offsetX
                    if (false && fx.offsetX <= 0) {
                        fx.offsetX = -marginLeft
                    }  else {
                        // var tabStop = 4
                        var tabStop = 1 // we changed this to only move one cursor at a time
                        fx.offsetX = Math.floor((fx.offsetX-1) / tabStop) * tabStop
                    }
                    // fx.cursorColIndex += fx.offsetX - origOffsetX
                    fx.cursorColIndex -= 1
                    if (fx.cursorColIndex < -marginLeft) {
                         fx.cursorColIndex = -marginLeft
                    }
                }
            }
        }
        if (fx.cursorColIndex < -marginLeft){
            fx.cursorColIndex = -marginLeft
        }
        // if (fx.cursorColIndex < 0){
        //     fx.cursorColIndex = 0
        // }
        if (fx.offsetX < -marginLeft){
            fx.offsetX = -marginLeft
        }
        document.body.addEventListener("touchend", onEndForEdges)
        updateCursorXY()
        render()
        return
    } else {
        var bbox = c.getBoundingClientRect()
        // TODO: is there any difference between cursorType select and selectedRegions.length > 0
        // if (fx.selectedRegions.length == 0 && cursorType != "select" && document.activeElement != theText && (startTouchY - bbox.top < (bbox.height/3)) ) {
        // TODO: consider allowing this on edit mode.
        if ((startTouchY - bbox.top < (bbox.height/3)) && document.activeElement != theText) { // hotpink marker
            // touch top third to select #topthird  #selectline #touchtop
            if (fx.selectedRegions.length == 0) {
                isSelectedFromTopThird = true
                // see onEndWhileSelected for one way to duplicate line (#duplicateline)
                selectAction(true)

                // TODO: maybe figure out how to not copy paste this?
                document.body.addEventListener("touchmove", onMove)
                moveListenerCount += 1
                document.body.addEventListener("touchend", onEnd)
                endListenerCount += 1
                return
            } else {
                // # duplicateline #duplicatelinefromtop
                var oldSelectedRegions = fx.selectedRegions
                copy()
                paste(true) // true here means unselect
                fx.selectedRegions = oldSelectedRegions
                render()
                return
            }
        }
    }
    if (fx.selectedRegions.length) {
        // idea: if 2 touches while selected
        // do something else like comment
        document.body.addEventListener("touchmove", onMoveWhileSelected)
        moveListenerCount += 1
        document.body.addEventListener("touchend", onEndWhileSelected)
        endListenerCount += 1
    } else {
        if (e.touches.length > 1 && cursorType != "select") {
            // this selectAction is the one from the first touch
            // select action will not get set on the second touch
            selectAction()
            return
        }

        var bbox = c.getBoundingClientRect()

        if (startTouchY - bbox.top < navTouchSize) {
            if (document.activeElement == theText && !acWord) {
               shouldAutocompleteLine = true
            } else if (false) { // commenting out the page down feature
                var origOffsetY = fx.offsetY
                fx.offsetY -= Math.round(maxLines/2)
                if (fx.offsetY <= 0) {
                    fx.offsetY = 0
                }
                fx.cursorLineIndex += fx.offsetY - origOffsetY
                updateCursorXY()
                render()
                return
            }
        }
        // commenting out the page down feature
        if (false && (bbox.top + bbox.height) - startTouchY < navTouchSize) {
            if (document.activeElement == theText) {
            } else {
                var origOffsetY = fx.offsetY
                fx.offsetY += Math.round(maxLines/2)
                if (fx.offsetY >= lines.length - 10) {
                    fx.offsetY = lines.length - 10
                }
                fx.cursorLineIndex += fx.offsetY - origOffsetY
                updateCursorXY()
                render()
                return
            }
        }

        selectTimeout = setTimeout(selectAction, selectTimeoutMillis)
        document.body.addEventListener("touchmove", onMove)
        moveListenerCount += 1
        document.body.addEventListener("touchend", onEnd)
        endListenerCount += 1
    }
    render()
}

function seeEl(el, body) {
    if (!el) {
        return null
    }

    return {
        tagName: el.tagName,
        id: el.id,
        className: el.className,
        isBody: el == body,
        tostring: el.toString()

    }
}

function getNextScrollableElement(el, body) {
    if (!el) {
        return body
    }
    if (el == body) {
        return body
    }
    if (el.scrollHeight > el.clientHeight && el.scrollTop < el.scrollHeight - el.clientHeight) {
        return el
    }

    return getNextScrollableElement(el.parentElement, body)
}
function getNextScrollableElementUp(el, body) {
    if (!el) {
        return body
    }
    if (el == body) {
        return body
    }
    if (el.scrollHeight > el.clientHeight && el.scrollTop > 0) {
        return el
    }

    return getNextScrollableElementUp(el.parentElement, body)
}
function clickItemInDirectory() {
    var prefix = fx.fullPath
    // To prevent leading double slash
    if (prefix == "/") {
        prefix = ""
    }
    var addPath = fx.lines[fx.cursorLineIndex]
    if (addPath == "..") {
        var parts = prefix.split("/")
        if (parts.length > 0) {
            parts = parts.slice(0, parts.length - 1)
        }
        var newFullPath = parts.join("/")
    } else {
        var newFullPath = prefix + "/" + addPath
    }
    var color = fx.color
    var group = fx.group
    var preventSelect = true
    var closedLeftMostFile = false
    if (fx.cursorColIndex != -marginLeft) {
        if (files[0] == fx) {
            closedLeftMostFile = true
        }
        closeFile()
        preventSelect = false
    }
    // log("add before: " + closedLeftMostFile)
    var newFile = addFile(newFullPath, {
        preventSelect: preventSelect,
        addBefore: closedLeftMostFile
    })
    
    if (newFile) {
        // we do this because of the close, which doesn't always happen
        newFile.color = color
        newFile.group = group
        // note, this call already happens above but we need to re-render it
        //  because we set the color after the fact.
        renderFileDropdown()
    }
}


// fuzzyMatch("fzy", "if")
// false
// fuzzyMatch("fzy", "fuzzy")
// true
function fuzzyMatch(fuzzyWord, word) {

    if (!word) {
        return false
    }
    // make sure the first letter matches
    if (fuzzyWord.charAt(0).toLowerCase() != word.charAt(0).toLowerCase()) {
        return false
    }
    if (word.length > 50) {
        // prevent against long base64 values from matching
        return false
    }

    fuzzyWord = fuzzyWord.toLowerCase()
    word = word.toLowerCase()
    var lastMatch = -1
    for (var i=0; i<fuzzyWord.length; i++) {
        var chr = fuzzyWord.charAt(i)
        lastMatch = word.indexOf(chr, lastMatch+1)
        if (lastMatch == -1) {
            return false
        }
    }
    return true
}
var fuzzyAutocomplete = true

var shouldAutocompleteLine = false
// NEW FIND WORD
var acWord = null
function acWordToggle(recursive) {
    if (acWord == null) {
        var w
        if (lastAction == "move") {
            w = getWordAtCursor()
        } else {
            if (shouldAutocompleteLine) {
                w = {
                    // do we need statrt and end
                    word: (fx.lines[fx.cursorLineIndex] || "").trim()
                }
            } else {
                w = getWordBeforeCursor()
            }
        }

        acWord = {
            startY: fx.cursorLineIndex,
            stopY: fx.cursorLineIndex,
            hasPlopped: false,
            seen: {}
        }
        var theLine = fx.lines[fx.cursorLineIndex]
        if (lastAction == "type") {
            // start on autocomplete line
            //if (theLine.substring(0, w.start)
            acWord.prefix = w.word
            acWord.word = w.word

            // fuzzy
            acWord.startXNonFuzzy = fx.cursorColIndex
            acWord.stopXNonFuzzy = fx.cursorColIndex
            acWord.startX = expandTabIndex(theLine, w.start)
            acWord.stopX = expandTabIndex(theLine, w.end)

            // to prevent autocomplet in the middle
            // of a word from getting that compound word.
            var _w = getWordAtCursor()
            acWord.seen[_w.word] = true

            // if it's the start of the line
            // do autocomplete whole line
            // works for languages where lines start with words usually
            //if (theLine.trim() == w.word) {
            // if (theLine.trim() == w.word && !hasMovedSinceNewLine) {
            if (shouldAutocompleteLine) {
                acWord.autocompleteLine = true
            }
            shouldAutocompleteLine = false
        } else {
            acWord.startX = expandTabIndex(theLine, w.start)
            acWord.stopX = expandTabIndex(theLine, w.end)
            acWord.word = w.word
        }
        acWord.fileIndex = files.indexOf(fx)
        if (acWord.fileIndex == -1) {
            acWord.fileIndex = 0
        }
        acWord.findUpX = fx.lines[fx.cursorLineIndex].length
        acWord.findUpY = fx.cursorLineIndex
        if (acWord.autocompleteLine) {
            acWord.findUpY = fx.cursorLineIndex <= 0 ? 0 : fx.cursorLineIndex - 1
        }
        acWord.findDownX = 0
        acWord.findDownY = fx.cursorLineIndex + 1
        acWord.findDirection = false // true: up, false: down
        acWord.toggleCount = 0
        acWord.clearedWord = acWord == ""
        acWord.pasteLastCleared = false
        acWord.pastedLastTyped = false
        acWord.pastedCopyBufferInLine = false
        // acWord.pastedCutBufferInLine = false
        acWord.findUpDone = false
        acWord.findDownDone = false
        // so replacements don't affect search
        acWord.origLine = fx.lines[fx.cursorLineIndex]
    }
    // single for loop so we can break
    loopBlock:
    for (var s=0; s<1; s++) {
        if (acWord.prefix) {
            // just autocomplete
            var loopCount = 0
            var found = ""
            loopFind:
            while (true) {
                found = ""
                loopCount += 1
                if (loopCount > 1000) {
                    alert("eek!")
                    break loopFind
                }
                acWord.findDirection = !acWord.findDirection
                if (acWord.fileIndex >= files.length) {
                    //alert("allDone")

                    if (acWord.autocompleteLine || !fuzzyAutocomplete) {
                        acPlop([""])
                    } else {
                        acPlop([acWord.prefix])
                    }
                    // not going to cycle to turn on shouldAutocompleteLine
                    // if (!acWord.autocompleteLine) {
                    //    shouldAutocompleteLine = true
                    // }
                    if (acWord.autocompleteLine && !acWord.hasPlopped && !recursive) {
                        acWord = null
                        acWordToggle(true)
                        return
                    }
                    acWord = null
                    return
                }
                if (acWord.findUpDone && acWord.findDownDone) {
                    acWord.findUpX = 0
                    acWord.findDownX = 0
                    acWord.findUpY = -1
                    acWord.findDownY = 0
                    acWord.findDirection = true // so next loop it goes down
                    acWord.findUpDone = true
                    acWord.findDownDone = false
                    if (acWord.fileIndex == files.indexOf(fx) && acWord.fileIndex != 0) {
                        acWord.fileIndex = 0
                    } else {
                        acWord.fileIndex+=1
                        if (acWord.fileIndex == files.indexOf(fx)) {
                            acWord.fileIndex+=1
                        }
                    }
                    continue loopFind
                }
                if (!acWord.findUpDone && acWord.findDirection) {
                    found = acFindUp().word
                    if (found == "") {
                        acWord.findUpDone = true
                        continue loopFind
                    }
                    break loopFind
                }

                if (!acWord.findDownDone) {
                    found = acFindDown().word
                    if (found == "") {
                        acWord.findDownDone = true
                        continue loopFind
                    }
                }

                if (found == "") {
                    continue loopFind
                }

                break loopFind
            }

            // here we have found a word

            if (acWord.autocompleteLine || !fuzzyAutocomplete) {
                acPlop([trimPrefix(found, acWord.prefix)])
            } else {
                // don't trim prefix with fuzzy match
                acPlop([found])
            }
            break loopBlock
        }

        // here we have no prefix, not autocompleting
        if (!acWord.clearedWord && acWord.word != "") {
            acWord.clearedWord = true
            lastCleared = acWord.word
            acPlop([""])
            break loopBlock
        }

        if (!acWord.pastedLastTyped && lastWord && lastWord != acWord.word) {
            acWord.pastedLastTyped = true
            acPlop([lastWord])
            break loopBlock
        }

        if (!acWord.pasteLastCleared && lastCleared && lastCleared != acWord.word) {
            acWord.pasteLastCleared = true
            acPlop([lastCleared])
            break loopBlock
        }


        if (!acWord.pastedCopyBufferInLine && copyBuffer.length) {
            acWord.pastedCopyBufferInLine = true
            acPlop(copyBuffer)
            break loopBlock
        }

        // if (!acWord.pastedCutBufferInLine && cutBuffer.length) {
        //     acWord.pastedCutBufferInLine = true
        //     acPlop(cutBuffer)
        //     break loopBlock
        // }
        acWord.clearedWord = false
        acWord.pasteLastCleared = false
        acWord.pastedLastTyped = false
        acWord.pastedCopyBufferInLine = false
        // acWord.pastedCutBufferInLine = false
        acPlop([acWord.word])
    }
    acWord.toggleCount += 1
}

var inACPlop = false
function acPlop(buff) {
    if (buff[0].length > 0){
       acWord.hasPlopped = true
       setLastWord(buff.join("\n"))
    }
    inACPlop = true
    // TODO: compare with old implementation
    // replaceFindWord
    // this one calls more orher funcs like del()
    // and paste() and we might cause a little extra work
    var oldPreventRender = preventRender
    preventRender = true
    var oldCopyBuffer = copyBuffer
    var oldCutBuffer = cutBuffer
    copyBuffer = buff
    var oldSelectMode = selectMode

    var acWordStartX = acWord.startX
    var acWordStopX = acWord.stopX
    if (acWord.autocompleteLine || !fuzzyAutocomplete) {
        acWordStartX = acWord.startXNonFuzzy
        acWordStopX = acWord.stopXNonFuzzy
    }
    fx.selectedRegions = [{
        startX: acWordStartX,
        stopX: acWordStopX,
        startY: acWord.startY,
        stopY: acWord.stopY,
    }]
    selectMode = "char"
    del(true, true) // note that del does a lot more than maybe we need
    acWord.stopY = acWord.startY
    paste()
    acWord.stopY = acWord.startY + copyBuffer.length - 1
    if (copyBuffer.length == 1) {
        var theLine = fx.lines[fx.cursorLineIndex] || ""
        acWord.stopX = expandTabIndex(theLine, u(acWordStartX) + copyBuffer[0].length)
        acWord.stopXNonFuzzy = acWord.stopX
    } else {
        var lastCopyBufferLine = copyBuffer[copyBuffer.length - 1]
        // note. we don't cache this
        acWord.stopX = expandTabIndex(lastCopyBufferLine, lastCopyBufferLine.length, null, null, "nocache")
        acWord.stopXNonFuzzy = acWord.stopX
    }

    if (!acWord.autocompleteLine) {
        fx.cursorColIndex = acWord.stopX
    }
    fx.cursorLineIndex = acWord.stopY
    updateCursorXY()
    ensureCursorInScreen()
    copyBuffer = oldCopyBuffer
    cutBuffer = oldCutBuffer
    selectMode = oldSelectMode
    fx.selectedRegions = []
    preventRender = oldPreventRender
    render()
    inACPlop = false
}
function acFindUp() {
    var w = {start: -1, end: -1, word: ""}
    for (acWord.findUpY; acWord.findUpY>=0; acWord.findUpY--) {
        var line = files[acWord.fileIndex].lines[acWord.findUpY] || ""
        // so word being changed doesn't affect cursor
        if (acWord.fileIndex == files.indexOf(fx) && acWord.startY == acWord.findUpY) {
            line = acWord.origLine
        }
        if (acWord.findUpX < 0) {
            acWord.findUpX = line.length
        }

        if (acWord.autocompleteLine) {
            var trimmedLine = line.trim()
            if (trimmedLine.startsWith(acWord.prefix)) {
                // Also make sure it's not a regular word
                // because we would have seen it in the non autocompleteLine flow.
                if (isRegularWord(trimmedLine)) {
                    continue
                }
                // the start and end don't matter
                var seen = acWord.seen[trimmedLine]
                if (!seen) {
                    acWord.seen[trimmedLine] = true
                    return {word: trimmedLine}
                }
            }
            continue
        }

        for (acWord.findUpX; acWord.findUpX>=0; acWord.findUpX--) {
            w = getWordAt(line, acWord.findUpX)
            if (w.word != "") {
                acWord.findUpX = w.start - 1
            }
            var seen = acWord.seen[w.word]
            if (!seen && w.word != "" &&

                // fuzzy
                (acWord.prefix == "" || (w.word != acWord.prefix && isAutocompleteMatch(acWord.prefix, w.word))))
            {
                if (acWord.findUpX < 0) {
                    acWord.findUpY -= 1
                }
                acWord.seen[w.word] = true
                return w
            }
        }
    }
    return {start: -1, end: -1, word: ""}
}

function isAutocompleteMatch(prefix, word) {
    if (fuzzyAutocomplete) {
        return fuzzyMatch(prefix, word)
    } else {
        return word.startsWith(prefix)
    }
}

function acFindDown() {
    var w = {start: -1, end: -1, word: ""}
    for (acWord.findDownY; acWord.findDownY<files[acWord.fileIndex].lines.length; acWord.findDownY++) {
        var line = files[acWord.fileIndex].lines[acWord.findDownY] || ""

        if (acWord.autocompleteLine) {
            var trimmedLine = line.trim()
            if (trimmedLine.startsWith(acWord.prefix)) {
                // Also make sure it's not a regular word
                // because we would have seen it in the non autocompleteLine flow.
                if (isRegularWord(trimmedLine)) {
                    continue
                }
                // the start and end don't matter
                var seen = acWord.seen[trimmedLine]
                if (!seen) {
                    acWord.seen[trimmedLine] = true
                    return {word: trimmedLine}
                }
            }
            continue
        }

        for (acWord.findDownX; acWord.findDownX < line.length; acWord.findDownX++) {
            w = getWordAt(line, acWord.findDownX)
            if (w.word != "") {
                acWord.findDownX = w.end + 1
            }
            var seen = acWord.seen[w.word]
            if (!seen && w.word != "" &&
                // fuzzy
                (acWord.prefix == "" || (w.word != acWord.prefix && isAutocompleteMatch(acWord.prefix, w.word))))
            {
                if (acWord.findDownX >= line.length) {
                    acWord.findDownY += 1
                    acWord.findDownX = 0
                }
                acWord.seen[w.word] = true
                return w
            }
        }
        acWord.findDownX = 0
    }
    return {start: -1, end: -1, word: ""}
}
// END NEW FIND WORD
function doFormat() {
    if (!confirm("format code?")) {
        return
    }
    setLines(simpleFormat(fx.lines))
    docChanged()
    render()
}
function clearTrailingWhitespace() {
        scriptLinesWithOneLineScript(`x.replace(/\\s+$/, "")`)
}
function simpleFormat(lines) {
    // this will work as long as every indent
    // has another lone that "closes" it
    /*
    split lines
    store for each line if it's more intented
    or less indented
    */
    var newLines = []
    var lastSpaceCount = 0
    var currentIndent = 0
    for (var i=0; i<lines.length; i++) {
        var line = lines[i]
        if (line.trim() == "") {
            newLines.push("")
            continue
        }
        var spaceCount = getSpaceCount(line)
        if (spaceCount > lastSpaceCount) {
            currentIndent += 1
        } else if (spaceCount < lastSpaceCount) {
            currentIndent -= 1
        }
        if (currentIndent < 0) {
            currentIndent = 0
        }
        newLines.push(
            " ".repeat(globalTabStop * currentIndent) +
            line.trim()
        )

        lastSpaceCount = spaceCount
    }
    return newLines
}

function getSpaceCount(line) {
    spaceCount = 0
    for (var i=0; i<line.length; i++) {
        var chr = line[i]
        if (chr == " ") {
            spaceCount += 1
        } else if (chr == "\t") {
            spaceCount += globalTabStop
        } else {
            break
        }
    }
    return spaceCount
}

async function selectWorkspaceToolbar(e) {
    if (!e.target.hasAttribute("data-index")) {
        return
    }
    var index = e.target.getAttribute("data-index")
    // I guess we could have all the workspaces quietly.
    if (workspacesList[index].Name == workspaceName) {
        // make a new one
        index = "new"
    }
    await saveWorkspace()
    fetchWorkspaceWithList(index)
}


// if it's at 0 (or only ondented) you could do
// if, func, for, var!!

function selectFileRow(e) {
    if (!e.target.hasAttribute("data-index")) {
        // thinking we get here if they tap in the margin
        // or now the handle
        return
    }
    var index = e.target.getAttribute("data-index")

    selectFileIndex(index)
}
function selectFileIndex(index) {
    var file = files[index]
    // put it at the beginning.

    if (reorderFiles) {
        files.splice(index, 1)
        files.unshift(file)
    }
    setCurrentFile(file)
}

function moveFileAllTheWayLeft() {
    var theIndex = files.indexOf(fx)
    if (theIndex == -1) {
        return
    }
    if (theIndex == 0) {
        return
    }
    files.splice(theIndex, 1)
    files.splice(0, 0, fx)
    render()
    renderFileDropdown()
}
function moveFileLeft() {
    var theIndex = files.indexOf(fx)
    if (theIndex == -1) {
        return
    }
    if (theIndex == 0) {
        return
    }
    files.splice(theIndex, 1)
    files.splice(theIndex - 1, 0, fx)
    render()
    renderFileDropdown()
}
function moveFileRight() {
    var theIndex = files.indexOf(fx)
    if (theIndex == -1) {
        return
    }
    if (theIndex == files.length - 1) {
        return
    }
    files.splice(theIndex, 1)
    files.splice(theIndex+1, 0, fx)
    render()
    renderFileDropdown()
}

var uniqueID = 0
function getUniqueID() {
   uniqueID++
   return uniqueID
}

var fileToken = {}

function makeFile(fullPath, cursorLineIndex, contents) {
    var theLines = contents.split("\n")
    return {
        // fullPath should have the leading slash
        fullPath: fullPath,
        name: "",
        undo: {
            index: 0,
            stack: [contents],
            xStack: [0],
            yStack: [0],
            lastSavedLines: JSON.parse(JSON.stringify(theLines)),
            lastSavedHash: md5(contents),
        },
        lines: theLines,
        cursorLineIndex: cursorLineIndex,
        // cursorColIndex: 0,
        cursorColIndex: -marginLeft,
        // offsetY: cursorLineIndex, // you could get smarter about this
        offsetY: max(cursorLineIndex - Math.floor(maxLines/2), 0), // you can still clean this up a bit, not sure if maxLines is ready?
        offsetX: 0,
        fileMode: "file",
        shellCWD: "",
        version: 0,
        savedVersion: 0,
        savingVersion: -1,
        uniqueID: getUniqueID(),
        fileToken: fileToken,
        selectedRegions: [],

        lastOffsetY: -1,

        // copy color from current file
        color: window.fx ? fx.color : '',
        group: window.fx ? fx.group : '',
        highlightRanges: []
    }
}
function addFileToList(file, options) {
    options = options || {}
    if (initialFileAdding) {
        files.push(file)
    } else {
        // add it after current file if it exists in list, otherwise unshift it to the start.
        var theIndex = files.indexOf(fx)
        log("the start index is: " + theIndex)
        if (theIndex != -1) {
            var spliceIndex = theIndex + 1
            if (options.addBefore) {
                spliceIndex = theIndex
                log("did add before")
            }
            files.splice(spliceIndex, 0, file)
        } else {
            files.unshift(file)
        }
    }
    renderFileDropdown()
}
function addFile(fullPath, options, id, name) {
    options = options || {}
    fullPath = normalizeFullPath(fullPath)
    if (fullPath == "") {
        return
    }
    
    if (isGitBash && fullPath.startsWith("/c/")) {
        fullPath = fullPath.substr(3)
    }

    // adding file to list beforehand to preserve order

    var cursorLineIndex = 0
    var parts = fullPath.split(":")
    fullPath = parts[0]
    if (parts.length > 1) {
        cursorLineIndex = (parts[1] - 1) || 0
    }
    // If the file is already in the list of open files.
    // then let it have a reference to the existing lines, like vim does.
    for (var i=0; i<files.length; i++) {
        if (files[i].fullPath == fullPath) {
            return duplicateFile(files[i], cursorLineIndex, options, id)
        }
    }
    var file = makeFile(fullPath, cursorLineIndex, "")
    file.ID = id
    if (name) {
        file.name = name
    }
    addFileToList(file, options)
    if (!initialFileAdding) {
        if (!options.preventSelect) {
            setCurrentFile(file)
        }
        renderURL()
    }
    fetchFile(fullPath, file, id).then(() => {
        for (var i=0; i<files.length; i++) {
            if (files[i] != file && files[i].fullPath == file.fullPath) {
                // TODO: is this needed, I think duplicateFile should get these?
                files[i].lines = file.lines
                files[i].undo = file.undo
            }
        }
        updateCursorXY(file)
        ensureCursorInScreen(file)
        render()
    }).catch(e => {
        alert("Error loading file " + e)
    })
    return file
}

function verifyLoadedMD5(f, md5String) {
    if (!md5String) {
        return
    }
    if (md5String != f.undo.lastSavedHash) {
        log(`md5s don't match ${f.fullPath} ${md5String}; ${f.undo.lastSavedHash}`)
    }

}

var selectedButton = null
function renderFileDropdown() {
    fileRow.innerHTML = ""
    selectedButton = null
    for (var fileI=0; fileI<files.length; fileI++) {
        var file = files[fileI]
        // Todo, what causes this bug
        if (!file) {
            var err = new Error()
            log("null file error")
            log(err.stack)
            log({fileI, files})
            // this bug keeps biting me every once in a while
            alert("null file issue!! on " + fileI)
            return
        }
        // this is for the "grip handles" because we are experimenting with selecting files ontouchstart.
        // if (fileI % 5 == 0 && fileI != 0) {
        //     var button = document.createElement("div")
        //     button.className = "longButton handle"
        //     button.innerText = ""
        //     fileRow.appendChild(button)
        // }
        var button = document.createElement("div")
        button.className = "longButton"
        // button.className = "square"
        button.setAttribute("data-index", fileI)
        var theName = ""
        if (file.name) {
            theName = file.name
        } else {
            var parts = file.fullPath.split("/")
            theName = parts[parts.length - 1]
        }
        button.innerText = theName.substr(0, 15)
        if (fx == file) {
            button.classList.add("selected")
            selectedButton = button
        }

        button.style.position = "relative"
        if (file.color) {
            var colorDiv = document.createElement("div")
            colorDiv.style.width = "10px"
            colorDiv.style.height = "10px"
            colorDiv.style.backgroundColor = file.color
            colorDiv.style.position = "absolute"
            colorDiv.style.top = "2px"
            colorDiv.style.right = "2px"
            colorDiv.style.border = "none"
            colorDiv.style.borderRadius = "5px"
            button.appendChild(colorDiv)
        }
        if (file.group) {
            var groupDiv = document.createElement("div")
            // groupDiv.style.height = "10px"
            // groupDiv.style.width = "10px"
            groupDiv.style.position = "absolute"
            groupDiv.style.bottom = "1px"
            groupDiv.style.right = "1px"
            groupDiv.style.border = "none"
            groupDiv.innerText = file.group
            groupDiv.style.borderRadius = "2px"
            button.appendChild(groupDiv)
        }
        fileRow.appendChild(button)

    }
    
    // make sure selected button is in view.
    if (selectedButton) {
        if (selectedButton.offsetLeft + selectedButton.clientWidth > fileRow.scrollLeft + fileRow.clientWidth) {
            fileRow.scrollLeft = selectedButton.offsetLeft - fileRow.clientWidth + selectedButton.clientWidth
        }
        if (selectedButton.offsetLeft < fileRow.scrollLeft) {
            fileRow.scrollLeft = selectedButton.offsetLeft
        }
    }


    workspaceToolbar.innerHTML = ""
    for (var wI=0; wI<workspacesList.length; wI++) {
        var w = workspacesList[wI]
        var button = document.createElement("div")
        button.className = "longButton"
        button.setAttribute("data-index", wI)
        button.innerText = w.Name.substr(0, 15)
        // Maybe do workspace ids at some point.
        if (w.Name == workspaceName) {
            button.classList.add("selected")
        }

        if (w.Color) {
            var colorDiv = document.createElement("div")
            colorDiv.style.width = "10px"
            colorDiv.style.height = "10px"
            colorDiv.style.backgroundColor = file.color
            colorDiv.style.position = "absolute"
            colorDiv.style.top = "2px"
            colorDiv.style.right = "2px"
            colorDiv.style.border = "none"
            colorDiv.style.borderRadius = "5px"
            button.style.position = "relative"
            button.appendChild(colorDiv)
        }
        workspaceToolbar.appendChild(button)
    }
    
    
    renderSaves()

}
var treeFiles = []
var fileTree = {}
var treeFilesShadow = []
function treeToLines(theTree, path, indent, kPrefix) {
    var theKeys = Object.keys(theTree)
    theKeys.sort()
    // for (var k in theTree) {
    for (var ki = 0; ki < theKeys.length; ki++ ) {
        var k = theKeys[ki]

        var childKeys = Object.keys(theTree[k])
        // Do I need this?
        childKeys.sort()
        if (false && (childKeys.length == 1)) {
            kPrefix += k + "/"
            if (theTree[k][childKeys[0]].fileToken == fileToken) {
                treeFiles.push(indent + kPrefix + "/" + childKeys[0])
                treeFilesShadow.push(theTree[k][childKeys[0]])
            } else {
                newPath = path + "/" + k + "/" + childKeys[0]
                treeToLines(theTree[k][childKeys[0]], newPath, indent + "", kPrefix)
            }
            continue
        }

        kPrefix = ""
        if (theTree[k].fileToken == fileToken) {
            if (theTree[k].fileMode == "file") {
                treeFiles.push("" + indent + kPrefix + k)
            } else if (theTree[k].fileMode == "shell") {
                treeFiles.push("" + indent + kPrefix + k)
            } else if (theTree[k].fileMode == "terminal") {
                // same as others but a separate if statement so we can easily change it later
                treeFiles.push("" + indent + kPrefix + k)
            } else {
                treeFiles.push("" + indent + kPrefix + k)
            }
            // add that suffix if you want to show the line they are on
            // + "    " + (theTree[k].lines[theTree[k].cursorLineIndex]|| "").trim() )
            treeFilesShadow.push(theTree[k])
        } else {
            treeFiles.push("" + indent + kPrefix + k)
            var newPath = path + "/" + k
            treeFilesShadow.push(newPath)
            treeToLines(theTree[k], newPath, indent + "  ", "")
        }
    }
}

function getLinesForFileList() {
    fileTree = {}

    // reset the index
    for (var i=0; i<files.length; i++) {
        // tmpIndex should only be used in this function
        files[i].tmpIndex = i
    }

    // doing the slice so we don't mutate the original array
    var sortedFiles = files.slice().sort(function(f1, f2) {
        if (f1.fileMode == "shell") {
            // TODO: should we set the fullPath for shell to be the CWD?
            return (f1.shellCWD + f1.tmpIndex) > (f2.shellCWD + f2.tmpIndex)
        } else if (f1.fileMode == "terminal") {
            // #todoterminal: how get the cwd of the process (/proc/fd) ?
            return (f1.shellCWD + f1.tmpIndex) > (f2.shellCWD + f2.tmpIndex)
        } else {
            return (f1.fullPath + f1.tmpIndex) > (f2.fullPath + f2.tmpIndex)
        }
    })

    // taking advantage of sorted order here
    for (var fileI=0; fileI<sortedFiles.length; fileI++) {
        var f = sortedFiles[fileI]
        // var parts = (f.fullPath + ":" + (f.cursorLineIndex+1)).split("/")
        // var parts = (f.fullPath + "(" + (f.tmpIndex) + ")").split("/")
        
        var groupText = ""
        if (f.group) {
            groupText = " " + f.group + " "
        }
        var parts = (f.fullPath + groupText + "(" + (f.ID) + ")").split("/")
        // if (f.group) {
        //     parts[parts.length - 1] = f.group + ": " + parts[parts.length - 1]
        // }
        if (f.fileMode == "shell") {
            parts = ["(cmd)", (f.tmpIndex+"").padStart(2, "0") + ": " + (f.name || "")]
        } else if (f.fileMode == "terminal") {
            // #todoterminal: how get the cwd of the process (/proc/fd) ?
            parts = ["(terminal)", (f.tmpIndex+"").padStart(2, "0") + ": " + (f.name || "")]
        }
        // var parts = (f.fullPath).split("/")
        var curTree = fileTree
        for (var partI=0; partI<parts.length; partI++) {
           var part = parts[partI]
           if (part == "") {
              continue
           }

           var childTree = curTree[part]
           if (!childTree) {
              if (partI == parts.length-1) {
                  childTree = f
              } else {
                  childTree = {}
              }
              curTree[part] = childTree
           }
           curTree = childTree
        }
    }
    treeFiles = []
    treeFilesShadow = []

    if (showFilesFlatFirst) {
        treeFilesShadow.push("initialSeparator")
        treeFiles.push("-") // blank line do you can paste on top
        for (let i = 0; i < files.length; i++) {
            // treeFiles.push(files[i].fullPath.split("/").reverse().join(" < "))
            
            // treeFiles.push(files[i].name || files[i].fullPath.split("/").slice(-1)[0])
            var flatName = files[i].name || files[i].fullPath.split("/").slice(-1)[0]
            if (files[i].group) {
                flatName = files[i].group + ": " + flatName
            }
            treeFiles.push(flatName)
            
            // I wrote this so you could get rid of the last part if you want and only show the file name
            // treeFiles.push(files[i].name || files[i].fullPath.split("/").slice(-1)[0] + "\t\t\t\t< " + files[i].fullPath.split("/").reverse().slice(1).join(" < "))
            // treeFiles.push(files[i].name || files[i].fullPath.split("/").slice(-2).join("/"))
            // treeFilesShadow.push(files[i].fullPath)
            treeFilesShadow.push(files[i])
        }
        treeFiles.push("-")
        treeFilesShadow.push("treeSeparator")
    }

    treeToLines(fileTree, "", "", "")
    return treeFiles
}

function seeFiles() {
    if (fx.fileMode == "fileList") {
        setCurrentFile(lastFile)
        return
    }

    splicedFiles = []

    var contents = getLinesForFileList().join("\n")
    var f = makeFile("__", 0, contents)
    f.fileMode = "fileList"

    f.cursorLineIndex = 0
    f.cursorColIndex = -marginLeft
    var fileIndex = treeFilesShadow.indexOf(fx)
    if (fileIndex != -1) {
        f.cursorLineIndex = fileIndex
    }

    setCurrentFile(f)
    updateCursorXY()
    ensureCursorInScreen()
}

function setCurrentFile(file) {
    if (!file) {
        return
    }

    if (fx == file) {
        // go up a directory
        addFile(fx.fullPath.split("/").slice(0, -1).join("/"))
        return
    }

    // #filestuff
    // this check doesn't seem to work
    // alt-tab after viewing files is broken
    if (fx && fx.fileMode != "fileList" && fx != file) {
        lastFile = fx
    }
    fx = file
    if (fx.fileMode == "shell") {
        shellToolbar1.classList.remove("hidden")
        shellToolbar2.classList.remove("hidden")
        terminalToolbar1.classList.add("hidden")
        workspaceToolbar.classList.add("hidden")
        iframeToolbar1.classList.add("hidden")
        runScriptAndPasteButton.innerText = "run script"
    } else if (fx.fileMode == "terminal") {
        shellToolbar1.classList.add("hidden")
        shellToolbar2.classList.add("hidden")
        terminalToolbar1.classList.remove("hidden")
        workspaceToolbar.classList.add("hidden")
        iframeToolbar1.classList.add("hidden")
        runScriptAndPasteButton.innerText = "paste"
    } else if (fx.fileMode == "iframe") {
        shellToolbar1.classList.add("hidden")
        shellToolbar2.classList.add("hidden")
        terminalToolbar1.classList.add("hidden")
        workspaceToolbar.classList.add("hidden")
        iframeToolbar1.classList.remove("hidden")
        // something else can be done here? like refresh?
        runScriptAndPasteButton.innerText = "run script"
    } else {
        shellToolbar1.classList.add("hidden")
        shellToolbar2.classList.add("hidden")
        terminalToolbar1.classList.add("hidden")
        workspaceToolbar.classList.remove("hidden")
        iframeToolbar1.classList.add("hidden")
        runScriptAndPasteButton.innerText = "run script"
    }

    if (fx.fileMode == "iframe") {
        // c.style.display = "none"
        fx.iframeWrapper.style.display = "block"
        iframeCursor.style.display = "block"
        // c.style.display = "block"
    } else {
        iframeCursor.style.display = "none"
    }
    if (lastFile && lastFile.iframe) {
        lastFile.iframeWrapper.style.display = "none"
    }
    setCanvasHeightAccordingly()
    updateCursorXY()
    searchText.setAttribute("placeholder", fx.fullPath + " (search)")
    theText.setAttribute("placeholder", fx.fullPath.split("/").reverse().join(" < "))
    render()
    renderFileDropdown()

}

function duplicateFile(f, cursorLineIndex, options, id="") {
    options = options || {}
    if (f.fileMode == "terminal") {
        return
    }
    // TODO: maybe a more efficient way,
    // We copy all the lines here
    var fc = JSON.parse(JSON.stringify(f))
    fc.fileToken = fileToken
    fc.uniqueID = getUniqueID()
    fc.ID = id

    if (id == "") {
        fetch(proxyPath + "/duplfile?idtodup="+f.ID+"&id="+id, {
            cache: "no-cache"
        }).then(r => {
            if (r.headers.get("X-ID")) {
                fc.ID = r.headers.get("X-ID") - 0
            }
        }).catch(e => {
            alert("Error duplicating file " + e)
        })
    }
    // copy everything but reference lines
    fc.lines = f.lines
    fc.undo = f.undo
    if (window.fx) {
        fc.color = fx.color
    }
    addFileToList(fc, options)
    setCurrentFile(fc)
    if (cursorLineIndex != -1) {
        fc.cursorLineIndex = cursorLineIndex
        fc.offsetY = max(cursorLineIndex - Math.floor(maxLines/2), 0)
        ensureCursorInScreen()
    }
    renderURL()
    return fc
    // TODO: eventually, update cursor position
    // when text to one file is added.
}

function downloadFile() {
    var newFullPath = fx.fullPath
    if (fx.fileMode == "directory") {
        // see also clickItemInDirectory
        var prefix = fx.fullPath
        // To prevent leading double slash #duplicatelogic?
        if (prefix == "/") {
            prefix = ""
        }
        var addPath = fx.lines[fx.cursorLineIndex]
        newFullPath = prefix + "/" + addPath
    }
    window.open(proxyPath + "/saveload?fullpath=" + encodeURIComponent(newFullPath) + "&raw=1&download=1")
    // log(proxyPath + "/saveload?fullpath=" + encodeURIComponent(fx.fullPath) + "&raw=1&download=1")
}

// also see makeFile
function fetchFile(fullPath, file, id="") {
    var isDir = false
    var newID = 0
    var md5String = ""
    fullPath = normalizeFullPath(fullPath)
    return fetch(proxyPath + "/saveload?fullpath=" + encodeURIComponent(fullPath) + "&raw=1&id="+id, {
        cache: "no-cache"
    }).then(r => {
        if (r.headers.get("X-Is-Dir") == "1") {
            isDir = true
        }

        // only gets id if new file
        if (r.headers.get("X-ID")) {
            file.ID = r.headers.get("X-ID") - 0
        }
        md5String = r.headers.get("X-MD5")
        return r.text()
    }).then(b => {
        file.lines = b.split("\n")
        file.undo = {
            stack: [b],
            index:0,
            xStack: [0],
            yStack: [0],
            lastSavedLines: JSON.parse(JSON.stringify(file.lines)),
            lastSavedHash: md5(b),
        }
        file.loadedFirstTime = true
        if (isDir) {
            file.fileMode = "directory"
            file.cursorLineIndex = 1
        } else {
            file.fileMode = "file"
        }
        verifyLoadedMD5(file, md5String)
    }).catch(e => {
        alert("Error loading file " + e)
    })
}

function reloadAll() {
    var seen = {}
    for (var i=0; i<files.length; i++) {
        var theFile = files[i]
        if (!seen[theFile.fullPath]) {
            reloadFile(theFile)
        }
        seen[theFile.fullPath] = true
    }
}

function reloadFile(theFile) {
    theFile = theFile || fx
    if (theFile.fileMode != "file" && theFile.fileMode != "directory") {
        return
    }
    // Update all the other instances of this same file, no matter if it's the current file I guess
    fetchFile(theFile.fullPath, theFile, theFile.ID).then(() => {
        for (var i=0; i<files.length; i++) {
            if (files[i].fullPath == theFile.fullPath) {
                files[i].lines = theFile.lines
                files[i].undo = theFile.undo
            }
        }
        render()
    }).catch(e => {
        alert("Error loading file " + e)
    })

}

var inDebugView = false
function debugView() {
    inDebugView = !inDebugView
    if (inDebugView) {
       statusEl.classList.remove("hidden")
       logEl.classList.remove("hidden")
    } else {
       statusEl.classList.add("hidden")
       logEl.classList.add("hidden")
    }
    setCanvasHeightAccordingly()
}



var maxUndos = 30

var fx

var files = []
var workspacesList = []

var lines = []
// the actual lines will be put here by the server
// LINES GO HERE

var fileMode = "file"
// FILEMODE DIRECTORY GOES HERE

var rootLocation = "" // will be set server side
// ROOTLOCATION GOES HERE
// var paths = decodeURIComponent(location.pathname).split(",")
var paths = (location.pathname).split(",")

var firstFileMD5 = ""
// FIRSTFILEMD5 GOES HERE

// TODO: I don't think this is being used
var initialFileAdding = false



function fetchWorkspaceWithList(index) {
    // if (index != -1) {
    //     saveWorkspace()
    // }
    preventRender = true
    files = []
    // add exising files
    // TODO: you should hydrate this in the first pageload.
    // and maybe at least hydrate the first file.
    // #loadWorkspace
    
    var theUrl = proxyPath + "/myWorkspaceWithList" 
    if (index != -1) {
        theUrl += "?index=" + index
    }
    fetch(theUrl, {
        cache: "no-cache"
    }).then(r => {
        return r.json()
    }).then(workspaceWithList => {
        // alert(JSON.stringify(workspaceWithList, "", "  "))
        var workspace = workspaceWithList.workspace
        workspacesList = workspaceWithList.workspacesList
        workspaceName = workspace.Name
        for (var serverFile of workspace.Files) {
            // TODO: fix inconsistent file naming #inconsistentFileNaming
            if (serverFile.Type == "terminal") {
                addExistingTerminalTab(serverFile.ID, serverFile.Name, serverFile.CWD)
            } else if (serverFile.Type == "shell") {
                addCmdTab(serverFile.ID, serverFile.CWD, serverFile.Name)
            } else if (serverFile.Type == "iframe") {
                addIframe(serverFile.FullPath, serverFile.ID, serverFile.Name, serverFile.CWD)
            } else {
                addFile(serverFile.FullPath + ":" + (serverFile.LineNumber || 1), {preventSelect: false}, serverFile.ID, serverFile.Name)
            }
            // #serverAssignments
            fx.color = serverFile.Color
            fx.group = serverFile.Group || ""
            fx.highlightRanges = serverFile.HighlightRanges
        }
        initialFileAdding = false
        if (workspace.FontName) {
            selectFont(workspace.FontName)
        }
        if (workspace.FontScale) {
            // TODO: Maybe make a setter for this, like we have in selectFont
            fontScale = workspace.FontScale;
            updateFontScale()
        }
        if (workspace.DarkMode != isDark) {
            toggleDarkMode()
        }
        if (workspace.HighlightMatches) {
            highlightMatches = workspace.HighlightMatches
            processHighlightMatches()
        }
    
        preventRender = false
        render()
        renderDarkMode()
    }).catch(e => {
        alert("error loading files: " + e)
    })
}

fetchWorkspaceWithList(-1)


function saveWorkspace(oldWorkspaceName) {
    var tmpWorkspace = {
        DarkMode: isDark,
        FontName: currentFont.fontName,
        FontScale: fontScale,
        HighlightMatches: highlightMatches,
        Files: [],
        Name: workspaceName
    }
    for (var i = 0; i < files.length; i++) {
        var f = files[i]
        // TODO: fix inconsistent file naming #inconsistentFileNaming
        tmpWorkspace.Files.push({
            "ID": f.ID,
            "Name": f.name,
            "Type": f.fileMode,
            "FullPath": f.fullPath,
            "LineNumber": f.cursorLineIndex + 1,
            "CWD": f.shellCWD,
            "Color": f.color,
            "Group": f.group,
            "HighlightRanges": f.highlightRanges,
            // "HighlightText": f.highlightText,
        })
    }
    oldWorkspaceName = oldWorkspaceName || ""
    return fetch(proxyPath + "/mysaveworkspace?oldWorkspaceName=" + encodeURIComponent(oldWorkspaceName), {
        cache: "no-cache",
        method: "POST",
        body: JSON.stringify(tmpWorkspace),
    // }).then(r => {
    //     return r.json()
    // }).then(r => {
    }).catch(e => {
        alert("error saving workspace: " + e)
    })
}

function setHighlightMatches() {
    var lines = getSelectedLines(fx, false).lines
    highlightMatches = []
    for (var i = 0; i < lines.length; i++) {
        // reasonable limit
        if (i > 50) {
            break
        }
        var line = lines[i]
        if (line.startsWith("#") || line.startsWith("//") || line.trim() == "") {
            continue
        }
        var parts = line.split(" ")
        highlightMatches.push({
            Regex: parts.slice(0, -1).join(" "),
            // TODO: Change this on the back and frontend to Color.
            BackgroundColor: parts[parts.length-1] || "hotpink",
            // TextColor: parts[2] || "",
            // UnderlineColor: parts[3] || ""
        })
    }
    processHighlightMatches()
    saveWorkspace()
}

function processHighlightMatches() {
    // turn into one big regexp
    // var r = /(foo)|(bar)|(baz)/g
    // var matches = "hello baz and foo".matchAll(r)
    // var ret = JSON.stringify([...matches].map(function (x) {
    //     return {
    //         arr: x,
    //         index: x.index,
    //         length: x.length,
    //         input: x.input
    //     }
    // }), "","    ")
    // ret
    // [
    //     {
    //         "arr": [
    //             "baz",
    //             null,
    //             null,
    //             "baz"
    //         ],
    //         "index": 6,
    //         "length": 4,
    //         "input": "hello baz and foo"
    //     },
    //     {
    //         "arr": [
    //             "foo",
    //             "foo",
    //             null,
    //             null
    //         ],
    //         "index": 14,
    //         "length": 4,
    //         "input": "hello baz and foo"
    //     }
    // ]
    if (highlightMatches.length == 0) {
        highlightMatchesSingleRegExp = null
        return
    }
    var regStrs = []
    for (var i = 0; i < highlightMatches.length; i++) {
        var h = highlightMatches[i]
        regStrs.push("("+h.Regex+")")
    }
    try {
        highlightMatchesSingleRegExp = new RegExp(regStrs.join("|"), "g")
    } catch (e) {
        highlightMatchesSingleRegExp = null
    }
}



var ust = new URLSearchParams(window.location.search)
if (ust.has("dark")) {
    isDark = ust.get("dark") == "1"
}

function gotoDefinition() {
    var word = getWordAtCursor().word
    if (!word) {
        return
    }
    duplicateFile(fx, -1)
    fx.color = "hotpink"
    var oldSearchText = searchText.value
    if (fx.fullPath.endsWith(".html")) {
        searchText.value = "function " + word + "\\b"
        fx.cursorLineIndex = 0
        fx.cursorColIndex = 0
        findDown()
        searchText.value = oldSearchText
    }
}

function gotoDefinition_experimental() {
    langServer({
        jsonrpc: "2.0",
        method: "textDocument/definition",
        params: {
            textDocument: {
                uri: "file://" + fx.fullPath
            },
            position: {
                line: fx.cursorLineIndex,
                character: fx.cursorColIndex
            }
            // workDoneToken:
            // partialResultToken:
        }
    })
}

var jsonRPCID = 0
function langServer(jsonRPC) {
    jsonRPC.id = jsonRPCID++
    var body = JSON.stringify(jsonRPC)
    log(jsonRPC)
    fetch(proxyPath + "/mylangserver",  {
        cache: "no-cache",
        method: "POST",
        headers: {
            "Content-Type": "application/json-rpc",
            "Content-Length": body.length
        },
        body: body,
    }).then(r => {
        return r.json()
    }).then(r => {
        log(r)
    }).catch(e => {
        alert("error saving calling lang server: " + e)
    })
}


// let acl = new Accelerometer({frequency: 60});
// acl.addEventListener('reading', () => {
//    log
// });




// make sure when selecting in the margin
// that the selectMode is   line!
// add a threshold for move, like 5px or something.
// todo: in select mode, swipe down is paste. even paste over
// I turned off "Predictive" to get more vertical space
</script>
</body>
</html>
