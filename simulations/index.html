<!doctype html>
<title>Simulations</title>
<table>
<tr>
<td>
<canvas id=worldEl  width=1024 height=1024 style="width:512px; height:512px; border: 1px solid black;"></canvas>
</td>
<td>
<div>Ticks: <span id=tickCountEl></span></div>
<div>Population: <span id=populationCountEl></span></div>
<canvas id=graphEl width=1024 height=1024 style="width:512px; height:512px; border: 1px solid black;" style="border: 1px solid navy"></canvas>
</td>
</tr>
</table>

<script>
var populationCount = 500
var maxX = 2048
var maxY = maxX
var moveIncrement = 3


var tickDuration = 10
var renderEvery = 1

var chunksX = 128
var chunksY = chunksX
var chunkSizeX = maxX / chunksX
var chunkSizeY = chunkSizeX
var allowMove = true
var ageToReproduce = 10
var tickCount = 0
var maxPopulation = 2000

var sizeW = 10
var sizeH = 10

var colors = [
	"orange",
	"blue",
	"red",
	"black",
]
var happy = 0
var sad = 1
var mad = 2
var test = 3
var bitSet = [0b01, 0b10, 0b100, 0b1000]

var feelings = [happy, sad, mad, test]

var worldCtx = document.getElementById("worldEl").getContext("2d")

var feelglips = []
for (var i=0; i < populationCount; i++) {
	feelglips.push({x: r(maxX), y: r(maxY), w: sizeW, h: sizeH, feeling: feelings[r(3)], life: r(1000), age: 0})
}

worldEl.width = maxX
worldEl.height = maxY
worldEl.style.width = (maxX / 2) + "px"
worldEl.style.height = (maxY / 2) + "px"
// reset for testing
//feelglips = [
//	{x: 200, y: 200, w: 100, h: 100, feeling: happy},
//	{x: 250, y: 250, w: 100, h: 100, feeling: mad},
//]

var cachedLocations

var holes = []
function add(f) {
	index = holes.pop()	
	if (index === undefined) {
		if (feelglips.length < maxPopulation) {
			feelglips.push(f)
			populationCount += 1
		}
	} else {
		feelglips[index] = f
		populationCount += 1
	}
}

function tick() {
	tickCount += 1
	cachedLocations = {}

	for (var i=0; i<feelglips.length; i++) {
		var f = feelglips[i]
		if (f == null) {
			continue	
		}
		f.life -= 1
		f.age += 1
		if (f.life == 0) {
			feelglips[i] = null
			holes.push(i)
			populationCount -= 1
		}
		if (!allowMove) {
			var movement = -1
		} else {
			var movement = r(4)
		}
		if (movement == 0) {
			f.x -= moveIncrement
		} else if (movement == 1) {
			f.x += moveIncrement
		} else if (movement == 2) {
			f.y -= moveIncrement
		} else if (movement == 3) {
			f.y += moveIncrement
		}

		if (f.x < 0) {
			f.x = 0		
		} else if (f.x > maxX) {
			f.x = maxY	
		}

		if (f.y < 0) {
			f.y = 0		
		} else if (f.y > maxY) {
			f.y = maxY	
		}
		var chunkX = Math.floor(f.x / chunkSizeX)
		var chunkY = Math.floor(f.y / chunkSizeY)
		var key = chunkX + "_" + chunkY
		if (cachedLocations[key]) {
			cachedLocations[key].push(f)	
		} else {
			cachedLocations[key] = [f]
		}
	}

	// move all at once, then check overlap
	// TODO: you would need to actually check surrounding chunks
	// This is not a perfect simulation because of that
	
	// Now let's to the touching check
	for (key in cachedLocations) {
		var fs = cachedLocations[key]	
		if (!fs ||  fs.lenth == 0) {
			continue	
		}

		for (var i=0; i < fs.length;i++) {
			var a = fs[i]
			if (i.age < ageToReproduce) {
				continue	
			}
			for (var j=i+1; j<fs.length; j++) {
				var b = fs[j]
				if (b.age < ageToReproduce) {
					continue	
				}
				if (
						a.x < b.x + b.w &&
						a.x + a.w > b.x &&
						a.y < b.y + b.h &&
						a.y + a.h > b.y
				) {
					// This is the part where we put the rules of what happens
					// when they touch.
					var combined = bitSet[a.feeling] | bitSet[b.feeling]
					//a.feeling = test
					//b.feeling = test
					switch (combined) {
					case bitSet[happy] | bitSet[mad]:
						add({x:a.x, y:a.y, w:sizeW, h: sizeH, feeling: sad, age: 0, life: r(1000)})
						break
					case bitSet[happy] | bitSet[sad]:
						add({x:a.x, y:a.y, w:sizeW, h: sizeH, feeling: happy, age: 0, life: r(1000)})
						break
					case bitSet[sad]:
						//add({x:a.x, y:a.y, w:sizeW, h: sizeH, feeling: happy, age: 0, life: r(1000)})
						add({x:a.x, y:a.y, w:sizeW, h: sizeH, feeling: mad, age: 0, life: r(1000)})
						break
					case bitSet[mad]:
						add({x:a.x, y:a.y, w:sizeW, h: sizeH, feeling: sad, age: 0, life: r(1000)})
						break
					}
					//a.feeling = "test"						
					//b.feeling = "test"						
				}
			}	
		}
	}

	
	render()
}

setInterval(tick, tickDuration)


function render() {
	if (tickCount % renderEvery != 0) {
		return	
	}

	worldEl.width = worldEl.width // hack to clear
	worldEl.width = worldEl.width // hack to clear
	tickCountEl.innerText = tickCount
	populationCountEl.innerText = populationCount
	for (var i=0; i<feelglips.length;i++) {
		var f = feelglips[i]
		if (f == null) {
			continue
		}
		worldCtx.fillStyle = colors[f.feeling]
		worldCtx.fillRect(f.x, f.y, f.w, f.h)
	}
}

function r(n) {
	return Math.floor(Math.random() * n)
}


</script>
